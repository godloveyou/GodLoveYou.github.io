---
title: java面试系列问题(1)
categories: java

tags:
- 面试
---

### 1. final, finally, finalize 的区别  
 final它是java中的一个关键字和修饰符,用于声明属性,方法，类，分别标书修饰的属性不可变,方法不可覆盖,类不可继承  
 
 finally是异常处理语句结构的一部分，表示总是执行,使用 finally 可以维护对象的内部状态，并可以清理非内存资源 
  
 finallize这个方法是Object类的一个方法，因此所有类都继承了它,当垃圾收集器确定某个对象不再被引用时，会调用该方法做清理工作,如果想要执行自定义的清理工作，可以在子类中覆盖该方法.

--- 
### 2. Exception、Error、运行时异常与一般异常有何异同  
https://blog.csdn.net/m0_37531231/article/details/79502778(参考)
![Java异常类层次结构图](https://img-blog.csdn.net/20180309211054853?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbTBfMzc1MzEyMzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

Error层次结构描述了java运行时系统的内部错误和资源耗尽错误。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题

Exceprion这个层次结构又分解为连个分支：一个分支派生于RuntimeException；另一个分支包含其他异常。划分两个分支的规则是：由程序错误导致的异常属于RuntimeException；而程序本身没有没有问题，但由于像I/O错误这类异常导致的异常属于其他异常  


### 3. 请写出5种常见到的runtime exception
NullpointerExection IndexOutOfBoundsException NumberFormatException FileNotFoundException EofException


### 4. int 和 Integer 有什么区别，Integer的值缓存范围  
int是java中基本数据类型，Integer是对象类型,它是int的包装类
java对于-128到127之间的数，会进行缓存

### 5.包装类，装箱和拆箱  
Java中的基本类型功能简单，不具备对象的特性，为了使基本类型具备对象的特性，所以出现了包装类，就可以像操作对象一样操作基本类型数据  

装箱就是 自动将基本数据类型转换为包装器类型；拆箱就是  自动将包装器类型转换为基本数据类型。

```
java5之前如果要定义一个值为10的Integer对象 必须这样定义 Integer i = new Integer(10)
Integer i = 10;  //装箱
int n = i;   //拆箱
```


### 6.String、StringBuilder、StringBuffer 
1.执行速度StringBuilder > StringBuffer > String
2. 操作少量数据用String, 单线程下操作大量字符串数据用StringBuilder, 多线程下操作大量数据用StringBuffer


### 7.重载和重写的区别
重载(Overload): 
方法名称相同, 参数个数或类型不同，可以有不同的返回类型,可以有不同的访问修饰符,可以抛出不同的异常.  

重写(Override): 
参数列表与被重写的方法相同，返回类型与被重写的方法一致，访问修饰符要大于被重写方法的修饰符  


### 8.抽象类和接口有什么区别
1.抽象类可以有默认的方法实现,接口完全是抽象的不存在方法实现
2.抽象类可以有构造器, 接口没有构造器
3.抽象类的修饰符可以是public,protected,default; 接口默认都是public,不能使用其他修饰符
4.抽象类比接口速度更快，因为接口需要寻找它的实现类
5.抽象类可以继承1个类并可以实现多个接口， 接口只能实现接口 不能继承接口

### 9.说说反射的用途及实现
反射是java的特征之一, 通过反射我们可以在程序运行时获知程序的每个属性和方法
用途:
	反射最重要的用途就是开发各种通用框架
	很多框架（比如 Spring）都是配置化的（比如通过 XML文件配置 JavaBean，Action之类的），为了保证框架的通用性，他们可能根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。
举一个例子，在运用Struts 2框架的开发中我们一般会在struts.xml里去配置Action，比如

```
    <action name="login" class="org.ScZyhSoft.test.action.SimpleLoginAction"  method="execute">  
       <result>/shop/shop-index.jsp</result>  
       <result name="error">login.jsp</result>  
    </action>
```

配置文件与Action建立了一种映射关系，当View层发出请求时，请求会被StrutsPrepareAndExecuteFilter拦截，然后StrutsPrepareAndExecuteFilter会去动态地创建Action实例。
——比如我们请求login.action，那么StrutsPrepareAndExecuteFilter就会去解析struts.xml文件，检索action中name为login的Action，并根据class属性创建SimpleLoginAction实例，并用invoke方法来调用execute方法，这个过程离不开反射。
对与框架开发人员来说，反射虽小但作用非常大，它是各种容器实现的核心。而对于一般的开发者来说，不深入框架开发则用反射用的就会少一点，不过了解一下框架的底层机制有助于丰富自己的编程思想，也是很有益的。


### 10.说说自定义注解的场景及实现
场景：日志管理，缓存处理，权限验证等
实现：在需要验证的地方增加一个切面，通过反射获取方法所包含的注解，比如包含自定义的注解，就进行相应的功能处理


### 11.HTTP请求的GET与POST方式的区别
GET请求：请求参数会被拼接到URL后,可以拼接的长度受限制，而且如果有敏感信息 相对是不安全的
POST请求: 为了克服GET请求的限制，post传递参数会被放入请求体中，可以发送的参数数目不受限制，因为外部不可见，因此相对安全

### 12.Session与Cookie区别
session是基于服务端的会话管理，用于跟踪用户状态 这个数据可以保存在内存中，数据库中或者集群中
cookie是基于客户端的会话管理,数据保存在客户端中

### 13.列出自己常用的JDK包
java.util.* java.io.*

### 14.MVC设计思想
MODEL模型用来封装业务逻辑，
VIEW 视图用来实现表示逻辑，
Controller 控制器用来协调模型与视图(视图要通过控制器来调用模型，模型返回的处理结果也要先交给控制器，由控制器来选择合适的视图来显示 处理结果)。
这种设计思想 可以使各个层之间相互独立 又能相互协作，可以是业务逻辑与我们表现层视图进行解耦，有利于分工合作及快速开发

### 15.equals与==的区别
equals和==的第一个区别就是  他们一个是方法，一个是运算符，它们比较的都是物理地址 而不是值得比较
Java 语言里的 equals方法其实是交给开发者去覆写的，让开发者自己去定义满足什么条件的两个Object是equal的

由于String对象中重写了equals方法 当物理地址不同时，会进一步比较值，所以比较字符串时我们是用equals方法
如果我们要重写一个对象比如Student的equals方法，必须要同时重写equals() 和hashcode()方法,因为只重写equals方法是无法改变hashcode值的 而比较时首先比较的就是hashcode，所以我们通常是在编辑器中 右键->source->generate hashcode() and equals() 来实现。



### 16.什么是Java序列化和反序列化，如何实现Java序列化？或者请解释Serializable 接口的作用
* 序列化：把对象转换为字节序列的过程
* 反序列化: 把字节序列转化为对象的过程
对象序列化用途：
1.将对象字节序列永久保存在硬盘上 通常保存在一个文件中
2.在网络上传送对象的字节序列

* java.io.ObjectOutputStream代表对象输出流，它的writeObject(Object obj)方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。
* java.io.ObjectInputStream代表对象输入流，它的readObject()方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。 


```java 
    ObjectOutputStream oo = new ObjectOutputStream(new FileOutputStream( 
              new File("E:/Person.txt"))); 
   	oo.writeObject(person); 
   	System.out.println("Person对象序列化成功！"); 
```





### 17.Object类中常见的方法，为什么wait  notify会放在Object里边？
简单说：因为synchronized中的这把锁可以是任意对象，所以任意对象都可以调用wait()和notify()；所以wait和notify属于Object。

专业说：因为这些方法在操作同步线程时，都必须要标识它们操作线程的锁，只有同一个锁上的被等待线程，可以被同一个锁上的notify唤醒，不可以对不同锁中的线程进行唤醒。
也就是说，等待和唤醒必须是同一个锁。而锁可以是任意对象，所以可以被任意对象调用的方法是定义在object类中。


### 18.Java的平台无关性如何体现出来的
* Java程序则编译为字节码。字节码本身不能运行，因为它不是原生代码。字节码只能够在Java虚拟机（JVM）上运行
* JVM是一个原生应用程序，它负责解释字节码。通过使用JVM可用在众多的平台上（这也就是Java可以做到平台无关性的原因），Sun公司将Java变成了跨平台的语言。如下图模型，完全相同的字节码可以在已经开发了JVM的任何操作系统上运行
![传统](https://img-blog.csdn.net/20160708143840579)


### 19.JDK和JRE的区别
* JDK（Java Development Kit）JDK是整个JAVA的核心，包括了Java运行环境JRE（Java Runtime Envirnment）、一堆Java工具（javac/java/jdb等）和Java基础的类库
* Java Runtime Environment（JRE）他就是java运行环境 并不是一个开发环境，所以没有包含任何开发工具

### 20.Java 8有哪些新特性

### 21.Java常见集合
ArrayList,LinkedList,HashMap,HashTable,Set,HashSet,TreeSet

### 22.List 和 Set 区别
* 1.List,Set都实现了Collection接口
* 2.List它是一个有序的集合输出顺序就是插入顺序，可以允许插入重复对象，可以插入null元素，常用的实现有ArrayList,LinkedList,Vector
* 3.Set 是一一个无序的容器(存入和取出顺序不一定一致)，不允许插入重复对象,常用实现HashSet,LinkedHashSet,TreeSet


### 23.HashSet如何保证数据唯一性？
HashSet底层数据接口是哈希表,怎样保证数据唯一性呢？它是通过HashCode和equals来完成的，
如果元素的Hashcode值相同,才会判断equals是否为true,如果hashcode值不同，不会调用equals方法

在java的集合中，判断两个对象是否相等的规则是:
判断两个对象的hashCode否相等
1. 如果相等 就认为两个对象不相等，完毕
2. 如果不相等，调用对象的equals()方法判断是否相等，如果不相等，认为两个对象也不相等

为什么要通过hashCode()和equlas()两条规则呢? 
 因为hashCode()相等时 equlas()也可能不相等，String,Double类都重写了hashCode()方法和equlas()方法，我们自己定义的对象也可以重写hashCode()和equlas()方法

### 24.List 和 Map 区别
List是有顺序的集合，Map是通过键值对存取的容器,Key和Value一一对应
Set,List都继承自Collection接口,List接口有三个实现类：ArrayList，Vector，LinkedList
HashMap,HashTable实现了  Map<E,V>接口

### 25.Arraylist 与 LinkedList 区别
ArrayList,LinkedList是List接口的两个实现类，他们都实现了List接口的方法,只是实现的方式不同

ArrayList它是以数组的方式来实现的,数组的特性是可以使用索引的方式来快速定位对象的位置,因此对于快速的随机取得对象的需求,使用ArrayList实现执行效率上会比较好
LinkedList是采用链表的方式来实现List接口的,它本身有自己特定的方法，如: addFirst(),addLast(),getFirst(),removeFirst()等. 由于是采用链表实现的,因此在进行insert和remove动作时在效率上要比ArrayList要好得多!适合用来实现Stack(堆栈)与Queue(队列),前者先进后出，后者是先进先出.

### 26.在删除可插入对象的动作时，为什么ArrayList的效率会比较低呢?
ArrayList是使用数组实现的,若要从数组中删除或插入某一个对象，需要移动后段的数组元素，从而会重新调整索引顺序,调整索引顺序会消耗一定的时间，所以速度上就会比LinkedList要慢许多. 相反,LinkedList是使用链表实现的,若要从链表中删除或插入某一个对象,只需要改变前后对象的引用即可

### 27.ArrayList 与 Vector 区别
List接口有三个实现类：ArrayList，Vector，LinkedList
1） Vector的方法都是同步的(Synchronized),是线程安全的(thread-safe)，而ArrayList的方法不是，由于线程的同步必然要影响性能，因此,ArrayList的性能比Vector好。
2） 当Vector或ArrayList中的元素超过它的初始大小时,Vector会将它的容量翻倍,而ArrayList只增加50%的大小，这样,ArrayList就有利于节约内存空间。

### 28.HashMap 和 Hashtable 的区别
1)HashMap线程不安全，HashTable线程安全，HashMap性能要好一点儿
2)HashMap中key和value可以为null, HashTable中key和value都不能为null

### 29.HashSet 和 HashMap 区别
1) HashSet实现了Set接口，它不允许集合中出现重复元素。当我们提到HashSet时，第一件事就是在将对象存储在 HashSet之前，要确保重写hashCode（）方法和equals（）方法，这样才能比较对象的值是否相等，确保集合中没有 储存相同的对象
2) HashMap实现了Map接口 Map接口对键值对进行映射。HashMap中根据key来计算hashcode, HashSet中使用成员对象来计算HashCode,对于两个对象来说hashCode值可能相同，因此如果两个对象hashcode相同的情况下会继续调用equals()方法
判断对象的相等性，相等返回true,否则返回false.


### 30. HashMap 和 ConcurrentHashMap 的区别
1) ConcurrentHashMap是线程安全的 具体是怎么实现线程安全的呢，肯定不可能是每个方法加synchronized，那样就变成了HashTable。它引入了一个“分段锁”的概念，具体可以理解为把一个大的Map拆分成N个小的HashTable，根据key.hashCode()来决定把key放到哪个HashTable中

2）在ConcurrentHashMap中，就是把Map分成了N个Segment，put和get的时候，都是现根据key.hashCode()算出放到哪个Segment中


### 31.Java中native方法使用场景？
1）在方法中调用一些不是由java语言写的代码。

2）在方法中用java语言直接操纵计算机硬件。


---


### 33.JVM运行时内存区域划分
![jvm内存划分](https://img-blog.csdn.net/20170722164426883?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbm9hbWFuX3dncw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

1.程序计数器（线程私有）
程序计数器 通常占用很小的一块儿内存, 它用于存放当前线程执行的字节码的行号指示器
为什么需要程序计数器呢？因为java虚拟机中多线程是通过线程不断切换获得CPU执行时间进行的，为了处理器切换线程时能够回到之前所执行的位置, 每个线程都要有一个程序计数器,记录当前线程执行的字节码位置,所以是线程私有的.

2.java虚拟机栈(线程私有)
虚拟机栈描述的是Java 方法执行的内存模型：每个方法被执 行的时候都会同时创建一个栈帧（Stack Frame ①）用于存储局部变量表、操作栈、动态链接、方法出口等信息。
每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

* 注意：1.局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用
* 两种异常
1.StackOverflowError 如果线程申请的栈深度大于虚拟机允许的栈深度时，抛出这个错误
2.OutOfMemoryError 当虚拟机栈扩展时 无法申请到足够的内存 就会抛出这个错误.

3.本地方法栈 (Native Method Stacks) 线程私有
本地方法栈与虚拟机栈所发挥的作用是非常相似的,区别就是 虚拟机栈为执行的java方法服务，而本地方法栈为虚拟机使用到的Native方法(本地方法)服务

4.java堆（线程共享）
Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的 唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存
主要用来存放对象实例和数组，它是垃圾收集器管理的主要区域


5.方法区（非堆内存）Non-heap（线程共享）
用于存储被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据
根据Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError 异常

运行时常量池
运行时常量池是方法区的一部分，主要存储编译期生成的各种字面量和符号引用

### JVM如何设置参数
Linux下 在catalina.sh中设置如下参数
JAVA_OPTS="-Xms128m -Xmx512m -XX:PermSize=128m -XX:MaxPermSize=256m"  

* Xms  			  jvm初始分配的堆内存大小
* Xmx  			  jvm最大允许分配的堆内存，按需分配
* XX:PermSize    jvm初始分配的非堆内存大小
* XX:MaxPermSize jvm最大允许分配的非堆内存




### 34.常见的设计模式

设计模式的的六大原则及其含义

常见的单例模式以及各种实现方式的优缺点，哪一种最好，手写常见的单利模式

设计模式在实际场景中的应用

Spring中用到了哪些设计模式

MyBatis中用到了哪些设计模式

你项目中有使用哪些设计模式

说说常用开源框架中设计模式使用分析

动态代理很重要！！！

1.7、数据结构

树（二叉查找树、平衡二叉树、红黑树、B树、B+树）

深度有限算法、广度优先算法

克鲁斯卡尔算法、普林母算法、迪克拉斯算法

什么是一致性Hash及其原理、Hash环问题

常见的排序算法和查找算法：快排、折半查找、堆排序等

1.8、网络/IO基础
BIO、NIO、AIO的概念

什么是长连接和短连接

Http1.0和2.0相比有什么区别，可参考《Http 2.0》

Https的基本概念

三次握手和四次挥手、为什么挥手需要四次

从游览器中输入URL到页面加载的发生了什么？可参考《从输入URL到页面加载发生了什么》

二、数据存储和消息队列

2.1、数据库
MySQL 索引使用的注意事项

DDL、DML、DCL分别指什么

explain命令

left join，right join，inner join

数据库事物ACID（原子性、一致性、隔离性、持久性）

事物的隔离级别（读未提交、读以提交、可重复读、可序列化读）

脏读、幻读、不可重复读

数据库的几大范式

数据库常见的命令

说说分库与分表设计

分库与分表带来的分布式困境与应对之策（如何解决分布式下的分库分表，全局表？）

说说 SQL 优化之道

MySQL遇到的死锁问题、如何排查与解决

存储引擎的 InnoDB与MyISAM区别，优缺点，使用场景

索引类别（B+树索引、全文索引、哈希索引）、索引的原理

什么是自适应哈希索引（AHI）

为什么要用 B+tree作为MySQL索引的数据结构

聚集索引与非聚集索引的区别

遇到过索引失效的情况没，什么时候可能会出现，如何解决

limit 20000 加载很慢怎么解决

如何选择合适的分布式主键方案

选择合适的数据存储方案

常见的几种分布式ID的设计方案

常见的数据库优化方案，在你的项目中数据库如何进行优化的

2.2、Redis
Redis 有哪些数据类型，可参考《Redis常见的5种不同的数据类型详解》

Redis 内部结构

Redis 使用场景

Redis 持久化机制，可参考《使用快照和AOF将Redis数据持久化到硬盘中》

Redis 集群方案与实现

Redis 为什么是单线程的？

缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级

使用缓存的合理性问题

Redis常见的回收策略

2.3、消息队列
消息队列的使用场景

消息的重发补偿解决思路

消息的幂等性解决思路

消息的堆积解决思路

自己如何实现消息队列

如何保证消息的有序性

三、开源框架和容器
3.1、SSM/Servlet
Servlet的生命周期

转发与重定向的区别

BeanFactory 和 ApplicationContext 有什么区别

Spring Bean 的生命周期

Spring IOC 如何实现

Spring中Bean的作用域，默认的是哪一个

说说 Spring AOP、Spring AOP 实现原理

动态代理（CGLib 与 JDK）、优缺点、性能对比、如何选择

Spring 事务实现方式、事务的传播机制、默认的事务类别

Spring 事务底层原理

Spring事务失效（事务嵌套），JDK动态代理给Spring事务埋下的坑，可参考《JDK动态代理给Spring事务埋下的坑！》

如何自定义注解实现功能

Spring MVC 运行流程

Spring MVC 启动流程

Spring 的单例实现原理

Spring 框架中用到了哪些设计模式

Spring 其他产品（Srping Boot、Spring Cloud、Spring Secuirity、Spring Data、Spring AMQP 等）

有没有用到Spring Boot，Spring Boot的认识、原理

MyBatis的原理

可参考《为什么会有Spring》

可参考《为什么会有Spring AOP》

3.2、Netty
为什么选择 Netty

说说业务中，Netty 的使用场景

原生的 NIO 在 JDK 1.7 版本存在 epoll bug

什么是TCP 粘包/拆包

TCP粘包/拆包的解决办法

Netty 线程模型

说说 Netty 的零拷贝

Netty 内部执行流程

Netty 重连实现

3.3、Tomcat

Tomcat的基础架构（Server、Service、Connector、Container）

Tomcat如何加载Servlet的

Pipeline-Valve机制

可参考：《四张图带你了解Tomcat系统架构！》

四、分布式
4.1、Nginx
请解释什么是C10K问题或者知道什么是C10K问题吗？

Nginx简介，可参考《Nginx简介》

正向代理和反向代理.

Nginx几种常见的负载均衡策略

Nginx服务器上的Master和Worker进程分别是什么

使用“反向代理服务器”的优点是什么?

4.2、分布式其他
谈谈业务中使用分布式的场景

Session 分布式方案

Session 分布式处理

分布式锁的应用场景、分布式锁的产生原因、基本概念

分布是锁的常见解决方案

分布式事务的常见解决方案

集群与负载均衡的算法与实现

说说分库与分表设计，可参考《数据库分库分表策略的具体实现方案》

分库与分表带来的分布式困境与应对之策

4.3、Dubbo

什么是Dubbo，可参考《Dubbo入门》

什么是RPC、如何实现RPC、RPC 的实现原理，可参考《基于HTTP的RPC实现》

Dubbo中的SPI是什么概念

Dubbo的基本原理、执行流程

五、微服务

5.1、微服务

前后端分离是如何做的？

微服务哪些框架

Spring Could的常见组件有哪些？可参考《Spring Cloud概述》

领域驱动有了解吗？什么是领域驱动模型？充血模型、贫血模型


### JWT有了解吗，什么是JWT，可参考《前后端分离利器之JWT》 
https://blog.csdn.net/bntx2jsqfehy7/article/details/79224042

你怎么理解 RESTful

说说如何设计一个良好的 API

如何理解 RESTful API 的幂等性

如何保证接口的幂等性

说说 CAP 定理、BASE 理论

怎么考虑数据一致性问题

说说最终一致性的实现方案

微服务的优缺点，可参考《微服务批判》

微服务与 SOA 的区别

如何拆分服务、水平分割、垂直分割

如何应对微服务的链式调用异常

如何快速追踪与定位问题

如何保证微服务的安全、认证

5.2、安全问题
如何防范常见的Web攻击、如何方式SQL注入

服务端通信安全攻防

HTTPS原理剖析、降级攻击、HTTP与HTTPS的对比

5.3、性能优化
性能指标有哪些

如何发现性能瓶颈

性能调优的常见手段

说说你在项目中如何进行性能调优

六、其他
6.1、设计能力
说说你在项目中使用过的UML图

你如何考虑组件化、服务化、系统拆分

秒杀场景如何设计

可参考：《秒杀系统的技术挑战、应对策略以及架构设计总结一二！》

6.2、业务工程
说说你的开发流程、如何进行自动化部署的

你和团队是如何沟通的

你如何进行代码评审

说说你对技术与业务的理解

说说你在项目中遇到感觉最难Bug，是如何解决的

介绍一下工作中的一个你认为最有价值的项目，以及在这个过程中的角色、解决的问题、你觉得你们项目还有哪些不足的地方

6.3、软实力
说说你的优缺点、亮点

说说你最近在看什么书、什么博客、在研究什么新技术、再看那些开源项目的源代码

说说你觉得最有意义的技术书籍

工作之余做什么事情、平时是如何学习的，怎样提升自己的能力

说说个人发展方向方面的思考

说说你认为的服务端开发工程师应该具备哪些能力

说说你认为的架构师是什么样的，架构师主要做什么

如何看待加班的问题