---
title: java面试系列问题(1)
categories: java

tags:
- 面试
---

### 1. final, finally, finalize 的区别  
 final它是java中的一个关键字和修饰符,用于声明属性,方法，类，分别标书修饰的属性不可变,方法不可覆盖,类不可继承  
 
 finally是异常处理语句结构的一部分，表示总是执行,使用 finally 可以维护对象的内部状态，并可以清理非内存资源 
  
 finallize这个方法是Object类的一个方法，因此所有类都继承了它,当垃圾收集器确定某个对象不再被引用时，会调用该方法做清理工作,如果想要执行自定义的清理工作，可以在子类中覆盖该方法.

--- 
### 2. Exception、Error、运行时异常与一般异常有何异同  
https://blog.csdn.net/m0_37531231/article/details/79502778(参考)
![Java异常类层次结构图](http://pam1kb0ai.bkt.clouddn.com/java%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB.png)

Error层次结构描述了java运行时系统的内部错误和资源耗尽错误。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题

Exceprion这个层次结构又分解为连个分支：一个分支派生于RuntimeException；另一个分支包含其他异常。划分两个分支的规则是：由程序错误导致的异常属于RuntimeException；而程序本身没有没有问题，但由于像I/O错误这类异常导致的异常属于其他异常  


### 3. 请写出5种常见到的runtime exception
NullpointerExection IndexOutOfBoundsException NumberFormatException FileNotFoundException EofException


### 4. int 和 Integer 有什么区别，Integer的值缓存范围  
int是java中基本数据类型，Integer是对象类型,它是int的包装类
java对于-128到127之间的数，会进行缓存

### 5.包装类，装箱和拆箱  
Java中的基本类型功能简单，不具备对象的特性，为了使基本类型具备对象的特性，所以出现了包装类，就可以像操作对象一样操作基本类型数据  

装箱就是 自动将基本数据类型转换为包装器类型；拆箱就是  自动将包装器类型转换为基本数据类型。

```
java5之前如果要定义一个值为10的Integer对象 必须这样定义 Integer i = new Integer(10)
Integer i = 10;  //装箱
int n = i;   //拆箱
```


### 6.String、StringBuilder、StringBuffer 
1.执行速度StringBuilder > StringBuffer > String
2. 操作少量数据用String, 单线程下操作大量字符串数据用StringBuilder, 多线程下操作大量数据用StringBuffer


### 7.重载和重写的区别
重载(Overload): 
方法名称相同, 参数个数或类型不同，可以有不同的返回类型,可以有不同的访问修饰符,可以抛出不同的异常.  

重写(Override): 
参数列表与被重写的方法相同，返回类型与被重写的方法一致，访问修饰符要大于被重写方法的修饰符  


### 8.抽象类和接口有什么区别
1.抽象类可以有默认的方法实现,接口完全是抽象的不存在方法实现
2.抽象类可以有构造器, 接口没有构造器
3.抽象类的修饰符可以是public,protected,default; 接口默认都是public,不能使用其他修饰符
4.抽象类比接口速度更快，因为接口需要寻找它的实现类
5.抽象类可以继承1个类并可以实现多个接口， 接口只能实现接口 不能继承接口

### 9.说说反射的用途及实现
反射是java的特征之一, 通过反射我们可以在程序运行时获知程序的每个属性和方法
用途:
	反射最重要的用途就是开发各种通用框架
	很多框架（比如 Spring）都是配置化的（比如通过 XML文件配置 JavaBean，Action之类的），为了保证框架的通用性，他们可能根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。
举一个例子，在运用Struts 2框架的开发中我们一般会在struts.xml里去配置Action，比如

```
    <action name="login" class="org.ScZyhSoft.test.action.SimpleLoginAction"  method="execute">  
       <result>/shop/shop-index.jsp</result>  
       <result name="error">login.jsp</result>  
    </action>
```

配置文件与Action建立了一种映射关系，当View层发出请求时，请求会被StrutsPrepareAndExecuteFilter拦截，然后StrutsPrepareAndExecuteFilter会去动态地创建Action实例。
——比如我们请求login.action，那么StrutsPrepareAndExecuteFilter就会去解析struts.xml文件，检索action中name为login的Action，并根据class属性创建SimpleLoginAction实例，并用invoke方法来调用execute方法，这个过程离不开反射。
对与框架开发人员来说，反射虽小但作用非常大，它是各种容器实现的核心。而对于一般的开发者来说，不深入框架开发则用反射用的就会少一点，不过了解一下框架的底层机制有助于丰富自己的编程思想，也是很有益的。


### 10.说说自定义注解的场景及实现
场景：日志管理，缓存处理，权限验证等
实现：在需要验证的地方增加一个切面，通过反射获取方法所包含的注解，比如包含自定义的注解，就进行相应的功能处理


### 11.HTTP请求的GET与POST方式的区别
GET请求：请求参数会被拼接到URL后,可以拼接的长度受限制，而且如果有敏感信息 相对是不安全的
POST请求: 为了克服GET请求的限制，post传递参数会被放入请求体中，可以发送的参数数目不受限制，因为外部不可见，因此相对安全

### 12.Session与Cookie区别
session是基于服务端的会话管理，用于跟踪用户状态 这个数据可以保存在内存中，数据库中或者集群中
cookie是基于客户端的会话管理,数据保存在客户端中

### 13.列出自己常用的JDK包
java.util.* java.io.*

### 14.MVC设计思想
MODEL模型用来封装业务逻辑，
VIEW 视图用来实现表示逻辑，
Controller 控制器用来协调模型与视图(视图要通过控制器来调用模型，模型返回的处理结果也要先交给控制器，由控制器来选择合适的视图来显示 处理结果)。
这种设计思想 可以使各个层之间相互独立 又能相互协作，可以是业务逻辑与我们表现层视图进行解耦，有利于分工合作及快速开发

### 15.equals与==的区别
equals和==的第一个区别就是  他们一个是方法，一个是运算符，它们比较的都是物理地址 而不是值得比较
Java 语言里的 equals方法其实是交给开发者去覆写的，让开发者自己去定义满足什么条件的两个Object是equal的

由于String对象中重写了equals方法 当物理地址不同时，会进一步比较值，所以比较字符串时我们是用equals方法
如果我们要重写一个对象比如Student的equals方法，必须要同时重写equals() 和hashcode()方法,因为只重写equals方法是无法改变hashcode值的 而比较时首先比较的就是hashcode，所以我们通常是在编辑器中 右键->source->generate hashcode() and equals() 来实现。



### 16.什么是Java序列化和反序列化，如何实现Java序列化？或者请解释Serializable 接口的作用
* 序列化：把对象转换为字节序列的过程
* 反序列化: 把字节序列转化为对象的过程
对象序列化用途：
1.将对象字节序列永久保存在硬盘上 通常保存在一个文件中
2.在网络上传送对象的字节序列

* java.io.ObjectOutputStream代表对象输出流，它的writeObject(Object obj)方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。
* java.io.ObjectInputStream代表对象输入流，它的readObject()方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。 


```java 
    ObjectOutputStream oo = new ObjectOutputStream(new FileOutputStream(new File("E:/Person.txt"))); 
   	oo.writeObject(person); 
   	System.out.println("Person对象序列化成功！"); 
```

### 17.Object类中常见的方法，为什么wait  notify会放在Object里边？
简单说：因为synchronized中的这把锁可以是任意对象，所以任意对象都可以调用wait()和notify()；所以wait和notify属于Object。

专业说：因为这些方法在操作同步线程时，都必须要标识它们操作线程的锁，只有同一个锁上的被等待线程，可以被同一个锁上的notify唤醒，不可以对不同锁中的线程进行唤醒。
也就是说，等待和唤醒必须是同一个锁。而锁可以是任意对象，所以可以被任意对象调用的方法是定义在object类中。


### 18.Java的平台无关性如何体现出来的
* Java程序则编译为字节码。字节码本身不能运行，因为它不是原生代码。字节码只能够在Java虚拟机（JVM）上运行
* JVM是一个原生应用程序，它负责解释字节码。通过使用JVM可用在众多的平台上（这也就是Java可以做到平台无关性的原因），Sun公司将Java变成了跨平台的语言。如下图模型，完全相同的字节码可以在已经开发了JVM的任何操作系统上运行
![java跨平台原理](http://pam1kb0ai.bkt.clouddn.com/java%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E8%B7%A8%E5%B9%B3%E5%8F%B0.jpg)


### 19.JDK和JRE的区别
* JDK（Java Development Kit）JDK是整个JAVA的核心，包括了Java运行环境JRE（Java Runtime Envirnment）、一堆Java工具（javac/java/jdb等）和Java基础的类库
* Java Runtime Environment（JRE）他就是java运行环境 并不是一个开发环境，所以没有包含任何开发工具

### 20.Java 8有哪些新特性
* Lambda表达式和函数式接口,它允许我们将函数当成参数传递给某个方法
* 接口的默认方法（default修饰)

### 21.Java常见集合
ArrayList,LinkedList,HashMap,HashTable,Set,HashSet,TreeSet

### 22.List 和 Set 区别
* 1.List,Set都实现了Collection接口
* 2.List它是一个有序的集合输出顺序就是插入顺序，可以允许插入重复对象，可以插入null元素，常用的实现有ArrayList,LinkedList,Vector
* 3.Set 是一一个无序的容器(存入和取出顺序不一定一致)，不允许插入重复对象,常用实现HashSet,LinkedHashSet,TreeSet


### 23.HashSet如何保证数据唯一性？
HashSet底层数据接口是哈希表,怎样保证数据唯一性呢？它是通过HashCode和equals来完成的，
如果元素的Hashcode值相同,才会判断equals是否为true,如果hashcode值不同，不会调用equals方法

在java的集合中，判断两个对象是否相等的规则是:
判断两个对象的hashCode否相等
1. 如果相等 就认为两个对象不相等，完毕
2. 如果不相等，调用对象的equals()方法判断是否相等，如果不相等，认为两个对象也不相等

为什么要通过hashCode()和equlas()两条规则呢? 
 因为hashCode()相等时 equlas()也可能不相等，String,Double类都重写了hashCode()方法和equlas()方法，我们自己定义的对象也可以重写hashCode()和equlas()方法

### 24.List 和 Map 区别
List是有顺序的集合，Map是通过键值对存取的容器,Key和Value一一对应
Set,List都继承自Collection接口,List接口有三个实现类：ArrayList，Vector，LinkedList
HashMap,HashTable实现了  Map<E,V>接口

### 25.Arraylist 与 LinkedList 区别
ArrayList,LinkedList是List接口的两个实现类，他们都实现了List接口的方法,只是实现的方式不同

ArrayList它是以数组的方式来实现的,数组的特性是可以使用索引的方式来快速定位对象的位置,因此对于快速的随机取得对象的需求,使用ArrayList实现执行效率上会比较好
LinkedList是采用链表的方式来实现List接口的,它本身有自己特定的方法，如: addFirst(),addLast(),getFirst(),removeFirst()等. 由于是采用链表实现的,因此在进行insert和remove动作时在效率上要比ArrayList要好得多!适合用来实现Stack(堆栈)与Queue(队列),前者先进后出，后者是先进先出.

### 26.在删除可插入对象的动作时，为什么ArrayList的效率会比较低呢?
ArrayList是使用数组实现的,若要从数组中删除或插入某一个对象，需要移动后段的数组元素，从而会重新调整索引顺序,调整索引顺序会消耗一定的时间，所以速度上就会比LinkedList要慢许多. 相反,LinkedList是使用链表实现的,若要从链表中删除或插入某一个对象,只需要改变前后对象的引用即可

### 27.ArrayList 与 Vector 区别
List接口有三个实现类：ArrayList，Vector，LinkedList
1） Vector的方法都是同步的(Synchronized),是线程安全的(thread-safe)，而ArrayList的方法不是，由于线程的同步必然要影响性能，因此,ArrayList的性能比Vector好。
2） 当Vector或ArrayList中的元素超过它的初始大小时,Vector会将它的容量翻倍,而ArrayList只增加50%的大小，这样,ArrayList就有利于节约内存空间。

### 28.HashMap 和 Hashtable 的区别
1)HashMap线程不安全，HashTable线程安全，HashMap性能要好一点儿
2)HashMap中key和value可以为null, HashTable中key和value都不能为null

### 29.HashSet 和 HashMap 区别
1) HashSet实现了Set接口，它不允许集合中出现重复元素。当我们提到HashSet时，第一件事就是在将对象存储在 HashSet之前，要确保重写hashCode（）方法和equals（）方法，这样才能比较对象的值是否相等，确保集合中没有 储存相同的对象
2) HashMap实现了Map接口 Map接口对键值对进行映射。HashMap中根据key来计算hashcode, HashSet中使用成员对象来计算HashCode,对于两个对象来说hashCode值可能相同，因此如果两个对象hashcode相同的情况下会继续调用equals()方法
判断对象的相等性，相等返回true,否则返回false.


### 30. HashMap 和 ConcurrentHashMap 的区别
1) ConcurrentHashMap是线程安全的 具体是怎么实现线程安全的呢，肯定不可能是每个方法加synchronized，那样就变成了HashTable。它引入了一个“分段锁”的概念，具体可以理解为把一个大的Map拆分成N个小的HashTable，根据key.hashCode()来决定把key放到哪个HashTable中

2）在ConcurrentHashMap中，就是把Map分成了N个Segment，put和get的时候，都是现根据key.hashCode()算出放到哪个Segment中


### 31.Java中native方法使用场景？
1）在方法中调用一些不是由java语言写的代码。

2）在方法中用java语言直接操纵计算机硬件。

---


### 33.JVM运行时内存区域划分
![jvm内存划分](http://pam1kb0ai.bkt.clouddn.com/jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png)

1.程序计数器（线程私有）
程序计数器 通常占用很小的一块儿内存, 它用于存放当前线程执行的字节码的行号指示器
为什么需要程序计数器呢？因为java虚拟机中多线程是通过线程不断切换获得CPU执行时间进行的，为了处理器切换线程时能够回到之前所执行的位置, 每个线程都要有一个程序计数器,记录当前线程执行的字节码位置,所以是线程私有的.

2.java虚拟机栈(线程私有)
虚拟机栈描述的是Java 方法执行的内存模型：每个方法被执 行的时候都会同时创建一个栈帧（Stack Frame ①）用于存储局部变量表、操作栈、动态链接、方法出口等信息。
每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

* 注意：1.局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用
* 两种异常
1.StackOverflowError 如果线程申请的栈深度大于虚拟机允许的栈深度时，抛出这个错误
2.OutOfMemoryError 当虚拟机栈扩展时 无法申请到足够的内存 就会抛出这个错误.

3.本地方法栈 (Native Method Stacks) 线程私有
本地方法栈与虚拟机栈所发挥的作用是非常相似的,区别就是 虚拟机栈为执行的java方法服务，而本地方法栈为虚拟机使用到的Native方法(本地方法)服务

4.java堆（线程共享）
Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的 唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存
主要用来存放对象实例和数组，它是垃圾收集器管理的主要区域


5.方法区（非堆内存）Non-heap（线程共享）
用于存储被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据
根据Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError 异常

运行时常量池
运行时常量池是方法区的一部分，主要存储编译期生成的各种字面量和符号引用

### JVM如何设置参数
Linux下 在catalina.sh中设置如下参数
JAVA_OPTS="-Xms128m -Xmx512m -XX:PermSize=128m -XX:MaxPermSize=256m"  

* Xms  			  jvm初始分配的堆内存大小
* Xmx  			  jvm最大允许分配的堆内存，按需分配
* XX:PermSize    jvm初始分配的非堆内存大小
* XX:MaxPermSize jvm最大允许分配的非堆内存




### 34.常见的设计模式

### 35.设计模式的的六大原则及其含义
（参考: https://www.cnblogs.com/dolphin0520/p/3919839.html）

1. 单一职责原则  
	单一职责原则告诉我们：一个类不能太“累”！在软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中  
 
2. 开闭原则  
	一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展
	
3. 里氏替换原则  
	里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象
	
4. 依赖倒置原则  
	抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程

5. 接口隔离原则  
	使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口
	
6. 迪米特原则  
	一个软件实体应当尽可能少地与其他实体发生相互作用
	 如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。

### 36.常见的单例模式以及各种实现方式的优缺点，哪一种最好，手写常见的单利模式

```
	public class Singleton {
    	private static final Singleton singleton = new Singleton();
    	private Singleton(){}
    	public static synchronized Singleton getInstance(){
       	 return singleton;
    	}
	}
```

### 37.什么是长连接和短连接
1. HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。 IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠地传递数据包，使得网络上接收端收到发送端所发出的所有包，并且顺序与发送顺序一致。TCP协议是可靠的、面向连接的

2. 在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。

3. 而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：
```Connection:keep-alive```  
在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。


### 38.三次握手和四次挥手、为什么挥手需要四次
参考博文: https://blog.csdn.net/qzcsu/article/details/72861891

![Tcp三次握手示意图](http://pam1kb0ai.bkt.clouddn.com/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png)

第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。

第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；

第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

完成三次握手，客户端与服务器开始传送数据，在上述过程中，还有一些重要的概念：

未连接队列

在三次握手协议中，服务器维护一个未连接队列，该队列为每个客户端的SYN包（syn=j）开设一个条目，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在服务器处于SYN_RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。


> 问题1：为什么TCP客户端最后还要发送一次确认呢？ 

> 一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。
> 如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接


---
### TCP四次挥手
![四次挥手](http://pam1kb0ai.bkt.clouddn.com/tcp%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png)
>数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭。

对于一个已经建立的连接，TCP使用改进的三次握手来释放连接（使用一个带有FIN附加标记的报文段）。TCP关闭连接的步骤如下：

第一步，当主机A的应用程序通知TCP数据已经发送完毕时，TCP向主机B发送一个带有FIN附加标记的报文段（FIN表示英文finish）。

第二步，主机B收到这个FIN报文段之后，并不立即用FIN报文段回复主机A，而是先向主机A发送一个确认序号ACK，同时通知自己相应的应用程序：对方要求关闭连接（先发送ACK的目的是为了防止在这段时间内，对方重传FIN报文段）。

第三步，主机B的应用程序告诉TCP：我要彻底的关闭连接，TCP向主机A送一个FIN报文段。

第四步，主机A收到这个FIN报文段后，向主机B发送一个ACK表示连接彻底释放。


### 为什么连接的时候是三次握手，关闭的时候却是四次握手？

答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。



二、数据存储和消息队列

2.1、数据库
MySQL 索引使用的注意事项

DDL、DML、DCL分别指什么

explain命令

left join，right join，inner join

数据库事物ACID（原子性、一致性、隔离性、持久性）

事物的隔离级别（读未提交、读以提交、可重复读、可序列化读）

脏读、幻读、不可重复读

数据库的几大范式

数据库常见的命令

说说分库与分表设计

分库与分表带来的分布式困境与应对之策（如何解决分布式下的分库分表，全局表？）

说说 SQL 优化之道

MySQL遇到的死锁问题、如何排查与解决

存储引擎的 InnoDB与MyISAM区别，优缺点，使用场景

索引类别（B+树索引、全文索引、哈希索引）、索引的原理

什么是自适应哈希索引（AHI）

为什么要用 B+tree作为MySQL索引的数据结构

聚集索引与非聚集索引的区别

遇到过索引失效的情况没，什么时候可能会出现，如何解决

limit 20000 加载很慢怎么解决

如何选择合适的分布式主键方案

选择合适的数据存储方案

常见的几种分布式ID的设计方案

常见的数据库优化方案，在你的项目中数据库如何进行优化的

2.2、Redis
Redis 有哪些数据类型，可参考《Redis常见的5种不同的数据类型详解》

Redis 内部结构

Redis 使用场景

Redis 持久化机制，可参考《使用快照和AOF将Redis数据持久化到硬盘中》

Redis 集群方案与实现

Redis 为什么是单线程的？

缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级

使用缓存的合理性问题

Redis常见的回收策略

2.3、消息队列
消息队列的使用场景

消息的重发补偿解决思路

消息的幂等性解决思路

消息的堆积解决思路

自己如何实现消息队列

如何保证消息的有序性

三、开源框架和容器
3.1、SSM/Servlet
Servlet的生命周期

转发与重定向的区别

BeanFactory 和 ApplicationContext 有什么区别

Spring Bean 的生命周期

Spring IOC 如何实现

Spring中Bean的作用域，默认的是哪一个

说说 Spring AOP、Spring AOP 实现原理

动态代理（CGLib 与 JDK）、优缺点、性能对比、如何选择

Spring 事务实现方式、事务的传播机制、默认的事务类别

Spring 事务底层原理

Spring事务失效（事务嵌套），JDK动态代理给Spring事务埋下的坑，可参考《JDK动态代理给Spring事务埋下的坑！》

如何自定义注解实现功能

Spring MVC 运行流程

Spring MVC 启动流程

Spring 的单例实现原理

Spring 框架中用到了哪些设计模式

Spring 其他产品（Srping Boot、Spring Cloud、Spring Secuirity、Spring Data、Spring AMQP 等）

有没有用到Spring Boot，Spring Boot的认识、原理

MyBatis的原理

可参考《为什么会有Spring》

可参考《为什么会有Spring AOP》

3.2、Netty
为什么选择 Netty

说说业务中，Netty 的使用场景

原生的 NIO 在 JDK 1.7 版本存在 epoll bug

什么是TCP 粘包/拆包

TCP粘包/拆包的解决办法

Netty 线程模型

说说 Netty 的零拷贝

Netty 内部执行流程

Netty 重连实现

3.3、Tomcat

Tomcat的基础架构（Server、Service、Connector、Container）

Tomcat如何加载Servlet的

Pipeline-Valve机制

可参考：《四张图带你了解Tomcat系统架构！》

四、分布式
4.1、Nginx
请解释什么是C10K问题或者知道什么是C10K问题吗？

Nginx简介，可参考《Nginx简介》

正向代理和反向代理.

Nginx几种常见的负载均衡策略

Nginx服务器上的Master和Worker进程分别是什么

使用“反向代理服务器”的优点是什么?

4.2、分布式其他
谈谈业务中使用分布式的场景

Session 分布式方案

Session 分布式处理

分布式锁的应用场景、分布式锁的产生原因、基本概念

分布是锁的常见解决方案

分布式事务的常见解决方案

集群与负载均衡的算法与实现

说说分库与分表设计，可参考《数据库分库分表策略的具体实现方案》

分库与分表带来的分布式困境与应对之策

4.3、Dubbo

什么是Dubbo，可参考《Dubbo入门》

什么是RPC、如何实现RPC、RPC 的实现原理，可参考《基于HTTP的RPC实现》

Dubbo中的SPI是什么概念

Dubbo的基本原理、执行流程

五、微服务

5.1、微服务

前后端分离是如何做的？

微服务哪些框架

Spring Could的常见组件有哪些？可参考《Spring Cloud概述》

领域驱动有了解吗？什么是领域驱动模型？充血模型、贫血模型


### JWT有了解吗，什么是JWT，可参考《前后端分离利器之JWT》 
https://blog.csdn.net/bntx2jsqfehy7/article/details/79224042

你怎么理解 RESTful

说说如何设计一个良好的 API

如何理解 RESTful API 的幂等性

如何保证接口的幂等性

说说 CAP 定理、BASE 理论

怎么考虑数据一致性问题

说说最终一致性的实现方案

微服务的优缺点，可参考《微服务批判》

微服务与 SOA 的区别

如何拆分服务、水平分割、垂直分割

如何应对微服务的链式调用异常

如何快速追踪与定位问题

如何保证微服务的安全、认证

5.2、安全问题
如何防范常见的Web攻击、如何方式SQL注入

服务端通信安全攻防

HTTPS原理剖析、降级攻击、HTTP与HTTPS的对比

5.3、性能优化
性能指标有哪些

如何发现性能瓶颈

性能调优的常见手段

说说你在项目中如何进行性能调优

六、其他
6.1、设计能力
说说你在项目中使用过的UML图

你如何考虑组件化、服务化、系统拆分

秒杀场景如何设计

可参考：《秒杀系统的技术挑战、应对策略以及架构设计总结一二！》

6.2、业务工程
说说你的开发流程、如何进行自动化部署的

你和团队是如何沟通的

你如何进行代码评审

说说你对技术与业务的理解

说说你在项目中遇到感觉最难Bug，是如何解决的

介绍一下工作中的一个你认为最有价值的项目，以及在这个过程中的角色、解决的问题、你觉得你们项目还有哪些不足的地方

6.3、软实力
说说你的优缺点、亮点

说说你最近在看什么书、什么博客、在研究什么新技术、再看那些开源项目的源代码

说说你觉得最有意义的技术书籍

工作之余做什么事情、平时是如何学习的，怎样提升自己的能力

说说个人发展方向方面的思考

说说你认为的服务端开发工程师应该具备哪些能力

说说你认为的架构师是什么样的，架构师主要做什么

如何看待加班的问题