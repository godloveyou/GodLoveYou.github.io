{"compress":true,"commitItems":[["2f421823-31af-41f0-9681-c91d1889a71b",1571650425564,"",[[1571650382461,["david@DESKTOP-9844NL4",[[1,0,"# springboot整合ActiveMq\n\n\n\n"]],[0,0],[25,25]]],[1571650386036,["david@DESKTOP-9844NL4",[[1,25,"一、 ActiveMQ 消息队列的使用\nMQ\nMQ:Message Queue 消息队列，就是用来在系统之间进行消息传递的\n\n这个队列有一系列具体的实现技术：ActiveMQ、rabbitMQ、kafka、RocketMQ(alibaba)\n\nHttpCilent和MQ的比较\n\n1 HttpClient只能算是两个系统间调用的技术\n\nHttpClient支持跨操作系统跨语言调用\n\n2 MQ可以在两个系统间进行信息交互，并且支持高并发\n\nActiveMQ支持跨操作系统的java语言中通信\nrabbitMQ支持跨操作系统跨编程语言间的通信   \n1\n2\n1、ActiveMQ简介\n什么是ActiveMQ\n\n\nActiveMQ工作原理：在本系统中的调用\n\n\n\n1、 解决服务之间代码耦合\n\n2、 使用消息队列，增加系统并发处理量\n\n\n\nActiveMQ应用场景分析：\n\n1、 当系统使用短信平台、邮件平台的时候。\n\n用户注册，重点使用用户信息数据库保存，而发短信、发邮件，增加业务处理复杂度，这时候使用MQ， 将发短信、发邮箱，通知MQ，由另外服务平台完成。解决了代码的耦合问题。\n\n2、 当系统使用搜索平台、缓存平台的时候。\n\n查询数据，建立缓存、索引 ，当再次查询相同数据的时候，不从数据库查询，从缓存或者索引库查询\n\n当增加、修改、删除数据时，发送消息给MQ， 缓存平台、索引平台 从MQ获取到这个信息，更新缓存或者索引\n\n总结：使用MQ作为系统间数据调用的中转站。\n\n\n\n2、ActiveMQ安装和使用\n官网：http://activemq.apache.org/\n\n下载\n\n\n\n\n\n下载windows版本\n\n\n\n进行apache-activemq-5.14.0\\bin\\win64目录 启动activemq.bat 文件\n\n访问：http://localhost:8161/ 点击：Manage ActiveMQ broker\n\n用户名和密码 都是admin \n1\n\n\nActiveMQ使用的是标准生产者和消费者模型\n\n有两种数据结构 Queue、Topic (详见4.2)\n1\n1、Queue 队列（P2P消息模型） ，生产者生产了一个消息，只能由一个消费者进行消费 ：给微信好友发消息\n\n2、Topic 主题/广播（Pub/Sub消息模型），生产者生产了一个消息，可以由多个消费者进行消费\n\n  微信公众号给粉丝发消息\n1\nJMS和ActiveMQ的对应\n\nJMS消息模型\tP2P模式\tpub/sub模式\nActiveMQ消息\tQueue队列\tTopic队列\n特点\t一对一，一个人发送，只允许一个人接收\t一对多，一个人发送，允许多个人接收\n发送的人：生产者\n接收的人：消费者 \n1\n2\n2、使用Java程序操作ActiveMQ\n2.1、Queue-HelloWorld\n2.1.1、pom\n<dependencies>\n    <dependency>\n        <groupId>org.apache.activemq</groupId>\n        <artifactId>activemq-all</artifactId>\n        <version>5.14.0</version>\n    </dependency>\n</dependencies>\n1\n2\n3\n4\n5\n6\n7\n2.1.2、编写生产者\n使用JMS原生API编写测试类，向消息中间件写入消息的开发步骤：\n\n1 创建链接工厂\n2 从链接工厂中获取链接\n3 启动链接\n4 获取会话\n5 创建Queue队列\n6 创建生产者\n7 创建消息\n8 发送消息\n9 提交请求\n10 关闭各种资源\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n第一步：在test/java包中，创建包activeMQ_helloworld，创建类ActiveMQProducter\n\npublic class ActiveMQProducter {\n\n    public static void main(String[] args) throws Exception{\n        // 连接工厂\n        // 使用默认用户名、密码、路径\n        // 因为：底层实现：final String defaultURL = \"tcp://\" + DEFAULT_BROKER_HOST + \":\" + DEFAULT_BROKER_PORT;\n        // 所以：路径 tcp://host:61616\n        //1 创建连接工厂\n        ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory();\n        //2 创建连接\n        Connection connection = connectionFactory.createConnection();\n        //3 打开连接\n        connection.start();\n        //4 创建会话\n        //第一个参数：是否开启事务\n        //第二个参数：消息是否自动确认\n        Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);\n        //创建队列\n        Queue queue = session.createQueue(\"hello1115\");\n        //5 创建生产者\n        MessageProducer producer = session.createProducer(queue);\n        //6 创建消息\n        Message message = session.createTextMessage(\"hi i am boy\");\n        //7 发送消息\n        producer.send(message);\n\n        //8 关闭消息\n        session.commit();\n        producer.close();\n        session.close();\n        connection.close();\n        System.out.println(\"消息生产成功\");\n    }\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n第二步：运行代码，在控制台提示：\n\n\n\n第三步：查看页面效果，默认tcp连接activeMQ端口 61616 ！！！\n\n\n\n2.1.3、编写消费者\n使用JMS原生API编写测试类，向消息中间件消费消息的开发步骤：\n\n1 创建链接工厂\n2 创建链接\n3 启动链接\n4 获取会话\n5 创建队列\n6 创建消费者\n7 消费消息\n8 提交\n9 关闭资源\n1\n2\n3\n4\n5\n6\n7\n8\n9\n第一步：使用MessageConsumer完成消费ActiveMQConsumer.java\n\npublic class ActiveMQConsumer {\n    public static void main(String[] args) throws Exception {\n        //创建连接工厂\n        ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory();\n        //创建连接\n        Connection connection = connectionFactory.createConnection();\n        //开启连接\n        connection.start();\n        //创建会话\n        /** 第一个参数，是否使用事务\n         如果设置true，操作消息队列后，必须使用 session.commit();\n         如果设置false，操作消息队列后，不使用session.commit();\n         */\n        Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);\n        //创建队列\n        Queue queue = session.createQueue(\"hello1115\");\n        //创建消费者\n        MessageConsumer consumer = session.createConsumer(queue);\n        while(true){\n            //失效时间，如果10秒内没有收到新的消息，说明没有消息存在，此时可以退出当前循环\n            TextMessage message = (TextMessage) consumer.receive(10000);\n            if(message!=null){\n                System.out.println(message.getText());\n            }else {\n                break;\n            }\n        }\n\n        //关闭连接\n        session.commit();\n        session.close();\n        connection.close();\n\n        System.out.println(\"消费结束0\");\n    }\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n第二步：查看控制台，发现信息已经被消费\n\n\n\n第三步：查看页面效果\n\n访问：http://localhost:8161/ 点击：Manage ActiveMQ broker\n\n用户名和密码 都是admin \n1\n消费前：表示没有消费\n\n\n\n消费后：表示已经消费\n\n\n\n2.1.4、监听器消费消息\n// 使用监听器消费\npublic static void main(String[] args) throws Exception {\n    // 连接工厂\n    // 使用默认用户名、密码、路径\n    // 路径 tcp://host:61616\n    ConnectionFactory connectionFactory = new ActiveMQConnectionFactory();\n    // 获取一个连接\n    Connection connection = connectionFactory.createConnection();\n    // 开启连接\n    connection.start();\n    // 建立会话\n    // 第一个参数，是否使用事务，如果设置true，操作消息队列后，必须使用 session.commit();\n    Session session = connection.createSession(false,Session.AUTO_ACKNOWLEDGE);\n    // 创建队列或者话题对象\n    Queue queue = session.createQueue(\"Hello1115\");\n    // 创建消费者\n    MessageConsumer messageConsumer = session.createConsumer(queue);\n\n    messageConsumer.setMessageListener(new MessageListener() {\n        // 每次接收消息，自动调用 onMessage\n        public void onMessage(Message message) {\n            TextMessage textMessage = (TextMessage) message;\n            try {\n                System.out.println(textMessage.getText());\n            } catch (JMSException e) {\n                e.printStackTrace();\n            }\n        }\n    });\n    //此时，不能让程序结束，如果结束，监听就结束了\n    while (true) {\n        // 目的：不能让程序死掉\n    }\n} \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n重复测试生成和消费的过程。实现一边生产，一边消费的系统。\n\n2.2、多消费者模式-queue\n\n\nP2P消息模型中的多消费者模式，得出结论如下：\n\n一个消息只能被一个消费者消费，不可重复消费\n多个消费者均分消息(负载均衡策略)\n当消费者在消费某个消息的时候，mq一定要等到它的成功回执，才会分发下一个消息\n\n\n注意：测试的时候一定先启动消费者，然后再启动生产者\n\n###3.3、Topic-HelloWorld\n\nTopic：主题模式、广播模式、pus/sub模式、\n\n//4 获取会话\n// 第一个参数：是否开启事务  true 开启事务，后面一定要提交commit\n// 第二个参数：是否自动确认消息已经被消费\nSession session = connection.createSession(true,Session.AUTO_ACKNOWLEDGE);\n//5 创建Topic主题模式\n//Queue queue = session.createQueue(\"java1.0913\");\nTopic topic = session.createTopic(\"java1.0319\");\n//6 创建生产者\nMessageProducer producer = session.createProducer(topic);\n1\n2\n3\n4\n5\n6\n7\n8\n9\n2.4、多消费者模式-topic\n\n\n2.5 queue和topic模式的比较\n相同点：\n\n1、都只有一个生产者\n\n2、都可以有多个消费者\n\n不同点：\n\n1、queue队列模式，一个消息只能被一个消费者消费，不能重复消费\n\n当消费者消费某个消息的时候，一定要得到这个消息被成功消费的回执，才会分发下一个消息\nqueue入队之后，无论等待多久，消息都会一直等待消费者来处理\n\n2、topic广播模式，一个消息可以被多个消费者消费\n\n这个消息无法被成功消费与否，都无所谓\n\ntopic要求时间要一致，我正好发，你正好收\n\n3、SpringBoot整合ActiveMQ\n在Spring Boot中集成ActiveMQ相对还是比较简单的，都不需要安装什么服务，默认使用内存的activeMQ，当然配合外置ActiveMQ Server会更好。\n\n我们采用外置ActiveMQ。\n1\n3.1、创建工程maven子模块\n1、在common_parent中导入activeMQ的启动器\n\n<!-- ActiveMQ的启动器 -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-activemq</artifactId>\n</dependency>\n1\n2\n3\n4\n5\n2、创建bos-mq子模块\n\n\n\n\n\n\n\n3、添加项目依赖\n\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n    </dependency>\n    <!-- ActiveMQ的启动器 -->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-activemq</artifactId>\n    </dependency>\n</dependencies>\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n4、创建程序入口\n\n\n\n代码如下：\n\n@SpringBootApplication\npublic class BosMqApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(BosMqApplication.class, args);\n    }\n}\n1\n2\n3\n4\n5\n6\n7\n5、创建application.properties，具体配置如下：\n\n\n\n# MQ所在的服务器的地址\nspring.activemq.broker-url=tcp://127.0.0.1:61616\n# 是否使用内置的MQ， true  使用； fale  不使用\nspring.activemq.in-memory=false \n# 是否在回滚回滚消息之前停止消息传递。这意味着当启用此命令时，消息顺序不会被保留。\nspring.activemq.non-blocking-redelivery=false\n# 用户名\nspring.activemq.password=admin\n# 密码\nspring.activemq.user=admin\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n配置的具体意思\n\nspring.activemq.broker-url=tcp://127.0.0.1:61616\n# 在考虑结束之前等待的时间\n#spring.activemq.close-timeout=15s \n# 默认代理URL是否应该在内存中。如果指定了显式代理，则忽略此值。\nspring.activemq.in-memory=true \n# 是否在回滚回滚消息之前停止消息传递。这意味着当启用此命令时，消息顺序不会被保留。\nspring.activemq.non-blocking-redelivery=false\n# 密码\nspring.activemq.password=admin\n# 等待消息发送响应的时间。设置为0等待永远。\nspring.activemq.user=admin\n# 是否信任所有包\n#spring.activemq.packages.trust-all=\n# 要信任的特定包的逗号分隔列表（当不信任所有包时）\n#spring.activemq.packages.trusted=\n# 当连接请求和池满时是否阻塞。设置false会抛“JMSException异常”。\n#spring.activemq.pool.block-if-full=true\n# 如果池仍然满，则在抛出异常前阻塞时间。\n#spring.activemq.pool.block-if-full-timeout=-1ms\n# 是否在启动时创建连接。可以在启动时用于加热池。\n#spring.activemq.pool.create-connection-on-startup=true\n# 是否用Pooledconnectionfactory代替普通的ConnectionFactory。\n#spring.activemq.pool.enabled=false \n# 连接过期超时。\n#spring.activemq.pool.expiry-timeout=0ms\n# 连接空闲超时\n#spring.activemq.pool.idle-timeout=30s\n# 连接池最大连接数\n#spring.activemq.pool.max-connections=1\n# 每个连接的有效会话的最大数目。\n#spring.activemq.pool.maximum-active-session-per-connection=500\n# 当有\"JMSException\"时尝试重新连接\n#spring.activemq.pool.reconnect-on-exception=true\n# 在空闲连接清除线程之间运行的时间。当为负数时，没有空闲连接驱逐线程运行。\n#spring.activemq.pool.time-between-expiration-check=-1ms\n# 是否只使用一个MessageProducer\n#spring.activemq.pool.use-anonymous-producers=true\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n6、创建config\n\n\n\n代码如下：\n\npackage com.czxy.config;\nimport javax.jms.Queue;\nimport javax.jms.Topic;\nimport org.apache.activemq.command.ActiveMQQueue;\nimport org.apache.activemq.command.ActiveMQTopic;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n@Configuration\npublic class ActiveMQConfig {\n\t@Bean\n\tpublic Queue queue() {\n\t\t return new ActiveMQQueue(\"Armyman.queue\");\n\t}\n\t@Bean\n\tpublic Topic topic() {\n\t\treturn new ActiveMQTopic(\"Armyman.topic\");\n\t}\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n3.2、编写消费者和生产者\n1、编写生产者QueueProducer\n\n\n\n/**\n  * 消息的生产者 \n  * @author Administrator\n  *\n  */\n@Componet\n@EnableScheduling\npublic class QueueProducer {  \n\t/*\n\t * @Autowired // 也可以注入JmsTemplate，JmsMessagingTemplate对JmsTemplate进行了封装\n\t * private JmsMessagingTemplate jmsTemplate; //\n\t * 发送消息，destination是发送到的队列，message是待发送的消息\n\t * \n\t * @Scheduled(fixedDelay=3000)//每3s执行1次 \n\t   public void sendMessage(Destination destination, final String message){\n\t      jmsTemplate.convertAndSend(destination, message); \n\t   }\n\t */\n\n    @Autowired\n    private JmsMessagingTemplate jmsMessagingTemplate;\n\n    @Autowired\n    private Queue queue;\n\n    @Scheduled(fixedDelay=3000)//每3s执行1次\n    public void send() {\n       try {\n\t\t\n\t\t   MapMessage mapMessage = new ActiveMQMapMessage();\n\t\t   mapMessage.setString(\"info\", \"你还在睡觉\");\n\t\t   \n\t\t   this.jmsMessagingTemplate.convertAndSend(this.queue, mapMessage);\n\t\t   \n\t\t} catch (Exception e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n    }\n}  \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n2、编写消费者QueueConsumer\n\n\n\n/**\n * 消息的消费者\n * @author Administrator\n */\n@Component  \npublic class QueueConsumer {  \n    //使用JmsListener配置消费者监听的队列，其中Message是接收到的消息  \n\t@JmsListener(destination = \"Armyman.queue\")  \n    public void receiveQueue(Message message) {\n\t\ttry {\n\t\t\tMapMessage mapMessage = (MapMessage) message;\n\t\t\tString info = mapMessage.getString(\"info\");\n\t\t\tSystem.out.println(info);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n    } \n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n3、启动，测试，OK\n\n3.3 使用内置ActiveMQ\n只需要改变properties配置文件，即可运行\n\n# MQ所在的服务器的地址\n# spring.activemq.broker-url=tcp://127.0.0.1:61616\n# 是否使用SpringBoot内置的MQ， true  使用； fale  不使用\nspring.activemq.in-memory=true \n# 是否在回滚回滚消息之前停止消息传递。这意味着当启用此命令时，消息顺序不会被保留。\nspring.activemq.non-blocking-redelivery=false\n# 用户名\n# 密码\n#spring.activemq.user=admin\n# spring.activemq.password=admin\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n7 应用场景：\n\n用在高并发的请求中\n注册短信的发送\n注册邮件的发送\n秒杀\n两个系统间进行消息传递\n4.1、消息队列应用场景\n以下介绍消息队列在实际应用中常用的使用场景。\n\n异步处理，应用解耦，流量削锋和消息通讯四个场景\n\n4.1.1异步处理\n场景说明：用户注册后，需要发注册邮件和注册短信。传统的做法有两种:\n\n1.串行方式；2.并行方式\n\n（1）串行方式：将注册信息写入数据库成功后，发送注册邮件，再发送注册短信。以上三个任务全部完成后，返回给客户端\n\n\n\n（2）并行方式：将注册信息写入数据库成功后，发送注册邮件的同时，发送注册短信。以上三个任务完成后，返回给客户端。与串行的差别是，并行的方式可以提高处理的时间\n\n\n\n假设三个业务节点每个使用50毫秒钟，不考虑网络等其他开销，则串行方式的时间是150毫秒，并行的时间可能是100毫秒。\n\n因为CPU在单位时间内处理的请求数是一定的，假设CPU在1秒内吞吐量是100次。则串行方式1秒内CPU可处理的请求量是7次（1000/150）。并行方式处理的请求量是10次（1000/100）\n\n小结：如以上案例描述，传统的方式系统的性能（并发量，吞吐量，响应时间）会有瓶颈。如何解决这个问题呢？\n\n引入消息队列，将不是必须的业务逻辑，异步处理。改造后的架构如下：\n\n\n\n按照以上约定，用户的响应时间相当于是注册信息写入数据库的时间，也就是50毫秒。注册邮件，发送短信写入消息队列后，直接返回，因此写入消息队列的速度很快，基本可以忽略，因此用户的响应时间可能是50毫秒。因此架构改变后，系统的吞吐量提高到每秒20 QPS。比串行提高了3倍，比并行提高了2倍\n\n4.1.2应用解耦\n场景说明：用户下单后，订单系统需要通知库存系统。传统的做法是，订单系统调用库存系统的接口。如下图\n\n\n\n传统模式的缺点：\n\nl 假如库存系统无法访问，则订单减库存将失败，从而导致订单失败\n\nl 订单系统与库存系统耦合\n\n如何解决以上问题呢？引入应用消息队列后的方案，如下图：\n\n\n\n订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功\n\n库存系统：订阅下单的消息，采用pub/sub(发布/订阅)的方式，获取下单信息，库存系统根据下单信息，进行库存操作\n\n假如：在下单时库存系统不能正常使用。也不影响正常下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作了。实现订单系统与库存系统的应用解耦\n\n4.1.3流量削锋\n流量削锋也是消息队列中的常用场景，一般在秒杀或团抢活动中使用广泛\n\n应用场景：秒杀活动，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要在应用前端加入消息队列。\n\n可以控制活动的人数\n\n可以缓解短时间内高流量压垮应用\n\n\n\n用户的请求，服务器接收后，首先写入消息队列。假如消息队列长度超过最大数量，则直接抛弃用户请求或跳转到错误页面\n\n秒杀业务根据消息队列中的请求信息，再做后续处理\n\n4.1.4日志处理\n日志处理是指将消息队列用在日志处理中，比如Kafka的应用，解决大量日志传输的问题。架构简化如下\n\n\n\n日志采集客户端，负责日志数据采集，定时写受写入Kafka队列\n\nKafka消息队列，负责日志数据的接收，存储和转发\n\n日志处理应用：订阅并消费kafka队列中的日志数据[外链图片转存失败(img-gzmTdxhA-1567492404919)(assets/wps3257.tmp.jpg)]\n\n(1)Kafka：接收用户日志的消息队列\n\n(2)Logstash：做日志解析，统一成JSON输出给Elasticsearch\n\n(3)Elasticsearch：实时日志分析服务的核心技术，一个schemaless，实时的数据存储服务，通过index组织数据，兼具强大的搜索和统计功能\n\n(4)Kibana：基于Elasticsearch的数据可视化组件，超强的数据可视化能力是众多公司选择ELK stack的重要原因\n\n4.1.5消息通讯\n消息通讯是指，消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等\n\n点对点通讯：\n\n\n\n客户端A和客户端B使用同一队列，进行消息通讯。\n\n聊天室通讯：\n\n\n\n客户端A，客户端B，客户端N订阅同一主题，进行消息发布和接收。实现类似聊天室效果。\n\n以上实际是消息队列的两种消息模式，点对点或发布订阅模式。模型为示意图，供参考。\n\n4.2、JMS消息服务\n消息队列的JAVAEE规范JMS 。JMS（Java Message Service,java消息服务）API是一个消息服务的标准/规范，允许应用程序组件基于JavaEE平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。\n\n4.2.1 消息模型\n在JMS标准中，有两种消息模型P2P（Point to Point）,Publish/Subscribe(Pub/Sub)。\n\n4.2.2 P2P模式-队列模式\n\n\nP2P模式包含三个角色：消息队列（Queue），发送者(Sender)，接收者(Receiver)。每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到他们被消费或超时。\n\nP2P的特点\n\n每个消息只能被一个消费者（Consumer）消费(即一旦被消费，消息就不再存在于消息队列中)\n\n发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行，它不会影响到消息被发送到队列\n\n接收者在成功接收消息之后需向队列应答成功\n\n如果希望发送的每个消息都会被成功处理的话，那么需要P2P模式。\n\n4.2.3 Pub/Sub模式–广播/主题模式\n\n\n包含三个角色主题（Topic），发布者（Publisher），订阅者（Subscriber） 多个发布者将消息发送到Topic,系统将这些消息传递给多个订阅者。\n\nPub/Sub的特点\n\n每个消息可以有多个消费者\n\n发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息\n\n为了消费消息，订阅者必须保持运行的状态\n\n为了缓和这样严格的时间相关性，JMS允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息。\n\n如果希望发送的消息可以被多个消费者处理的话，那么可以采用Pub/Sub模型。\n\n4.3.消息消费方式\n在JMS中，消息的产生和消费都是异步的。对于消费来说，JMS的消息者可以通过两种方式来消费消息。\n\n（1）同步\n\n订阅者或接收者通过receive方法来接收消息，receive方法在接收到消息之前（或超时之前）将一直阻塞；\n\n（2）异步\n\n订阅者或接收者可以注册为一个消息监听器。当消息到达之后，系统自动调用监听器的onMessage方法。\n————————————————\n版权声明：本文为CSDN博主「Armymans」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/qq_43652509/article/details/83926758"]],[25,25],[14761,14761]]],[1571650389887,["david@DESKTOP-9844NL4",[[-1,25,"一、 ActiveMQ 消息队列的使用\nMQ\nMQ:Message Queue 消息队列，就是用来在系统之间进行消息传递的\n\n这个队列有一系列具体的实现技术：ActiveMQ、rabbitMQ、kafka、RocketMQ(alibaba)\n\nHttpCilent和MQ的比较\n\n1 HttpClient只能算是两个系统间调用的技术\n\nHttpClient支持跨操作系统跨语言调用\n\n2 MQ可以在两个系统间进行信息交互，并且支持高并发\n\nActiveMQ支持跨操作系统的java语言中通信\nrabbitMQ支持跨操作系统跨编程语言间的通信   \n1\n2\n1、ActiveMQ简介\n什么是ActiveMQ\n\n\nActiveMQ工作原理：在本系统中的调用\n\n\n\n1、 解决服务之间代码耦合\n\n2、 使用消息队列，增加系统并发处理量\n\n\n\nActiveMQ应用场景分析：\n\n1、 当系统使用短信平台、邮件平台的时候。\n\n用户注册，重点使用用户信息数据库保存，而发短信、发邮件，增加业务处理复杂度，这时候使用MQ， 将发短信、发邮箱，通知MQ，由另外服务平台完成。解决了代码的耦合问题。\n\n2、 当系统使用搜索平台、缓存平台的时候。\n\n查询数据，建立缓存、索引 ，当再次查询相同数据的时候，不从数据库查询，从缓存或者索引库查询\n\n当增加、修改、删除数据时，发送消息给MQ， 缓存平台、索引平台 从MQ获取到这个信息，更新缓存或者索引\n\n总结：使用MQ作为系统间数据调用的中转站。\n\n\n\n2、ActiveMQ安装和使用\n官网：http://activemq.apache.org/\n\n下载\n\n\n\n\n\n下载windows版本\n\n\n\n进行apache-activemq-5.14.0\\bin\\win64目录 启动activemq.bat 文件\n\n访问：http://localhost:8161/ 点击：Manage ActiveMQ broker\n\n用户名和密码 都是admin \n1\n\n\nActiveMQ使用的是标准生产者和消费者模型\n\n有两种数据结构 Queue、Topic (详见4.2)\n1\n1、Queue 队列（P2P消息模型） ，生产者生产了一个消息，只能由一个消费者进行消费 ：给微信好友发消息\n\n2、Topic 主题/广播（Pub/Sub消息模型），生产者生产了一个消息，可以由多个消费者进行消费\n\n  微信公众号给粉丝发消息\n1\nJMS和ActiveMQ的对应\n\nJMS消息模型\tP2P模式\tpub/sub模式\nActiveMQ消息\tQueue队列\tTopic队列\n特点\t一对一，一个人发送，只允许一个人接收\t一对多，一个人发送，允许多个人接收\n发送的人：生产者\n接收的人：消费者 \n1\n2\n2、使用Java程序操作ActiveMQ\n2.1、Queue-HelloWorld\n2.1.1、pom\n<dependencies>\n    <dependency>\n        <groupId>org.apache.activemq</groupId>\n        <artifactId>activemq-all</artifactId>\n        <version>5.14.0</version>\n    </dependency>\n</dependencies>\n1\n2\n3\n4\n5\n6\n7\n2.1.2、编写生产者\n使用JMS原生API编写测试类，向消息中间件写入消息的开发步骤：\n\n1 创建链接工厂\n2 从链接工厂中获取链接\n3 启动链接\n4 获取会话\n5 创建Queue队列\n6 创建生产者\n7 创建消息\n8 发送消息\n9 提交请求\n10 关闭各种资源\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n第一步：在test/java包中，创建包activeMQ_helloworld，创建类ActiveMQProducter\n\npublic class ActiveMQProducter {\n\n    public static void main(String[] args) throws Exception{\n        // 连接工厂\n        // 使用默认用户名、密码、路径\n        // 因为：底层实现：final String defaultURL = \"tcp://\" + DEFAULT_BROKER_HOST + \":\" + DEFAULT_BROKER_PORT;\n        // 所以：路径 tcp://host:61616\n        //1 创建连接工厂\n        ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory();\n        //2 创建连接\n        Connection connection = connectionFactory.createConnection();\n        //3 打开连接\n        connection.start();\n        //4 创建会话\n        //第一个参数：是否开启事务\n        //第二个参数：消息是否自动确认\n        Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);\n        //创建队列\n        Queue queue = session.createQueue(\"hello1115\");\n        //5 创建生产者\n        MessageProducer producer = session.createProducer(queue);\n        //6 创建消息\n        Message message = session.createTextMessage(\"hi i am boy\");\n        //7 发送消息\n        producer.send(message);\n\n        //8 关闭消息\n        session.commit();\n        producer.close();\n        session.close();\n        connection.close();\n        System.out.println(\"消息生产成功\");\n    }\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n第二步：运行代码，在控制台提示：\n\n\n\n第三步：查看页面效果，默认tcp连接activeMQ端口 61616 ！！！\n\n\n\n2.1.3、编写消费者\n使用JMS原生API编写测试类，向消息中间件消费消息的开发步骤：\n\n1 创建链接工厂\n2 创建链接\n3 启动链接\n4 获取会话\n5 创建队列\n6 创建消费者\n7 消费消息\n8 提交\n9 关闭资源\n1\n2\n3\n4\n5\n6\n7\n8\n9\n第一步：使用MessageConsumer完成消费ActiveMQConsumer.java\n\npublic class ActiveMQConsumer {\n    public static void main(String[] args) throws Exception {\n        //创建连接工厂\n        ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory();\n        //创建连接\n        Connection connection = connectionFactory.createConnection();\n        //开启连接\n        connection.start();\n        //创建会话\n        /** 第一个参数，是否使用事务\n         如果设置true，操作消息队列后，必须使用 session.commit();\n         如果设置false，操作消息队列后，不使用session.commit();\n         */\n        Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);\n        //创建队列\n        Queue queue = session.createQueue(\"hello1115\");\n        //创建消费者\n        MessageConsumer consumer = session.createConsumer(queue);\n        while(true){\n            //失效时间，如果10秒内没有收到新的消息，说明没有消息存在，此时可以退出当前循环\n            TextMessage message = (TextMessage) consumer.receive(10000);\n            if(message!=null){\n                System.out.println(message.getText());\n            }else {\n                break;\n            }\n        }\n\n        //关闭连接\n        session.commit();\n        session.close();\n        connection.close();\n\n        System.out.println(\"消费结束0\");\n    }\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n第二步：查看控制台，发现信息已经被消费\n\n\n\n第三步：查看页面效果\n\n访问：http://localhost:8161/ 点击：Manage ActiveMQ broker\n\n用户名和密码 都是admin \n1\n消费前：表示没有消费\n\n\n\n消费后：表示已经消费\n\n\n\n2.1.4、监听器消费消息\n// 使用监听器消费\npublic static void main(String[] args) throws Exception {\n    // 连接工厂\n    // 使用默认用户名、密码、路径\n    // 路径 tcp://host:61616\n    ConnectionFactory connectionFactory = new ActiveMQConnectionFactory();\n    // 获取一个连接\n    Connection connection = connectionFactory.createConnection();\n    // 开启连接\n    connection.start();\n    // 建立会话\n    // 第一个参数，是否使用事务，如果设置true，操作消息队列后，必须使用 session.commit();\n    Session session = connection.createSession(false,Session.AUTO_ACKNOWLEDGE);\n    // 创建队列或者话题对象\n    Queue queue = session.createQueue(\"Hello1115\");\n    // 创建消费者\n    MessageConsumer messageConsumer = session.createConsumer(queue);\n\n    messageConsumer.setMessageListener(new MessageListener() {\n        // 每次接收消息，自动调用 onMessage\n        public void onMessage(Message message) {\n            TextMessage textMessage = (TextMessage) message;\n            try {\n                System.out.println(textMessage.getText());\n            } catch (JMSException e) {\n                e.printStackTrace();\n            }\n        }\n    });\n    //此时，不能让程序结束，如果结束，监听就结束了\n    while (true) {\n        // 目的：不能让程序死掉\n    }\n} \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n重复测试生成和消费的过程。实现一边生产，一边消费的系统。\n\n2.2、多消费者模式-queue\n\n\nP2P消息模型中的多消费者模式，得出结论如下：\n\n一个消息只能被一个消费者消费，不可重复消费\n多个消费者均分消息(负载均衡策略)\n当消费者在消费某个消息的时候，mq一定要等到它的成功回执，才会分发下一个消息\n\n\n注意：测试的时候一定先启动消费者，然后再启动生产者\n\n###3.3、Topic-HelloWorld\n\nTopic：主题模式、广播模式、pus/sub模式、\n\n//4 获取会话\n// 第一个参数：是否开启事务  true 开启事务，后面一定要提交commit\n// 第二个参数：是否自动确认消息已经被消费\nSession session = connection.createSession(true,Session.AUTO_ACKNOWLEDGE);\n//5 创建Topic主题模式\n//Queue queue = session.createQueue(\"java1.0913\");\nTopic topic = session.createTopic(\"java1.0319\");\n//6 创建生产者\nMessageProducer producer = session.createProducer(topic);\n1\n2\n3\n4\n5\n6\n7\n8\n9\n2.4、多消费者模式-topic\n\n\n2.5 queue和topic模式的比较\n相同点：\n\n1、都只有一个生产者\n\n2、都可以有多个消费者\n\n不同点：\n\n1、queue队列模式，一个消息只能被一个消费者消费，不能重复消费\n\n当消费者消费某个消息的时候，一定要得到这个消息被成功消费的回执，才会分发下一个消息\nqueue入队之后，无论等待多久，消息都会一直等待消费者来处理\n\n2、topic广播模式，一个消息可以被多个消费者消费\n\n这个消息无法被成功消费与否，都无所谓\n\ntopic要求时间要一致，我正好发，你正好收\n\n3、SpringBoot整合ActiveMQ\n在Spring Boot中集成ActiveMQ相对还是比较简单的，都不需要安装什么服务，默认使用内存的activeMQ，当然配合外置ActiveMQ Server会更好。\n\n我们采用外置ActiveMQ。\n1\n3.1、创建工程maven子模块\n1、在common_parent中导入activeMQ的启动器\n\n<!-- ActiveMQ的启动器 -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-activemq</artifactId>\n</dependency>\n1\n2\n3\n4\n5\n2、创建bos-mq子模块\n\n\n\n\n\n\n\n3、添加项目依赖\n\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n    </dependency>\n    <!-- ActiveMQ的启动器 -->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-activemq</artifactId>\n    </dependency>\n</dependencies>\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n4、创建程序入口\n\n\n\n代码如下：\n\n@SpringBootApplication\npublic class BosMqApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(BosMqApplication.class, args);\n    }\n}\n1\n2\n3\n4\n5\n6\n7\n5、创建application.properties，具体配置如下：\n\n\n\n# MQ所在的服务器的地址\nspring.activemq.broker-url=tcp://127.0.0.1:61616\n# 是否使用内置的MQ， true  使用； fale  不使用\nspring.activemq.in-memory=false \n# 是否在回滚回滚消息之前停止消息传递。这意味着当启用此命令时，消息顺序不会被保留。\nspring.activemq.non-blocking-redelivery=false\n# 用户名\nspring.activemq.password=admin\n# 密码\nspring.activemq.user=admin\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n配置的具体意思\n\nspring.activemq.broker-url=tcp://127.0.0.1:61616\n# 在考虑结束之前等待的时间\n#spring.activemq.close-timeout=15s \n# 默认代理URL是否应该在内存中。如果指定了显式代理，则忽略此值。\nspring.activemq.in-memory=true \n# 是否在回滚回滚消息之前停止消息传递。这意味着当启用此命令时，消息顺序不会被保留。\nspring.activemq.non-blocking-redelivery=false\n# 密码\nspring.activemq.password=admin\n# 等待消息发送响应的时间。设置为0等待永远。\nspring.activemq.user=admin\n# 是否信任所有包\n#spring.activemq.packages.trust-all=\n# 要信任的特定包的逗号分隔列表（当不信任所有包时）\n#spring.activemq.packages.trusted=\n# 当连接请求和池满时是否阻塞。设置false会抛“JMSException异常”。\n#spring.activemq.pool.block-if-full=true\n# 如果池仍然满，则在抛出异常前阻塞时间。\n#spring.activemq.pool.block-if-full-timeout=-1ms\n# 是否在启动时创建连接。可以在启动时用于加热池。\n#spring.activemq.pool.create-connection-on-startup=true\n# 是否用Pooledconnectionfactory代替普通的ConnectionFactory。\n#spring.activemq.pool.enabled=false \n# 连接过期超时。\n#spring.activemq.pool.expiry-timeout=0ms\n# 连接空闲超时\n#spring.activemq.pool.idle-timeout=30s\n# 连接池最大连接数\n#spring.activemq.pool.max-connections=1\n# 每个连接的有效会话的最大数目。\n#spring.activemq.pool.maximum-active-session-per-connection=500\n# 当有\"JMSException\"时尝试重新连接\n#spring.activemq.pool.reconnect-on-exception=true\n# 在空闲连接清除线程之间运行的时间。当为负数时，没有空闲连接驱逐线程运行。\n#spring.activemq.pool.time-between-expiration-check=-1ms\n# 是否只使用一个MessageProducer\n#spring.activemq.pool.use-anonymous-producers=true\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n6、创建config\n\n\n\n代码如下：\n\npackage com.czxy.config;\nimport javax.jms.Queue;\nimport javax.jms.Topic;\nimport org.apache.activemq.command.ActiveMQQueue;\nimport org.apache.activemq.command.ActiveMQTopic;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n@Configuration\npublic class ActiveMQConfig {\n\t@Bean\n\tpublic Queue queue() {\n\t\t return new ActiveMQQueue(\"Armyman.queue\");\n\t}\n\t@Bean\n\tpublic Topic topic() {\n\t\treturn new ActiveMQTopic(\"Armyman.topic\");\n\t}\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n3.2、编写消费者和生产者\n1、编写生产者QueueProducer\n\n\n\n/**\n  * 消息的生产者 \n  * @author Administrator\n  *\n  */\n@Componet\n@EnableScheduling\npublic class QueueProducer {  \n\t/*\n\t * @Autowired // 也可以注入JmsTemplate，JmsMessagingTemplate对JmsTemplate进行了封装\n\t * private JmsMessagingTemplate jmsTemplate; //\n\t * 发送消息，destination是发送到的队列，message是待发送的消息\n\t * \n\t * @Scheduled(fixedDelay=3000)//每3s执行1次 \n\t   public void sendMessage(Destination destination, final String message){\n\t      jmsTemplate.convertAndSend(destination, message); \n\t   }\n\t */\n\n    @Autowired\n    private JmsMessagingTemplate jmsMessagingTemplate;\n\n    @Autowired\n    private Queue queue;\n\n    @Scheduled(fixedDelay=3000)//每3s执行1次\n    public void send() {\n       try {\n\t\t\n\t\t   MapMessage mapMessage = new ActiveMQMapMessage();\n\t\t   mapMessage.setString(\"info\", \"你还在睡觉\");\n\t\t   \n\t\t   this.jmsMessagingTemplate.convertAndSend(this.queue, mapMessage);\n\t\t   \n\t\t} catch (Exception e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n    }\n}  \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n2、编写消费者QueueConsumer\n\n\n\n/**\n * 消息的消费者\n * @author Administrator\n */\n@Component  \npublic class QueueConsumer {  \n    //使用JmsListener配置消费者监听的队列，其中Message是接收到的消息  \n\t@JmsListener(destination = \"Armyman.queue\")  \n    public void receiveQueue(Message message) {\n\t\ttry {\n\t\t\tMapMessage mapMessage = (MapMessage) message;\n\t\t\tString info = mapMessage.getString(\"info\");\n\t\t\tSystem.out.println(info);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n    } \n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n3、启动，测试，OK\n\n3.3 使用内置ActiveMQ\n只需要改变properties配置文件，即可运行\n\n# MQ所在的服务器的地址\n# spring.activemq.broker-url=tcp://127.0.0.1:61616\n# 是否使用SpringBoot内置的MQ， true  使用； fale  不使用\nspring.activemq.in-memory=true \n# 是否在回滚回滚消息之前停止消息传递。这意味着当启用此命令时，消息顺序不会被保留。\nspring.activemq.non-blocking-redelivery=false\n# 用户名\n# 密码\n#spring.activemq.user=admin\n# spring.activemq.password=admin\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n7 应用场景：\n\n用在高并发的请求中\n注册短信的发送\n注册邮件的发送\n秒杀\n两个系统间进行消息传递\n4.1、消息队列应用场景\n以下介绍消息队列在实际应用中常用的使用场景。\n\n异步处理，应用解耦，流量削锋和消息通讯四个场景\n\n4.1.1异步处理\n场景说明：用户注册后，需要发注册邮件和注册短信。传统的做法有两种:\n\n1.串行方式；2.并行方式\n\n（1）串行方式：将注册信息写入数据库成功后，发送注册邮件，再发送注册短信。以上三个任务全部完成后，返回给客户端\n\n\n\n（2）并行方式：将注册信息写入数据库成功后，发送注册邮件的同时，发送注册短信。以上三个任务完成后，返回给客户端。与串行的差别是，并行的方式可以提高处理的时间\n\n\n\n假设三个业务节点每个使用50毫秒钟，不考虑网络等其他开销，则串行方式的时间是150毫秒，并行的时间可能是100毫秒。\n\n因为CPU在单位时间内处理的请求数是一定的，假设CPU在1秒内吞吐量是100次。则串行方式1秒内CPU可处理的请求量是7次（1000/150）。并行方式处理的请求量是10次（1000/100）\n\n小结：如以上案例描述，传统的方式系统的性能（并发量，吞吐量，响应时间）会有瓶颈。如何解决这个问题呢？\n\n引入消息队列，将不是必须的业务逻辑，异步处理。改造后的架构如下：\n\n\n\n按照以上约定，用户的响应时间相当于是注册信息写入数据库的时间，也就是50毫秒。注册邮件，发送短信写入消息队列后，直接返回，因此写入消息队列的速度很快，基本可以忽略，因此用户的响应时间可能是50毫秒。因此架构改变后，系统的吞吐量提高到每秒20 QPS。比串行提高了3倍，比并行提高了2倍\n\n4.1.2应用解耦\n场景说明：用户下单后，订单系统需要通知库存系统。传统的做法是，订单系统调用库存系统的接口。如下图\n\n\n\n传统模式的缺点：\n\nl 假如库存系统无法访问，则订单减库存将失败，从而导致订单失败\n\nl 订单系统与库存系统耦合\n\n如何解决以上问题呢？引入应用消息队列后的方案，如下图：\n\n\n\n订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功\n\n库存系统：订阅下单的消息，采用pub/sub(发布/订阅)的方式，获取下单信息，库存系统根据下单信息，进行库存操作\n\n假如：在下单时库存系统不能正常使用。也不影响正常下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作了。实现订单系统与库存系统的应用解耦\n\n4.1.3流量削锋\n流量削锋也是消息队列中的常用场景，一般在秒杀或团抢活动中使用广泛\n\n应用场景：秒杀活动，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要在应用前端加入消息队列。\n\n可以控制活动的人数\n\n可以缓解短时间内高流量压垮应用\n\n\n\n用户的请求，服务器接收后，首先写入消息队列。假如消息队列长度超过最大数量，则直接抛弃用户请求或跳转到错误页面\n\n秒杀业务根据消息队列中的请求信息，再做后续处理\n\n4.1.4日志处理\n日志处理是指将消息队列用在日志处理中，比如Kafka的应用，解决大量日志传输的问题。架构简化如下\n\n\n\n日志采集客户端，负责日志数据采集，定时写受写入Kafka队列\n\nKafka消息队列，负责日志数据的接收，存储和转发\n\n日志处理应用：订阅并消费kafka队列中的日志数据[外链图片转存失败(img-gzmTdxhA-1567492404919)(assets/wps3257.tmp.jpg)]\n\n(1)Kafka：接收用户日志的消息队列\n\n(2)Logstash：做日志解析，统一成JSON输出给Elasticsearch\n\n(3)Elasticsearch：实时日志分析服务的核心技术，一个schemaless，实时的数据存储服务，通过index组织数据，兼具强大的搜索和统计功能\n\n(4)Kibana：基于Elasticsearch的数据可视化组件，超强的数据可视化能力是众多公司选择ELK stack的重要原因\n\n4.1.5消息通讯\n消息通讯是指，消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等\n\n点对点通讯：\n\n\n\n客户端A和客户端B使用同一队列，进行消息通讯。\n\n聊天室通讯：\n\n\n\n客户端A，客户端B，客户端N订阅同一主题，进行消息发布和接收。实现类似聊天室效果。\n\n以上实际是消息队列的两种消息模式，点对点或发布订阅模式。模型为示意图，供参考。\n\n4.2、JMS消息服务\n消息队列的JAVAEE规范JMS 。JMS（Java Message Service,java消息服务）API是一个消息服务的标准/规范，允许应用程序组件基于JavaEE平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。\n\n4.2.1 消息模型\n在JMS标准中，有两种消息模型P2P（Point to Point）,Publish/Subscribe(Pub/Sub)。\n\n4.2.2 P2P模式-队列模式\n\n\nP2P模式包含三个角色：消息队列（Queue），发送者(Sender)，接收者(Receiver)。每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到他们被消费或超时。\n\nP2P的特点\n\n每个消息只能被一个消费者（Consumer）消费(即一旦被消费，消息就不再存在于消息队列中)\n\n发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行，它不会影响到消息被发送到队列\n\n接收者在成功接收消息之后需向队列应答成功\n\n如果希望发送的每个消息都会被成功处理的话，那么需要P2P模式。\n\n4.2.3 Pub/Sub模式–广播/主题模式\n\n\n包含三个角色主题（Topic），发布者（Publisher），订阅者（Subscriber） 多个发布者将消息发送到Topic,系统将这些消息传递给多个订阅者。\n\nPub/Sub的特点\n\n每个消息可以有多个消费者\n\n发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息\n\n为了消费消息，订阅者必须保持运行的状态\n\n为了缓和这样严格的时间相关性，JMS允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息。\n\n如果希望发送的消息可以被多个消费者处理的话，那么可以采用Pub/Sub模型。\n\n4.3.消息消费方式\n在JMS中，消息的产生和消费都是异步的。对于消费来说，JMS的消息者可以通过两种方式来消费消息。\n\n（1）同步\n\n订阅者或接收者通过receive方法来接收消息，receive方法在接收到消息之前（或超时之前）将一直阻塞；\n\n（2）异步\n\n订阅者或接收者可以注册为一个消息监听器。当消息到达之后，系统自动调用监听器的onMessage方法。\n————————————————\n版权声明：本文为CSDN博主「Armymans」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/qq_43652509/article/details/83926758"]],[14761,14761],[25,25]]],[1571650407759,["david@DESKTOP-9844NL4",[[-1,25,"\n"],[1,26,"c"]],[25,25],[26,26]]],[1571650408087,["david@DESKTOP-9844NL4",[[1,26,"ank"]],[26,26],[29,29]]],[1571650408832,["david@DESKTOP-9844NL4",[[-1,26,"ank"]],[29,29],[26,26]]],[1571650409047,["david@DESKTOP-9844NL4",[[-1,25,"c"],[1,26,"\n"]],[26,26],[25,25]]],[1571650410311,["david@DESKTOP-9844NL4",[[-1,25,"\n"],[1,26,"参考"]],[25,25],[27,27]]],[1571650412498,["david@DESKTOP-9844NL4",[[1,27,"博客: [https://blog.csdn.net/qq_43652509/article/details/83926758](https://blog.csdn.net/qq_43652509/article/details/83926758)"]],[27,27],[151,151]]],[1571650413596,["david@DESKTOP-9844NL4",[[1,151,"\n\n"]],[151,151],[152,152]]],[1571650414531,["david@DESKTOP-9844NL4",[[1,153,"\n"]],[152,152],[153,153]]],[1571650462984,["david@DESKTOP-9844NL4",[[-1,153,"\n"],[1,154,"s"]],[153,153],[154,154]]],[1571650463095,["david@DESKTOP-9844NL4",[[1,154,"p"]],[154,154],[155,155]]],[1571650463728,["david@DESKTOP-9844NL4",[[-1,154,"p"]],[155,155],[154,154]]],[1571650463906,["david@DESKTOP-9844NL4",[[-1,153,"s"],[1,154,"\n"]],[154,154],[153,153]]],[1571650465341,["david@DESKTOP-9844NL4",[[-1,153,"\n"],[1,154,"使用"]],[153,153],[155,155]]],[1571650465625,["david@DESKTOP-9844NL4",[[-1,154,"用"]],[155,155],[154,154]]],[1571650465895,["david@DESKTOP-9844NL4",[[-1,153,"使"],[1,154,"\n"]],[154,154],[153,153]]],[1571650466869,["david@DESKTOP-9844NL4",[[-1,153,"\n"],[1,154,"开发"]],[153,153],[155,155]]],[1571650467720,["david@DESKTOP-9844NL4",[[1,155,"步骤"]],[155,155],[157,157]]],[1571650470616,["david@DESKTOP-9844NL4",[[1,153,"### "]],[153,153],[157,157]]],[1571650473414,["david@DESKTOP-9844NL4",[[-1,157,"开发步骤"]],[161,161],[157,157]]],[1571650476295,["david@DESKTOP-9844NL4",[[1,157,"1.添加一"]],[157,157],[162,162]]],[1571650476863,["david@DESKTOP-9844NL4",[[-1,159,"添加一"]],[162,162],[159,159]]],[1571650483262,["david@DESKTOP-9844NL4",[[1,159,"springboot项目中加入对"]],[159,159],[175,175]]],[1571650483772,["david@DESKTOP-9844NL4",[[-1,174,"对"]],[175,175],[174,174]]],[1571650484426,["david@DESKTOP-9844NL4",[[1,174,"a"]],[174,174],[175,175]]],[1571650488067,["david@DESKTOP-9844NL4",[[1,175,"ctiveMq依赖"]],[175,175],[184,184]]],[1571650488508,["david@DESKTOP-9844NL4",[[1,184,"\n\n"]],[184,184],[185,185]]],[1571650489410,["david@DESKTOP-9844NL4",[[-1,185,"\n"],[1,186,"·"]],[185,185],[186,186]]],[1571650489800,["david@DESKTOP-9844NL4",[[1,186,"··"]],[186,186],[188,188]]],[1571650490646,["david@DESKTOP-9844NL4",[[-1,186,"··"]],[188,188],[186,186]]],[1571650490821,["david@DESKTOP-9844NL4",[[-1,185,"·"],[1,186,"\n"]],[186,186],[185,185]]],[1571650491198,["david@DESKTOP-9844NL4",[[-1,185,"\n"],[1,186,"·"]],[185,185],[186,186]]],[1571650491607,["david@DESKTOP-9844NL4",[[1,186,"··"]],[186,186],[188,188]]],[1571650492183,["david@DESKTOP-9844NL4",[[-1,186,"··"]],[188,188],[186,186]]],[1571650492362,["david@DESKTOP-9844NL4",[[-1,185,"·"],[1,186,"\n"]],[186,186],[185,185]]],[1571650493301,["david@DESKTOP-9844NL4",[[-1,185,"\n"],[1,186,"`"]],[185,185],[186,186]]],[1571650493965,["david@DESKTOP-9844NL4",[[1,186,"``"]],[186,186],[188,188]]],[1571650493988,["david@DESKTOP-9844NL4",[[1,188,"language\n```\n"]],[188,188],[188,196]]],[1571650496656,["david@DESKTOP-9844NL4",[[-1,188,"language"],[1,196,"x"]],[188,196],[189,189]]],[1571650496938,["david@DESKTOP-9844NL4",[[1,189,"ml"]],[189,189],[191,191]]],[1571650497613,["david@DESKTOP-9844NL4",[[1,192,"\n"]],[191,191],[192,192]]],[1571650498395,["david@DESKTOP-9844NL4",[[1,192,"<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n    </dependency>\n    <!-- ActiveMQ的启动器 -->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-activemq</artifactId>\n    </dependency>\n</dependencies>\n————————————————\n版权声明：本文为CSDN博主「Armymans」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/qq_43652509/article/details/83926758"]],[192,192],[686,686]]],[1571650502169,["david@DESKTOP-9844NL4",[[-1,538,"————————————————\n版权声明：本文为CSDN博主「Armymans」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/qq_43652509/article/details/83926758"]],[538,686],[538,538]]],[1571650502636,["david@DESKTOP-9844NL4",[[-1,538,"\n"]],[538,538],[537,537]]],[1571650520864,["david@DESKTOP-9844NL4",[[-1,375," "],[1,376,"<!--引入ActiveMq依赖-->"],[-1,390,"  "],[-1,396,"  "],[-1,442,"    "],[1,504,"</dependency>\n\n<!--"],[1,506,"启用JMS"],[1,507,"的池化, 就一定要加上这个 jar--> <dependency>\n"],[1,508,"   <groupId>org.apache.activemq</groupId>\n    <artifactId>activemq-pool</artifactId>\n"]],[375,521],[674,674]]],[1571650521791,["david@DESKTOP-9844NL4",[[1,375," "],[-1,375,"<!--引入ActiveMq依赖-->"],[1,408,"  "],[1,412,"  "],[1,456,"    "],[-1,514,"</dependency>\n\n<!--"],[-1,535,"启用JMS"],[-1,541,"的池化, 就一定要加上这个 jar--> <dependency>\n"],[-1,576,"   <groupId>org.apache.activemq</groupId>\n    <artifactId>activemq-pool</artifactId>\n"]],[674,674],[375,521]]],[1571650524762,["david@DESKTOP-9844NL4",[[-1,209,"  <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n    </dependency>\n    <!-- ActiveMQ的启动器 -->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-activemq</artifactId>\n    </dependency>"]],[209,521],[209,209]]],[1571650525156,["david@DESKTOP-9844NL4",[[1,209,"<!--引入ActiveMq依赖--> <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-activemq</artifactId>\n</dependency>\n\n<!--  启用JMS 的池化, 就一定要加上这个 jar--> <dependency>\n    <groupId>org.apache.activemq</groupId>\n    <artifactId>activemq-pool</artifactId>\n</dependency>"]],[209,209],[508,508]]],[1571650526165,["david@DESKTOP-9844NL4",[[-1,209,"<!--引入ActiveMq依赖--> <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-activemq</artifactId>\n</dependency>\n\n<!--  启用JMS 的池化, 就一定要加上这个 jar--> <dependency>\n    <groupId>org.apache.activemq</groupId>\n    <artifactId>activemq-pool</artifactId>\n</dependency>"]],[508,508],[209,209]]],[1571650528819,["david@DESKTOP-9844NL4",[[-1,192,"<dependencies>\n  \n</dependencies>"]],[192,225],[192,192]]],[1571650529146,["david@DESKTOP-9844NL4",[[1,192,"<!--引入ActiveMq依赖--> <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-activemq</artifactId>\n</dependency>\n\n<!--  启用JMS 的池化, 就一定要加上这个 jar--> <dependency>\n    <groupId>org.apache.activemq</groupId>\n    <artifactId>activemq-pool</artifactId>\n</dependency>"]],[192,192],[491,491]]],[1571650532820,["david@DESKTOP-9844NL4",[[1,212,"\n"]],[212,212],[213,213]]],[1571650535469,["david@DESKTOP-9844NL4",[[1,192,"\n"]],[192,192],[193,193]]],[1571650539013,["david@DESKTOP-9844NL4",[[-1,192,"\n"]],[193,193],[192,192]]],[1571650542712,["david@DESKTOP-9844NL4",[[1,497,"\n"]],[496,496],[497,497]]],[1571650542890,["david@DESKTOP-9844NL4",[[1,498,"\n"]],[497,497],[498,498]]],[1571650544106,["david@DESKTOP-9844NL4",[[-1,498,"\n"],[1,499,"#"]],[498,498],[499,499]]],[1571650546056,["david@DESKTOP-9844NL4",[[1,499,"## 2. "]],[499,499],[505,505]]],[1571650601379,["david@DESKTOP-9844NL4",[[1,505,"application. "]],[505,505],[518,518]]],[1571650601870,["david@DESKTOP-9844NL4",[[-1,517," "]],[518,518],[517,517]]],[1571650613971,["david@DESKTOP-9844NL4",[[1,517,"yml配置mq服务器的配置"]],[517,517],[530,530]]],[1571650617699,["david@DESKTOP-9844NL4",[[-1,502,"2"]],[503,503],[502,502]]],[1571650617857,["david@DESKTOP-9844NL4",[[1,502,"3"]],[502,502],[503,503]]],[1571650620457,["david@DESKTOP-9844NL4",[[-1,157,"1"]],[158,158],[157,157]]],[1571650620613,["david@DESKTOP-9844NL4",[[1,157,"2"]],[157,157],[158,158]]],[1571650621471,["david@DESKTOP-9844NL4",[[1,153,"\n"]],[152,152],[153,153]]],[1571650624884,["david@DESKTOP-9844NL4",[[1,153,"### 1.安装"]],[153,153],[161,161]]],[1571650625428,["david@DESKTOP-9844NL4",[[-1,159,"安装"]],[161,161],[159,159]]],[1571650631798,["david@DESKTOP-9844NL4",[[1,159,"下载activeMq并启动"]],[159,159],[172,172]]],[1571650633429,["david@DESKTOP-9844NL4",[[1,173,"\n"]],[172,172],[173,173]]],[1571650636105,["david@DESKTOP-9844NL4",[[1,172,"（）"]],[172,172],[174,174]]],[1571650637456,["david@DESKTOP-9844NL4",[[-1,172,"（）"]],[174,174],[172,172]]],[1571650638167,["david@DESKTOP-9844NL4",[[1,172,"()"]],[172,172],[174,174]]],[1571650639792,["david@DESKTOP-9844NL4",[[1,173,"banb"]],[173,173],[177,177]]],[1571650640494,["david@DESKTOP-9844NL4",[[-1,173,"banb"]],[177,177],[173,173]]],[1571650641799,["david@DESKTOP-9844NL4",[[1,173,"版本"]],[173,173],[175,175]]],[1571650657969,["david@DESKTOP-9844NL4",[[1,175,"activemq5.15.4"]],[175,175],[189,189]]],[1571650660940,["david@DESKTOP-9844NL4",[[1,176,"a"]],[175,175],[176,176]]],[1571650661197,["david@DESKTOP-9844NL4",[[1,176,"po"]],[176,176],[178,178]]],[1571650661701,["david@DESKTOP-9844NL4",[[-1,177,"o"]],[178,178],[177,177]]],[1571650662018,["david@DESKTOP-9844NL4",[[1,178,"a"]],[177,177],[178,178]]],[1571650662866,["david@DESKTOP-9844NL4",[[1,178,"che-"]],[178,178],[182,182]]],[1571650669015,["david@DESKTOP-9844NL4",[[1,190,"-"]],[190,190],[191,191]]],[1571650672011,["david@DESKTOP-9844NL4",[[1,197,"ji"]],[197,197],[199,199]]],[1571650672540,["david@DESKTOP-9844NL4",[[-1,197,"ji"]],[199,199],[197,197]]],[1571650675464,["david@DESKTOP-9844NL4",[[1,197,"解压运行"]],[197,197],[201,201]]],[1571650681513,["david@DESKTOP-9844NL4",[[1,204,"\n"]],[202,202],[203,203]]],[1571650683541,["david@DESKTOP-9844NL4",[[1,203,"1 "]],[203,203],[205,205]]],[1571650684009,["david@DESKTOP-9844NL4",[[-1,203,"1 "]],[205,205],[203,203]]],[1571650686365,["david@DESKTOP-9844NL4",[[1,203,"管理路径"]],[203,203],[207,207]]],[1571650688083,["david@DESKTOP-9844NL4",[[-1,203,"管理路径"]],[207,207],[203,203]]],[1571650701724,["david@DESKTOP-9844NL4",[[1,203,"启动成功后管理路径是http://127.0.0.1:816"]],[203,203],[233,233]]],[1571650708326,["david@DESKTOP-9844NL4",[[1,233,"1 用户名密码admin admin"]],[233,233],[251,251]]],[1571650710585,["david@DESKTOP-9844NL4",[[-1,245," "]],[246,246],[245,245]]],[1571650711159,["david@DESKTOP-9844NL4",[[1,245,"/"]],[245,245],[246,246]]],[1571650713288,["david@DESKTOP-9844NL4",[[1,235,"\n"]],[235,235],[236,236]]],[1571650735582,["david@DESKTOP-9844NL4",[[1,254,"\n"]],[252,252],[253,253]]],[1571650883103,["david@DESKTOP-9844NL4",[[1,253,"![mark](http://blog.sjjtcloud.com/blog/20191021/FKqfRpofuTfa.png?imageslim)"]],[253,253],[328,328]]],[1571650886884,["david@DESKTOP-9844NL4",[[-1,253,"![mark](http://blog.sjjtcloud.com/blog/20191021/FKqfRpofuTfa.png?imageslim)"]],[328,328],[253,253]]],[1571650888606,["david@DESKTOP-9844NL4",[[1,153,"\n"]],[152,152],[153,153]]],[1571650889280,["david@DESKTOP-9844NL4",[[1,153,"![mark](http://blog.sjjtcloud.com/blog/20191021/FKqfRpofuTfa.png?imageslim)"]],[153,153],[228,228]]],[1571650890008,["david@DESKTOP-9844NL4",[[1,229,"\n"]],[228,228],[229,229]]],[1571650897927,["david@DESKTOP-9844NL4",[[1,709,"\n\n"]],[709,709],[710,710]]],[1571650898105,["david@DESKTOP-9844NL4",[[1,711,"\n"]],[710,710],[711,711]]],[1571650899721,["david@DESKTOP-9844NL4",[[-1,711,"\n"]],[711,711],[710,710]]],[1571650903029,["david@DESKTOP-9844NL4",[[1,22,"x"]],[22,22],[23,23]]],[1571650903331,["david@DESKTOP-9844NL4",[[-1,22,"x"]],[23,23],[22,22]]],[1571650916843,["david@DESKTOP-9844NL4",[[-1,701,"mq"],[1,703,"a"]],[701,703],[702,702]]],[1571650918606,["david@DESKTOP-9844NL4",[[1,702,"ctiveMq"]],[702,702],[709,709]]],[1571650953345,["david@DESKTOP-9844NL4",[[1,716,"# MQ所在的服务器的地址\nspring.activemq.broker-url=tcp://127.0.0.1:61616\n# 是否使用内置的MQ， true  使用； fale  不使用\nspring.activemq.in-memory=false \n# 是否在回滚回滚消息之前停止消息传递。这意味着当启用此命令时，消息顺序不会被保留。\nspring.activemq.non-blocking-redelivery=false\n# 用户名\nspring.activemq.password=admin\n# 密码\nspring.activemq.user=admin\n————————————————\n版权声明：本文为CSDN博主「Armymans」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/qq_43652509/article/details/83926758"]],[716,716],[1151,1151]]],[1571650954603,["david@DESKTOP-9844NL4",[[-1,716,"# MQ所在的服务器的地址\nspring.activemq.broker-url=tcp://127.0.0.1:61616\n# 是否使用内置的MQ， true  使用； fale  不使用\nspring.activemq.in-memory=false \n# 是否在回滚回滚消息之前停止消息传递。这意味着当启用此命令时，消息顺序不会被保留。\nspring.activemq.non-blocking-redelivery=false\n# 用户名\nspring.activemq.password=admin\n# 密码\nspring.activemq.user=admin\n————————————————\n版权声明：本文为CSDN博主「Armymans」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/qq_43652509/article/details/83926758"]],[1151,1151],[716,716]]],[1571650956146,["david@DESKTOP-9844NL4",[[1,716,"      "]],[716,716],[722,722]]],[1571650958053,["david@DESKTOP-9844NL4",[[-1,716,"      "]],[722,722],[716,716]]],[1571650959740,["david@DESKTOP-9844NL4",[[-1,716,"\n"],[1,717,"`"]],[716,716],[717,717]]],[1571650960253,["david@DESKTOP-9844NL4",[[1,717,"``"]],[717,717],[719,719]]],[1571650960276,["david@DESKTOP-9844NL4",[[1,719,"language\n```\n"]],[719,719],[719,727]]],[1571650962385,["david@DESKTOP-9844NL4",[[-1,719,"language"],[1,727,"y"]],[719,727],[720,720]]],[1571650962911,["david@DESKTOP-9844NL4",[[1,720,"ml"]],[720,720],[722,722]]],[1571650963520,["david@DESKTOP-9844NL4",[[1,723,"\n"]],[722,722],[723,723]]],[1571650963973,["david@DESKTOP-9844NL4",[[1,723,"# MQ所在的服务器的地址\nspring.activemq.broker-url=tcp://127.0.0.1:61616\n# 是否使用内置的MQ， true  使用； fale  不使用\nspring.activemq.in-memory=false \n# 是否在回滚回滚消息之前停止消息传递。这意味着当启用此命令时，消息顺序不会被保留。\nspring.activemq.non-blocking-redelivery=false\n# 用户名\nspring.activemq.password=admin\n# 密码\nspring.activemq.user=admin\n————————————————\n版权声明：本文为CSDN博主「Armymans」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/qq_43652509/article/details/83926758"]],[723,723],[1158,1158]]],[1571650970965,["david@DESKTOP-9844NL4",[[-1,1010,"————————————————\n版权声明：本文为CSDN博主「Armymans」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/qq_43652509/article/details/83926758"]],[1010,1158],[1010,1010]]],[1571650971508,["david@DESKTOP-9844NL4",[[-1,1010,"\n"]],[1010,1010],[1009,1009]]],[1571650981979,["david@DESKTOP-9844NL4",[[-1,763,"="]],[764,764],[763,763]]],[1571650983049,["david@DESKTOP-9844NL4",[[1,763,": "]],[763,763],[765,765]]],[1571650985234,["david@DESKTOP-9844NL4",[[-1,845,"="]],[846,846],[845,845]]],[1571650986095,["david@DESKTOP-9844NL4",[[1,845,": "]],[845,845],[847,847]]],[1571650990029,["david@DESKTOP-9844NL4",[[-1,936,"="]],[937,937],[936,936]]],[1571650990855,["david@DESKTOP-9844NL4",[[1,936,": "]],[936,936],[938,938]]],[1571650994179,["david@DESKTOP-9844NL4",[[-1,974,"="]],[975,975],[974,974]]],[1571650995133,["david@DESKTOP-9844NL4",[[1,974,": "]],[974,974],[976,976]]],[1571650998653,["david@DESKTOP-9844NL4",[[-1,1007,"="]],[1008,1008],[1007,1007]]],[1571650999784,["david@DESKTOP-9844NL4",[[1,1007,": "]],[1007,1007],[1009,1009]]],[1571651003272,["david@DESKTOP-9844NL4",[[-1,1009,"admin"],[1,1014,"y"]],[1009,1014],[1010,1010]]],[1571651004924,["david@DESKTOP-9844NL4",[[1,1010,"lzhy001"]],[1010,1010],[1017,1017]]],[1571651010201,["david@DESKTOP-9844NL4",[[1,1022,"\n"]],[1021,1021],[1022,1022]]],[1571651010397,["david@DESKTOP-9844NL4",[[1,1023,"\n"]],[1022,1022],[1023,1023]]],[1571651024317,["david@DESKTOP-9844NL4",[[-1,1023,"\n"]],[1023,1023],[1022,1022]]],[1571651025253,["david@DESKTOP-9844NL4",[[1,1023,"\n"]],[1022,1022],[1023,1023]]],[1571651027372,["david@DESKTOP-9844NL4",[[-1,1023,"\n"],[1,1024,"j"]],[1023,1023],[1024,1024]]],[1571651027833,["david@DESKTOP-9844NL4",[[1,1024,"ut"]],[1024,1024],[1026,1026]]],[1571651028436,["david@DESKTOP-9844NL4",[[-1,1024,"ut"]],[1026,1026],[1024,1024]]],[1571651028594,["david@DESKTOP-9844NL4",[[-1,1023,"j"],[1,1024,"\n"]],[1024,1024],[1023,1023]]],[1571651029546,["david@DESKTOP-9844NL4",[[-1,1023,"\n"],[1,1024,"具体"]],[1023,1023],[1025,1025]]],[1571651037288,["david@DESKTOP-9844NL4",[[1,1025,"的配置信息解析"]],[1025,1025],[1032,1032]]],[1571651037568,["david@DESKTOP-9844NL4",[[1,1032,"\n\n"]],[1032,1032],[1033,1033]]],[1571651038781,["david@DESKTOP-9844NL4",[[-1,1033,"\n"],[1,1034,"·"]],[1033,1033],[1034,1034]]],[1571651038959,["david@DESKTOP-9844NL4",[[1,1034,"·"]],[1034,1034],[1035,1035]]],[1571651039768,["david@DESKTOP-9844NL4",[[-1,1034,"·"]],[1035,1035],[1034,1034]]],[1571651039949,["david@DESKTOP-9844NL4",[[-1,1033,"·"],[1,1034,"\n"]],[1034,1034],[1033,1033]]],[1571651040491,["david@DESKTOP-9844NL4",[[-1,1033,"\n"],[1,1034,"`"]],[1033,1033],[1034,1034]]],[1571651041134,["david@DESKTOP-9844NL4",[[1,1034,"``"]],[1034,1034],[1036,1036]]],[1571651041158,["david@DESKTOP-9844NL4",[[1,1036,"language\n```\n"]],[1036,1036],[1036,1044]]],[1571651043022,["david@DESKTOP-9844NL4",[[-1,1036,"language"],[1,1044,"\n"]],[1036,1044],[1037,1037]]],[1571651043753,["david@DESKTOP-9844NL4",[[1,1037,"spring.activemq.broker-url=tcp://127.0.0.1:61616\n# 在考虑结束之前等待的时间\n#spring.activemq.close-timeout=15s \n# 默认代理URL是否应该在内存中。如果指定了显式代理，则忽略此值。\nspring.activemq.in-memory=true \n# 是否在回滚回滚消息之前停止消息传递。这意味着当启用此命令时，消息顺序不会被保留。\nspring.activemq.non-blocking-redelivery=false\n# 密码\nspring.activemq.password=admin\n# 等待消息发送响应的时间。设置为0等待永远。\nspring.activemq.user=admin\n# 是否信任所有包\n#spring.activemq.packages.trust-all=\n# 要信任的特定包的逗号分隔列表（当不信任所有包时）\n#spring.activemq.packages.trusted=\n# 当连接请求和池满时是否阻塞。设置false会抛“JMSException异常”。\n#spring.activemq.pool.block-if-full=true\n# 如果池仍然满，则在抛出异常前阻塞时间。\n#spring.activemq.pool.block-if-full-timeout=-1ms\n# 是否在启动时创建连接。可以在启动时用于加热池。\n#spring.activemq.pool.create-connection-on-startup=true\n# 是否用Pooledconnectionfactory代替普通的ConnectionFactory。\n#spring.activemq.pool.enabled=false \n# 连接过期超时。\n#spring.activemq.pool.expiry-timeout=0ms\n# 连接空闲超时\n#spring.activemq.pool.idle-timeout=30s\n# 连接池最大连接数\n#spring.activemq.pool.max-connections=1\n# 每个连接的有效会话的最大数目。\n#spring.activemq.pool.maximum-active-session-per-connection=500\n# 当有\"JMSException\"时尝试重新连接\n#spring.activemq.pool.reconnect-on-exception=true\n# 在空闲连接清除线程之间运行的时间。当为负数时，没有空闲连接驱逐线程运行。\n#spring.activemq.pool.time-between-expiration-check=-1ms\n# 是否只使用一个MessageProducer\n#spring.activemq.pool.use-anonymous-producers=true\n————————————————\n版权声明：本文为CSDN博主「Armymans」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/qq_43652509/article/details/83926758"]],[1037,1037],[2443,2443]]],[1571651057537,["david@DESKTOP-9844NL4",[[-1,2295,"————————————————\n版权声明：本文为CSDN博主「Armymans」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/qq_43652509/article/details/83926758"]],[2295,2443],[2295,2295]]],[1571651058237,["david@DESKTOP-9844NL4",[[-1,2295,"\n"]],[2295,2295],[2294,2294]]],[1571651071330,["david@DESKTOP-9844NL4",[[-1,30," [https://blog.csdn.net/qq_43652509/article/details/83926758]"]],[30,91],[30,30]]],[1571651076606,["david@DESKTOP-9844NL4",[[1,25,"zhuan"]],[25,25],[30,30]]],[1571651077737,["david@DESKTOP-9844NL4",[[-1,25,"zhuan"]],[30,30],[25,25]]],[1571651079414,["david@DESKTOP-9844NL4",[[1,25,"转载"]],[25,25],[27,27]]],[1571651088241,["david@DESKTOP-9844NL4",[[-1,25,"转载参考"]],[29,29],[25,25]]],[1571651090672,["david@DESKTOP-9844NL4",[[1,25,"查询资料"]],[25,25],[29,29]]],[1571651095105,["david@DESKTOP-9844NL4",[[-1,25,"查询"]],[27,27],[25,25]]],[1571651139870,["david@DESKTOP-9844NL4",[[1,2238,"\n"]],[2237,2237],[2238,2238]]],[1571651140042,["david@DESKTOP-9844NL4",[[1,2239,"\n"]],[2238,2238],[2239,2239]]],[1571651145004,["david@DESKTOP-9844NL4",[[-1,2239,"\n"],[1,2240,"#"]],[2239,2239],[2240,2240]]],[1571651159175,["david@DESKTOP-9844NL4",[[1,2240,"## 4.创建ActiveMqConfig"]],[2240,2240],[2261,2261]]],[1571651159586,["david@DESKTOP-9844NL4",[[1,2261,"\n\n"]],[2261,2261],[2262,2262]]],[1571651162034,["david@DESKTOP-9844NL4",[[-1,2262,"\n"],[1,2263,"`"]],[2262,2262],[2263,2263]]],[1571651162889,["david@DESKTOP-9844NL4",[[1,2263,"``"]],[2263,2263],[2265,2265]]],[1571651162916,["david@DESKTOP-9844NL4",[[1,2265,"language\n```\n"]],[2265,2265],[2265,2273]]],[1571651163848,["david@DESKTOP-9844NL4",[[-1,2265,"language"],[1,2273,"j"]],[2265,2273],[2266,2266]]],[1571651164783,["david@DESKTOP-9844NL4",[[1,2266,"ava"]],[2266,2266],[2269,2269]]],[1571651165011,["david@DESKTOP-9844NL4",[[1,2270,"\n"]],[2269,2269],[2270,2270]]],[1571651165465,["david@DESKTOP-9844NL4",[[1,2270,"@Configuration public class ActivemqConfig {\n   @Bean\n  public Queue queue() {\n      return new ActiveMQQueue(\"yw-advice-worker\");\n   }\n\n   @Bean(name = \"topic-company\")\n   public Topic topicCompany() {\n      return new ActiveMQTopic(\"topic-company\");\n   }\n\n   @Bean(name = \"topic-worker\")\n   public Topic topicWorker() {\n      return new ActiveMQTopic(\"topic-company\");\n   }\n\n}"]],[2270,2270],[2648,2648]]],[1571651168419,["david@DESKTOP-9844NL4",[[1,2285,"\n"]],[2285,2285],[2286,2286]]],[1571651190799,["david@DESKTOP-9844NL4",[[1,2327,"  "]],[2327,2327],[2329,2329]]],[1571651192313,["david@DESKTOP-9844NL4",[[-1,2328," "]],[2329,2329],[2328,2328]]],[1571651198102,["david@DESKTOP-9844NL4",[[1,2324,"(name = \"topic-company\")"]],[2324,2324],[2348,2348]]],[1571651199894,["david@DESKTOP-9844NL4",[[-1,2339,"company"],[1,2346,"q"]],[2339,2346],[2340,2340]]],[1571651201284,["david@DESKTOP-9844NL4",[[-1,2339,"q"]],[2340,2340],[2339,2339]]],[1571651203577,["david@DESKTOP-9844NL4",[[1,2339,"myqueue"]],[2339,2339],[2346,2346]]],[1571651211154,["david@DESKTOP-9844NL4",[[1,2679,"\n"]],[2678,2678],[2679,2679]]],[1571651211405,["david@DESKTOP-9844NL4",[[1,2680,"\n"]],[2679,2679],[2680,2680]]],[1571651498844,["david@DESKTOP-9844NL4",[[-1,2680,"\n"],[1,2681,"5"]],[2680,2680],[2681,2681]]],[1571651499686,["david@DESKTOP-9844NL4",[[-1,2680,"5"],[1,2681,"\n"]],[2681,2681],[2680,2680]]],[1571651500377,["david@DESKTOP-9844NL4",[[-1,2680,"\n"],[1,2681,"#"]],[2680,2680],[2681,2681]]],[1571651502178,["david@DESKTOP-9844NL4",[[1,2681,"## 5.b"]],[2681,2681],[2687,2687]]],[1571651502766,["david@DESKTOP-9844NL4",[[-1,2686,"b"]],[2687,2687],[2686,2686]]],[1571651503359,["david@DESKTOP-9844NL4",[[1,2686,"bian"]],[2686,2686],[2690,2690]]],[1571651504429,["david@DESKTOP-9844NL4",[[-1,2686,"bian"]],[2690,2690],[2686,2686]]],[1571651509068,["david@DESKTOP-9844NL4",[[1,2686,"编写生产者测试"]],[2686,2686],[2693,2693]]],[1571651509312,["david@DESKTOP-9844NL4",[[1,2693,"\n\n"]],[2693,2693],[2694,2694]]],[1571651510633,["david@DESKTOP-9844NL4",[[-1,2694,"\n"],[1,2695,"·"]],[2694,2694],[2695,2695]]],[1571651510994,["david@DESKTOP-9844NL4",[[1,2695,"··"]],[2695,2695],[2697,2697]]],[1571651511822,["david@DESKTOP-9844NL4",[[-1,2695,"··"]],[2697,2697],[2695,2695]]],[1571651511996,["david@DESKTOP-9844NL4",[[-1,2694,"·"],[1,2695,"\n"]],[2695,2695],[2694,2694]]],[1571651512403,["david@DESKTOP-9844NL4",[[-1,2694,"\n"],[1,2695,"`"]],[2694,2694],[2695,2695]]],[1571651512766,["david@DESKTOP-9844NL4",[[1,2695,"``"]],[2695,2695],[2697,2697]]],[1571651512793,["david@DESKTOP-9844NL4",[[1,2697,"language\n```\n"]],[2697,2697],[2697,2705]]],[1571651513237,["david@DESKTOP-9844NL4",[[-1,2697,"language"],[1,2705,"\n"]],[2697,2705],[2698,2698]]],[1571651514460,["david@DESKTOP-9844NL4",[[1,2698,"@RunWith(SpringRunner.class)\n@SpringBootTest(classes = ApiApplication.class)\npublic class ActiveMqProducterTest {\n\n    @Autowired\n  private JmsMessagingTemplate jmsTemplate;\n\n    @Resource(name = \"topic-company\")\n    private Topic adviceCompany;\n\n    @Test\n  public void testProducter(){\n        jmsTemplate.convertAndSend(adviceCompany, \"您有新的外卖订单,已为您自动接单\");\n\n    }\n\n}"]],[2698,2698],[3066,3066]]],[1571651518371,["david@DESKTOP-9844NL4",[[1,2697,"java"]],[2697,2697],[2701,2701]]],[1571651535199,["david@DESKTOP-9844NL4",[[-1,2819,"  "]],[2821,2821],[2819,2819]]],[1571651539536,["david@DESKTOP-9844NL4",[[-1,2877,"  "]],[2879,2879],[2877,2877]]],[1571651541734,["david@DESKTOP-9844NL4",[[-1,2913,"  "]],[2915,2915],[2913,2913]]],[1571651543951,["david@DESKTOP-9844NL4",[[-1,2945,"  "]],[2947,2947],[2945,2945]]],[1571651547739,["david@DESKTOP-9844NL4",[[-1,2989," "]],[2990,2990],[2989,2989]]],[1571651554877,["david@DESKTOP-9844NL4",[[1,3066,"\n"]],[3065,3065],[3066,3066]]],[1571651555068,["david@DESKTOP-9844NL4",[[1,3067,"\n"]],[3066,3066],[3067,3067]]],[1571651557007,["david@DESKTOP-9844NL4",[[-1,3067,"\n"],[1,3068,"#"]],[3067,3067],[3068,3068]]],[1571651559166,["david@DESKTOP-9844NL4",[[1,3068,"## 6. "]],[3068,3068],[3074,3074]]],[1571651559770,["david@DESKTOP-9844NL4",[[-1,3073," "]],[3074,3074],[3073,3073]]],[1571651559966,["david@DESKTOP-9844NL4",[[1,3073,"b"]],[3073,3073],[3074,3074]]],[1571651560525,["david@DESKTOP-9844NL4",[[-1,3073,"b"]],[3074,3074],[3073,3073]]],[1571651565102,["david@DESKTOP-9844NL4",[[1,3073,"编写消费者测试"]],[3073,3073],[3080,3080]]],[1571651567723,["david@DESKTOP-9844NL4",[[1,3080,"\n\n"]],[3080,3080],[3081,3081]]],[1571652439161,["david@DESKTOP-9844NL4",[[-1,3067,"### 6.编写消费者测试"]],[3067,3080],[3067,3067]]],[1571652439523,["david@DESKTOP-9844NL4",[[-1,3068,"\n"]],[3067,3067],[3066,3066]]]],null,"david@DESKTOP-9844NL4"],["c285ac55-2746-491d-9fd6-332290abb73d",1571709905743,"# springboot整合ActiveMq\n\n\n资料博客:(https://blog.csdn.net/qq_43652509/article/details/83926758)\n\n![mark](http://blog.sjjtcloud.com/blog/20191021/FKqfRpofuTfa.png?imageslim)\n\n### 1.下载activeMq并启动(版本apache-activemq-5.15.4解压运行)\n启动成功后管理路径是http://127.0.0.1:8161 \n用户名密码admin/admin\n\n\n### 2.springboot项目中加入activeMq依赖\n```xml\n<!--引入ActiveMq依赖--> \n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-activemq</artifactId>\n</dependency>\n\n<!--  启用JMS 的池化, 就一定要加上这个 jar--> <dependency>\n    <groupId>org.apache.activemq</groupId>\n    <artifactId>activemq-pool</artifactId>\n</dependency>\n```\n\n### 3. application.yml配置activeMq服务器的配置\n```yml\n# MQ所在的服务器的地址\nspring.activemq.broker-url: tcp://127.0.0.1:61616\n# 是否使用内置的MQ， true  使用； fale  不使用\nspring.activemq.in-memory: false \n# 是否在回滚回滚消息之前停止消息传递。这意味着当启用此命令时，消息顺序不会被保留。\nspring.activemq.non-blocking-redelivery: false\n# 用户名\nspring.activemq.password: admin\n# 密码\nspring.activemq.user: ylzhy001\n```\n\n具体的配置信息解析\n```\nspring.activemq.broker-url=tcp://127.0.0.1:61616\n# 在考虑结束之前等待的时间\n#spring.activemq.close-timeout=15s \n# 默认代理URL是否应该在内存中。如果指定了显式代理，则忽略此值。\nspring.activemq.in-memory=true \n# 是否在回滚回滚消息之前停止消息传递。这意味着当启用此命令时，消息顺序不会被保留。\nspring.activemq.non-blocking-redelivery=false\n# 密码\nspring.activemq.password=admin\n# 等待消息发送响应的时间。设置为0等待永远。\nspring.activemq.user=admin\n# 是否信任所有包\n#spring.activemq.packages.trust-all=\n# 要信任的特定包的逗号分隔列表（当不信任所有包时）\n#spring.activemq.packages.trusted=\n# 当连接请求和池满时是否阻塞。设置false会抛“JMSException异常”。\n#spring.activemq.pool.block-if-full=true\n# 如果池仍然满，则在抛出异常前阻塞时间。\n#spring.activemq.pool.block-if-full-timeout=-1ms\n# 是否在启动时创建连接。可以在启动时用于加热池。\n#spring.activemq.pool.create-connection-on-startup=true\n# 是否用Pooledconnectionfactory代替普通的ConnectionFactory。\n#spring.activemq.pool.enabled=false \n# 连接过期超时。\n#spring.activemq.pool.expiry-timeout=0ms\n# 连接空闲超时\n#spring.activemq.pool.idle-timeout=30s\n# 连接池最大连接数\n#spring.activemq.pool.max-connections=1\n# 每个连接的有效会话的最大数目。\n#spring.activemq.pool.maximum-active-session-per-connection=500\n# 当有\"JMSException\"时尝试重新连接\n#spring.activemq.pool.reconnect-on-exception=true\n# 在空闲连接清除线程之间运行的时间。当为负数时，没有空闲连接驱逐线程运行。\n#spring.activemq.pool.time-between-expiration-check=-1ms\n# 是否只使用一个MessageProducer\n#spring.activemq.pool.use-anonymous-producers=true\n```\n\n### 4.创建ActiveMqConfig\n```java\n@Configuration \npublic class ActivemqConfig {\n   @Bean(name = \"topic-myqueue\")\n   public Queue queue() {\n      return new ActiveMQQueue(\"yw-advice-worker\");\n   }\n\n   @Bean(name = \"topic-company\")\n   public Topic topicCompany() {\n      return new ActiveMQTopic(\"topic-company\");\n   }\n\n   @Bean(name = \"topic-worker\")\n   public Topic topicWorker() {\n      return new ActiveMQTopic(\"topic-company\");\n   }\n\n}\n```\n\n### 5.编写生产者测试\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest(classes = ApiApplication.class)\npublic class ActiveMqProducterTest {\n\n  @Autowired\n  private JmsMessagingTemplate jmsTemplate;\n\n  @Resource(name = \"topic-company\")\n  private Topic adviceCompany;\n\n  @Test\n  public void testProducter(){\n       jmsTemplate.convertAndSend(adviceCompany, \"您有新的外卖订单,已为您自动接单\");\n\n    }\n\n}\n```\n\n\n",[[1571709887710,["david@DESKTOP-9844NL4",[[1,2672,"   \n"]],[2671,2671],[2675,2675]]],[1571709887891,["david@DESKTOP-9844NL4",[[-1,2672,"   "],[1,2675,"\n"]],[2675,2675],[2673,2673]]],[1571709888649,["david@DESKTOP-9844NL4",[[1,2673,"// topic模式的ListenerContainer @Bean public JmsListenerContainerFactory<?> jmsListenerContainerTopic(ConnectionFactory activeMQConnectionFactory) {\n   DefaultJmsListenerContainerFactory bean = new DefaultJmsListenerContainerFactory();\n   bean.setPubSubDomain(true);\n   bean.setConnectionFactory(activeMQConnectionFactory);\n   return bean;\n}\n// queue模式的ListenerContainer @Bean public JmsListenerContainerFactory<?> jmsListenerContainerQueue(ConnectionFactory activeMQConnectionFactory) {\n   DefaultJmsListenerContainerFactory bean = new DefaultJmsListenerContainerFactory();\n   bean.setConnectionFactory(activeMQConnectionFactory);\n   return bean;\n}"]],[2673,2673],[3319,3319]]],[1571709892487,["david@DESKTOP-9844NL4",[[-1,2673,"// topic模式的ListenerContainer @Bean public JmsListenerContainerFactory<?> jmsListenerContainerTopic(ConnectionFactory activeMQConnectionFactory) {\n   DefaultJmsListenerContainerFactory bean = new DefaultJmsListenerContainerFactory();\n   bean.setPubSubDomain(true);\n   bean.setConnectionFactory(activeMQConnectionFactory);\n   return bean;\n}\n// queue模式的ListenerContainer @Bean public JmsListenerContainerFactory<?> jmsListenerContainerQueue(ConnectionFactory activeMQConnectionFactory) {\n   DefaultJmsListenerContainerFactory bean = new DefaultJmsListenerContainerFactory();\n   bean.setConnectionFactory(activeMQConnectionFactory);\n   return bean;\n}"]],[3319,3319],[2673,2673]]],[1571709893877,["david@DESKTOP-9844NL4",[[1,2673,"// topic模式的ListenerContainer @Bean public JmsListenerContainerFactory<?> jmsListenerContainerTopic(ConnectionFactory activeMQConnectionFactory) {\n   DefaultJmsListenerContainerFactory bean = new DefaultJmsListenerContainerFactory();\n   bean.setPubSubDomain(true);\n   bean.setConnectionFactory(activeMQConnectionFactory);\n   return bean;\n}\n// queue模式的ListenerContainer @Bean public JmsListenerContainerFactory<?> jmsListenerContainerQueue(ConnectionFactory activeMQConnectionFactory) {\n   DefaultJmsListenerContainerFactory bean = new DefaultJmsListenerContainerFactory();\n   bean.setConnectionFactory(activeMQConnectionFactory);\n   return bean;\n}"]],[2673,2673],[3319,3319]]],[1571709898212,["david@DESKTOP-9844NL4",[[1,2702,"\n"]],[2702,2702],[2703,2703]]],[1571709902182,["david@DESKTOP-9844NL4",[[1,2709,"\n"]],[2709,2709],[2710,2710]]],[1571709911090,["david@DESKTOP-9844NL4",[[-1,2791," "]],[2792,2792],[2791,2791]]],[1571709918594,["david@DESKTOP-9844NL4",[[-1,2673,"// topic模式的ListenerContainer \n@Bean \npublic JmsListenerContainerFactory<?> jmsListenerContainerTopic(ConnectionFactoryactiveMQConnectionFactory) {\n   DefaultJmsListenerContainerFactory bean = new DefaultJmsListenerContainerFactory();\n   bean.setPubSubDomain(true);\n   bean.setConnectionFactory(activeMQConnectionFactory);\n   return bean;\n}\n// queue模式的ListenerContainer @Bean public JmsListenerContainerFactory<?> jmsListenerContainerQueue(ConnectionFactory activeMQConnectionFactory) {\n   DefaultJmsListenerContainerFactory bean = new DefaultJmsListenerContainerFactory();\n   bean.setConnectionFactory(activeMQConnectionFactory);\n   return bean;\n}"]],[2673,3320],[2673,2673]]],[1571709937069,["david@DESKTOP-9844NL4",[[1,2675,"\n"]],[2673,2673],[2674,2674]]],[1571709938744,["david@DESKTOP-9844NL4",[[1,2672,"    "]],[2672,2672],[2676,2676]]],[1571709940178,["david@DESKTOP-9844NL4",[[-1,2675," "]],[2676,2676],[2675,2675]]],[1571709940806,["david@DESKTOP-9844NL4",[[-1,2672,"   "],[1,2675,"\n"]],[2675,2675],[2673,2673]]],[1571709942454,["david@DESKTOP-9844NL4",[[1,2673,"  // topic模式的ListenerContainer @Bean public JmsListenerContainerFactory<?> jmsListenerContainerTopic(ConnectionFactory activeMQConnectionFactory) {\n   DefaultJmsListenerContainerFactory bean = new DefaultJmsListenerContainerFactory();\n   bean.setPubSubDomain(true);\n   bean.setConnectionFactory(activeMQConnectionFactory);\n   return bean;\n}\n// queue模式的ListenerContainer @Bean public JmsListenerContainerFactory<?> jmsListenerContainerQueue(ConnectionFactory activeMQConnectionFactory) {\n   DefaultJmsListenerContainerFactory bean = new DefaultJmsListenerContainerFactory();\n   bean.setConnectionFactory(activeMQConnectionFactory);\n   return bean;\n}"]],[2673,2673],[3321,3321]]],[1571709946881,["david@DESKTOP-9844NL4",[[1,2704,"\n  "]],[2704,2704],[2707,2707]]],[1571709951356,["david@DESKTOP-9844NL4",[[1,2795,"     "]],[2795,2795],[2800,2800]]],[1571709955115,["david@DESKTOP-9844NL4",[[1,2713,"\n  "]],[2713,2713],[2716,2716]]],[1571709956495,["david@DESKTOP-9844NL4",[[-1,2714,"  "]],[2716,2716],[2714,2714]]],[1571709969154,["david@DESKTOP-9844NL4",[[1,3052,"\n"]],[3052,3052],[3053,3053]]],[1571709972007,["david@DESKTOP-9844NL4",[[1,3059,"\n"]],[3059,3059],[3060,3060]]],[1571709975509,["david@DESKTOP-9844NL4",[[1,3124,"\n"]],[3124,3124],[3125,3125]]],[1571709981431,["david@DESKTOP-9844NL4",[[1,2778,"\n"]],[2778,2778],[2779,2779]]],[1571709985982,["david@DESKTOP-9844NL4",[[-1,2798,"    "]],[2802,2802],[2798,2798]]],[1571709989886,["david@DESKTOP-9844NL4",[[-1,2778,"\n"]],[2779,2779],[2778,2778]]],[1571710002194,["david@DESKTOP-9844NL4",[[1,3019,"\n"]],[3018,3018],[3019,3019]]],[1571710488879,["david@DESKTOP-9844NL4",[[1,3729,"\n"]],[3727,3727],[3728,3728]]],[1571710496450,["david@DESKTOP-9844NL4",[[1,3728,"### 6.编写消费者 "]],[3728,3728],[3740,3740]]],[1571710497336,["david@DESKTOP-9844NL4",[[-1,3739," "]],[3740,3740],[3739,3739]]],[1571710497856,["david@DESKTOP-9844NL4",[[1,3739,"查"]],[3739,3739],[3740,3740]]],[1571710499064,["david@DESKTOP-9844NL4",[[-1,3739,"查"]],[3740,3740],[3739,3739]]],[1571710500164,["david@DESKTOP-9844NL4",[[1,3739,"测试"]],[3739,3739],[3741,3741]]],[1571710500495,["david@DESKTOP-9844NL4",[[1,3743,"\n"]],[3741,3741],[3742,3742]]],[1571710502884,["david@DESKTOP-9844NL4",[[1,3742,"```"]],[3742,3742],[3745,3745]]],[1571710502911,["david@DESKTOP-9844NL4",[[1,3745,"language\n```\n"]],[3745,3745],[3745,3753]]],[1571710504142,["david@DESKTOP-9844NL4",[[-1,3745,"language"],[1,3753,"j"]],[3745,3753],[3746,3746]]],[1571710504575,["david@DESKTOP-9844NL4",[[1,3746,"ava"]],[3746,3746],[3749,3749]]],[1571710504807,["david@DESKTOP-9844NL4",[[1,3750,"\n"]],[3749,3749],[3750,3750]]],[1571710505293,["david@DESKTOP-9844NL4",[[1,3750,"@Component public class ActiveMqConsumer {\n\n    private final static Logger logger = LoggerFactory.getLogger(ActiveMqConsumer.class);\n\n    @JmsListener(destination = \"topic-company\",containerFactory = \"jmsListenerContainerTopic\")\n    public void receiveTopic(String msg) {\n        logger.info(\"接收到topic消息：{}\",msg);\n    }\n\n    @JmsListener(destination = \"queue-advice\",containerFactory = \"jmsListenerContainerQueue\")\n    public void receiveQueue(String msg) {\n        logger.info(\"接收到queue消息：{}\",msg);\n    }\n\n}"]],[3750,3750],[4259,4259]]],[1571710508970,["david@DESKTOP-9844NL4",[[1,3761,"\n"]],[3761,3761],[3762,3762]]],[1571710513913,["david@DESKTOP-9844NL4",[[-1,3794,"\n"]],[3794,3794],[3793,3793]]],[1571710523712,["david@DESKTOP-9844NL4",[[-1,2705,"  "]],[2707,2707],[2705,2705]]],[1571710526725,["david@DESKTOP-9844NL4",[[1,2705,"  "]],[2705,2705],[2707,2707]]],[1571710529414,["david@DESKTOP-9844NL4",[[1,2714,"  "],[1,2829,"  "],[1,2913,"  "],[1,2947,"  "],[1,3004,"  "],[1,3017,"  "]],[2714,3018],[2714,3030]]],[1571710535420,["david@DESKTOP-9844NL4",[[1,3069,"  "],[1,3134,"  "],[1,3181,"  "],[1,3271,"  "],[1,3328,"  "],[1,3341,"  "]],[3069,3342],[3069,3354]]],[1571710538676,["david@DESKTOP-9844NL4",[[1,3062,"  "]],[3062,3062],[3064,3064]]],[1571710541336,["david@DESKTOP-9844NL4",[[1,3140,"  "]],[3140,3140],[3142,3142]]],[1571710546285,["david@DESKTOP-9844NL4",[[-1,3361,"\n"]],[3361,3361],[3360,3360]]],[1571710546512,["david@DESKTOP-9844NL4",[[-1,3360,"\n"]],[3360,3360],[3359,3359]]],[1571710546801,["david@DESKTOP-9844NL4",[[-1,3359,"\n"]],[3359,3359],[3358,3358]]],[1571710605382,["david@DESKTOP-9844NL4",[[-1,4282,"\n"]],[4282,4282],[4281,4281]]],[1571710990345,["david@DESKTOP-9844NL4",[[1,3628,"  \n"]],[3627,3627],[3630,3630]]],[1571710990538,["david@DESKTOP-9844NL4",[[-1,3628,"  "],[1,3630,"\n"]],[3630,3630],[3629,3629]]],[1571710991010,["david@DESKTOP-9844NL4",[[1,3629,"@Resource(name = \"queue-yw\")\nprivate Queue queueAdvice;"]],[3629,3629],[3684,3684]]],[1571710993787,["david@DESKTOP-9844NL4",[[1,3629,"  "],[1,3658,"  "]],[3629,3684],[3629,3688]]],[1571711004265,["david@DESKTOP-9844NL4",[[1,4343,"    \n"]],[4342,4342],[4347,4347]]],[1571711004513,["david@DESKTOP-9844NL4",[[-1,4343,"    "],[1,4347,"\n"]],[4347,4347],[4344,4344]]],[1571711008229,["david@DESKTOP-9844NL4",[[-1,3799,"\n"]],[3799,3799],[3798,3798]]],[1571711011509,["david@DESKTOP-9844NL4",[[-1,3801,"  "]],[3803,3803],[3801,3801]]],[1571711013760,["david@DESKTOP-9844NL4",[[1,3803,"  \n"]],[3802,3802],[3805,3805]]],[1571711014417,["david@DESKTOP-9844NL4",[[1,3805,"@Test public void testSendQueue(){\n    for(int i=0;i<10;i++){\n        jmsTemplate.convertAndSend(queueAdvice,\"你好\"+i);\n    }\n\n}"]],[3805,3805],[3931,3931]]],[1571711017445,["david@DESKTOP-9844NL4",[[1,3811,"\n  "]],[3811,3811],[3814,3814]]],[1571711018711,["david@DESKTOP-9844NL4",[[-1,3813," "]],[3814,3814],[3813,3813]]],[1571711019610,["david@DESKTOP-9844NL4",[[1,3813,"  "]],[3813,3813],[3815,3815]]],[1571711020298,["david@DESKTOP-9844NL4",[[-1,3814," "]],[3815,3815],[3814,3814]]],[1571711021844,["david@DESKTOP-9844NL4",[[-1,3846," "]],[3847,3847],[3846,3846]]],[1571711024555,["david@DESKTOP-9844NL4",[[-1,3926,"   "]],[3929,3929],[3926,3926]]],[1571711031574,["david@DESKTOP-9844NL4",[[-1,3877,"jmsTemplate.convertAndSend(queueAdvice,\"你好\"+i);"]],[3877,3924],[3877,3877]]],[1571711033711,["david@DESKTOP-9844NL4",[[-1,3845," for(int i=0;i<10;i++){"]],[3845,3868],[3845,3845]]],[1571711034282,["david@DESKTOP-9844NL4",[[1,3845,"jmsTemplate.convertAndSend(queueAdvice,\"你好\"+i);"]],[3845,3845],[3892,3892]]],[1571711037393,["david@DESKTOP-9844NL4",[[-1,3893,"        "]],[3901,3901],[3893,3893]]],[1571711038192,["david@DESKTOP-9844NL4",[[-1,3893,"\n"]],[3893,3893],[3892,3892]]],[1571711040544,["david@DESKTOP-9844NL4",[[-1,3888,"+i"]],[3890,3890],[3888,3888]]],[1571711046705,["david@DESKTOP-9844NL4",[[1,3887,",我来自队列"]],[3887,3887],[3893,3893]]],[1571711062106,["david@DESKTOP-9844NL4",[[-1,948,"ylzhy001"],[1,956,"admin"]],[948,956],[953,953]]],[1571711078834,["david@DESKTOP-9844NL4",[[-1,3898,"}"]],[3898,3899],[3898,3898]]],[1571711079353,["david@DESKTOP-9844NL4",[[-1,3899,"\n"]],[3898,3898],[3897,3897]]],[1571711080076,["david@DESKTOP-9844NL4",[[-1,3898,"\n"]],[3897,3897],[3896,3896]]],[1571711089419,["david@DESKTOP-9844NL4",[[-1,4281,"queue-advice"]],[4287,4293],[4281,4281]]],[1571711092240,["david@DESKTOP-9844NL4",[[1,4281,"queue-yw"]],[4281,4281],[4289,4289]]],[1571711097007,["david@DESKTOP-9844NL4",[[1,4411,"-yw"]],[4411,4411],[4414,4414]]],[1571711100165,["david@DESKTOP-9844NL4",[[-1,4434,"\n"]],[4433,4433],[4432,4432]]],[1571711101173,["david@DESKTOP-9844NL4",[[-1,4433,"\n"]],[4433,4433],[4432,4432]]],[1571711108293,["david@DESKTOP-9844NL4",[[1,92,"\n"]],[90,90],[91,91]]],[1571711120647,["david@DESKTOP-9844NL4",[[1,91,"[https://blog.csdn.net/cs_hnu_scw/article/details/81040834](https://blog.csdn.net/cs_hnu_scw/article/details/81040834)"]],[91,91],[209,209]]],[1571711128105,["david@DESKTOP-9844NL4",[[-1,91,"[https://blog.csdn.net/cs_hnu_scw/article/details/81040834]"]],[91,150],[91,91]]],[1571711131322,["david@DESKTOP-9844NL4",[[1,30,"\n"]],[30,30],[31,31]]],[1571711132363,["david@DESKTOP-9844NL4",[[1,31,"* "]],[31,31],[33,33]]],[1571711134492,["david@DESKTOP-9844NL4",[[1,94,"* "]],[94,94],[96,96]]],[1571711137742,["david@DESKTOP-9844NL4",[[-1,25,"资料博客:"]],[25,30],[25,25]]],[1571711138153,["david@DESKTOP-9844NL4",[[1,25,"can"]],[25,25],[28,28]]],[1571711139121,["david@DESKTOP-9844NL4",[[-1,25,"can"]],[28,28],[25,25]]],[1571711141080,["david@DESKTOP-9844NL4",[[1,25,"参考资料"]],[25,25],[29,29]]],[1571711149187,["david@DESKTOP-9844NL4",[[-1,25,"参考资料\n* (https://blog.csdn.net/qq_43652509/article/details/83926758)\n* (https://blog.csdn.net/cs_hnu_scw/article/details/81040834)\n"]],[25,155],[25,25]]],[1571711149631,["david@DESKTOP-9844NL4",[[-1,25,"\n"]],[25,25],[24,24]]],[1571711149924,["david@DESKTOP-9844NL4",[[-1,24,"\n"]],[24,24],[23,23]]],[1571711154366,["david@DESKTOP-9844NL4",[[1,4373,"\n"]],[4370,4370],[4371,4371]]],[1571711154557,["david@DESKTOP-9844NL4",[[1,4374,"\n"]],[4371,4371],[4372,4372]]],[1571711154716,["david@DESKTOP-9844NL4",[[1,4375,"\n"]],[4372,4372],[4373,4373]]],[1571711155338,["david@DESKTOP-9844NL4",[[1,4373,"参考资料\n* (https://blog.csdn.net/qq_43652509/article/details/83926758)\n* (https://blog.csdn.net/cs_hnu_scw/article/details/81040834)\n"]],[4373,4373],[4503,4503]]],[1571711164553,["david@DESKTOP-9844NL4",[[1,22,"入门"]],[22,22],[24,24]]]],null,"david@DESKTOP-9844NL4"],["8962c54b-417d-48fa-81bc-b61b910fdb27",1571964997137,"# springboot整合ActiveMq入门\n\n![mark](http://blog.sjjtcloud.com/blog/20191021/FKqfRpofuTfa.png?imageslim)\n\n### 1.下载activeMq并启动(版本apache-activemq-5.15.4解压运行)\n启动成功后管理路径是http://127.0.0.1:8161 \n用户名密码admin/admin\n\n\n### 2.springboot项目中加入activeMq依赖\n```xml\n<!--引入ActiveMq依赖--> \n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-activemq</artifactId>\n</dependency>\n\n<!--  启用JMS 的池化, 就一定要加上这个 jar--> <dependency>\n    <groupId>org.apache.activemq</groupId>\n    <artifactId>activemq-pool</artifactId>\n</dependency>\n```\n\n### 3. application.yml配置activeMq服务器的配置\n```yml\n# MQ所在的服务器的地址\nspring.activemq.broker-url: tcp://127.0.0.1:61616\n# 是否使用内置的MQ， true  使用； fale  不使用\nspring.activemq.in-memory: false \n# 是否在回滚回滚消息之前停止消息传递。这意味着当启用此命令时，消息顺序不会被保留。\nspring.activemq.non-blocking-redelivery: false\n# 用户名\nspring.activemq.password: admin\n# 密码\nspring.activemq.user: admin\n```\n\n具体的配置信息解析\n```\nspring.activemq.broker-url=tcp://127.0.0.1:61616\n# 在考虑结束之前等待的时间\n#spring.activemq.close-timeout=15s \n# 默认代理URL是否应该在内存中。如果指定了显式代理，则忽略此值。\nspring.activemq.in-memory=true \n# 是否在回滚回滚消息之前停止消息传递。这意味着当启用此命令时，消息顺序不会被保留。\nspring.activemq.non-blocking-redelivery=false\n# 密码\nspring.activemq.password=admin\n# 等待消息发送响应的时间。设置为0等待永远。\nspring.activemq.user=admin\n# 是否信任所有包\n#spring.activemq.packages.trust-all=\n# 要信任的特定包的逗号分隔列表（当不信任所有包时）\n#spring.activemq.packages.trusted=\n# 当连接请求和池满时是否阻塞。设置false会抛“JMSException异常”。\n#spring.activemq.pool.block-if-full=true\n# 如果池仍然满，则在抛出异常前阻塞时间。\n#spring.activemq.pool.block-if-full-timeout=-1ms\n# 是否在启动时创建连接。可以在启动时用于加热池。\n#spring.activemq.pool.create-connection-on-startup=true\n# 是否用Pooledconnectionfactory代替普通的ConnectionFactory。\n#spring.activemq.pool.enabled=false \n# 连接过期超时。\n#spring.activemq.pool.expiry-timeout=0ms\n# 连接空闲超时\n#spring.activemq.pool.idle-timeout=30s\n# 连接池最大连接数\n#spring.activemq.pool.max-connections=1\n# 每个连接的有效会话的最大数目。\n#spring.activemq.pool.maximum-active-session-per-connection=500\n# 当有\"JMSException\"时尝试重新连接\n#spring.activemq.pool.reconnect-on-exception=true\n# 在空闲连接清除线程之间运行的时间。当为负数时，没有空闲连接驱逐线程运行。\n#spring.activemq.pool.time-between-expiration-check=-1ms\n# 是否只使用一个MessageProducer\n#spring.activemq.pool.use-anonymous-producers=true\n```\n\n### 4.创建ActiveMqConfig\n```java\n@Configuration \npublic class ActivemqConfig {\n   @Bean(name = \"topic-myqueue\")\n   public Queue queue() {\n      return new ActiveMQQueue(\"yw-advice-worker\");\n   }\n\n   @Bean(name = \"topic-company\")\n   public Topic topicCompany() {\n      return new ActiveMQTopic(\"topic-company\");\n   }\n\n   @Bean(name = \"topic-worker\")\n   public Topic topicWorker() {\n      return new ActiveMQTopic(\"topic-company\");\n   }\n\n  // topic模式的ListenerContainer \n  @Bean \n  public JmsListenerContainerFactory<?> jmsListenerContainerTopic(ConnectionFactory  activeMQConnectionFactory) {\n     DefaultJmsListenerContainerFactory bean = new DefaultJmsListenerContainerFactory();\n     bean.setPubSubDomain(true);\n     bean.setConnectionFactory(activeMQConnectionFactory);\n     return bean;\n  }\n\n// queue模式的ListenerContainer \n  @Bean \n  public JmsListenerContainerFactory<?> jmsListenerContainerQueue(\n    ConnectionFactory activeMQConnectionFactory) {\n     DefaultJmsListenerContainerFactory bean = new DefaultJmsListenerContainerFactory();\n     bean.setConnectionFactory(activeMQConnectionFactory);\n     return bean;\n  }\n}\n```\n\n### 5.编写生产者测试\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest(classes = ApiApplication.class)\npublic class ActiveMqProducterTest {\n\n  @Autowired\n  private JmsMessagingTemplate jmsTemplate;\n\n  @Resource(name = \"topic-company\")\n  private Topic adviceCompany;\n\n  @Resource(name = \"queue-yw\")\n  private Queue queueAdvice;\n\n  @Test\n  public void testProducter(){\n       jmsTemplate.convertAndSend(adviceCompany, \"您有新的外卖订单,已为您自动接单\");\n  }\n  @Test \n  public void testSendQueue(){\n  jmsTemplate.convertAndSend(queueAdvice,\"你好,我来自队列\");\n }\n\n}\n```\n\n### 6.编写消费者测试\n```java\n@Component \npublic class ActiveMqConsumer {\n    private final static Logger logger = LoggerFactory.getLogger(ActiveMqConsumer.class);\n\n    @JmsListener(destination = \"topic-company\",containerFactory = \"jmsListenerContainerTopic\")\n    public void receiveTopic(String msg) {\n        logger.info(\"接收到topic消息：{}\",msg);\n    }\n\n    @JmsListener(destination = \"queue-yw\",containerFactory = \"jmsListenerContainerQueue\")\n    public void receiveQueue(String msg) {\n        logger.info(\"接收到queue-yw消息：{}\",msg);\n    }\n}\n```\n\n\n参考资料\n* (https://blog.csdn.net/qq_43652509/article/details/83926758)\n* (https://blog.csdn.net/cs_hnu_scw/article/details/81040834)\n\n\n\n",[[1571964969948,["david@DESKTOP-9844NL4",[[-1,0,"#"]],[1,1],[0,0]]],[1571964970758,["david@DESKTOP-9844NL4",[[1,0,"\n "]],[0,0],[2,2]]],[1571964971672,["david@DESKTOP-9844NL4",[[1,0,"---\ntitle: TCP/IP三次握手四次挥手\ncategories: TCP\ntags: TCP/IP\n---\n"]],[0,0],[59,59]]],[1571964972222,["david@DESKTOP-9844NL4",[[1,60,"\n"]],[59,59],[60,60]]],[1571964975899,["david@DESKTOP-9844NL4",[[-1,63,"springboot整合ActiveMq入门"]],[63,85],[63,63]]],[1571964979150,["david@DESKTOP-9844NL4",[[-1,11,"TCP/IP三次握手四次挥手"]],[12,25],[11,11]]],[1571964979484,["david@DESKTOP-9844NL4",[[1,11,"springboot整合ActiveMq入门"]],[11,11],[33,33]]],[1571964981919,["david@DESKTOP-9844NL4",[[-1,72,"\n"]],[72,72],[71,71]]],[1571964982497,["david@DESKTOP-9844NL4",[[-1,69,"  "]],[71,71],[69,69]]],[1571964982832,["david@DESKTOP-9844NL4",[[-1,69,"\n"]],[69,69],[68,68]]],[1571964983283,["david@DESKTOP-9844NL4",[[-1,68,"\n"]],[68,68],[67,67]]],[1571964989638,["david@DESKTOP-9844NL4",[[-1,46,"TCP"],[1,49,"ActiveMq"]],[46,49],[54,54]]],[1571964992341,["david@DESKTOP-9844NL4",[[-1,61,"TCP/IP"],[1,67,"ActiveMq"]],[61,67],[69,69]]],[1571965010261,["david@DESKTOP-9844NL4",[[-1,74,"\n"]],[74,74],[73,73]]],[1571965011400,["david@DESKTOP-9844NL4",[[1,74,"\n"]],[73,73],[74,74]]]],null,"david@DESKTOP-9844NL4"],["c499275a-bf5d-4029-abfd-9a06dd79be01",1572579523387,"---\ntitle: springboot整合ActiveMq入门\ncategories: ActiveMq\ntags: ActiveMq\n---\n\n![mark](http://blog.sjjtcloud.com/blog/20191021/FKqfRpofuTfa.png?imageslim)\n\n### 1.下载activeMq并启动(版本apache-activemq-5.15.4解压运行)\n启动成功后管理路径是http://127.0.0.1:8161 \n用户名密码admin/admin\n\n\n### 2.springboot项目中加入activeMq依赖\n```xml\n<!--引入ActiveMq依赖--> \n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-activemq</artifactId>\n</dependency>\n\n<!--  启用JMS 的池化, 就一定要加上这个 jar--> <dependency>\n    <groupId>org.apache.activemq</groupId>\n    <artifactId>activemq-pool</artifactId>\n</dependency>\n```\n\n### 3. application.yml配置activeMq服务器的配置\n```yml\n# MQ所在的服务器的地址\nspring.activemq.broker-url: tcp://127.0.0.1:61616\n# 是否使用内置的MQ， true  使用； fale  不使用\nspring.activemq.in-memory: false \n# 是否在回滚回滚消息之前停止消息传递。这意味着当启用此命令时，消息顺序不会被保留。\nspring.activemq.non-blocking-redelivery: false\n# 用户名\nspring.activemq.password: admin\n# 密码\nspring.activemq.user: admin\n```\n\n具体的配置信息解析\n```\nspring.activemq.broker-url=tcp://127.0.0.1:61616\n# 在考虑结束之前等待的时间\n#spring.activemq.close-timeout=15s \n# 默认代理URL是否应该在内存中。如果指定了显式代理，则忽略此值。\nspring.activemq.in-memory=true \n# 是否在回滚回滚消息之前停止消息传递。这意味着当启用此命令时，消息顺序不会被保留。\nspring.activemq.non-blocking-redelivery=false\n# 密码\nspring.activemq.password=admin\n# 等待消息发送响应的时间。设置为0等待永远。\nspring.activemq.user=admin\n# 是否信任所有包\n#spring.activemq.packages.trust-all=\n# 要信任的特定包的逗号分隔列表（当不信任所有包时）\n#spring.activemq.packages.trusted=\n# 当连接请求和池满时是否阻塞。设置false会抛“JMSException异常”。\n#spring.activemq.pool.block-if-full=true\n# 如果池仍然满，则在抛出异常前阻塞时间。\n#spring.activemq.pool.block-if-full-timeout=-1ms\n# 是否在启动时创建连接。可以在启动时用于加热池。\n#spring.activemq.pool.create-connection-on-startup=true\n# 是否用Pooledconnectionfactory代替普通的ConnectionFactory。\n#spring.activemq.pool.enabled=false \n# 连接过期超时。\n#spring.activemq.pool.expiry-timeout=0ms\n# 连接空闲超时\n#spring.activemq.pool.idle-timeout=30s\n# 连接池最大连接数\n#spring.activemq.pool.max-connections=1\n# 每个连接的有效会话的最大数目。\n#spring.activemq.pool.maximum-active-session-per-connection=500\n# 当有\"JMSException\"时尝试重新连接\n#spring.activemq.pool.reconnect-on-exception=true\n# 在空闲连接清除线程之间运行的时间。当为负数时，没有空闲连接驱逐线程运行。\n#spring.activemq.pool.time-between-expiration-check=-1ms\n# 是否只使用一个MessageProducer\n#spring.activemq.pool.use-anonymous-producers=true\n```\n\n### 4.创建ActiveMqConfig\n```java\n@Configuration \npublic class ActivemqConfig {\n   @Bean(name = \"topic-myqueue\")\n   public Queue queue() {\n      return new ActiveMQQueue(\"yw-advice-worker\");\n   }\n\n   @Bean(name = \"topic-company\")\n   public Topic topicCompany() {\n      return new ActiveMQTopic(\"topic-company\");\n   }\n\n   @Bean(name = \"topic-worker\")\n   public Topic topicWorker() {\n      return new ActiveMQTopic(\"topic-company\");\n   }\n\n  // topic模式的ListenerContainer \n  @Bean \n  public JmsListenerContainerFactory<?> jmsListenerContainerTopic(ConnectionFactory  activeMQConnectionFactory) {\n     DefaultJmsListenerContainerFactory bean = new DefaultJmsListenerContainerFactory();\n     bean.setPubSubDomain(true);\n     bean.setConnectionFactory(activeMQConnectionFactory);\n     return bean;\n  }\n\n// queue模式的ListenerContainer \n  @Bean \n  public JmsListenerContainerFactory<?> jmsListenerContainerQueue(\n    ConnectionFactory activeMQConnectionFactory) {\n     DefaultJmsListenerContainerFactory bean = new DefaultJmsListenerContainerFactory();\n     bean.setConnectionFactory(activeMQConnectionFactory);\n     return bean;\n  }\n}\n```\n\n### 5.编写生产者测试\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest(classes = ApiApplication.class)\npublic class ActiveMqProducterTest {\n\n  @Autowired\n  private JmsMessagingTemplate jmsTemplate;\n\n  @Resource(name = \"topic-company\")\n  private Topic adviceCompany;\n\n  @Resource(name = \"queue-yw\")\n  private Queue queueAdvice;\n\n  @Test\n  public void testProducter(){\n       jmsTemplate.convertAndSend(adviceCompany, \"您有新的外卖订单,已为您自动接单\");\n  }\n  @Test \n  public void testSendQueue(){\n  jmsTemplate.convertAndSend(queueAdvice,\"你好,我来自队列\");\n }\n\n}\n```\n\n### 6.编写消费者测试\n```java\n@Component \npublic class ActiveMqConsumer {\n    private final static Logger logger = LoggerFactory.getLogger(ActiveMqConsumer.class);\n\n    @JmsListener(destination = \"topic-company\",containerFactory = \"jmsListenerContainerTopic\")\n    public void receiveTopic(String msg) {\n        logger.info(\"接收到topic消息：{}\",msg);\n    }\n\n    @JmsListener(destination = \"queue-yw\",containerFactory = \"jmsListenerContainerQueue\")\n    public void receiveQueue(String msg) {\n        logger.info(\"接收到queue-yw消息：{}\",msg);\n    }\n}\n```\n\n\n参考资料\n* (https://blog.csdn.net/qq_43652509/article/details/83926758)\n* (https://blog.csdn.net/cs_hnu_scw/article/details/81040834)\n\n\n\n",[[1572579516866,["david@DESKTOP-9844NL4",[[-1,74,"\n"]],[74,74],[73,73]]],[1572579517563,["david@DESKTOP-9844NL4",[[1,74,"\n"]],[73,73],[74,74]]],[1572579519656,["david@DESKTOP-9844NL4",[[-1,151,"\n"]],[151,151],[150,150]]],[1572579520483,["david@DESKTOP-9844NL4",[[1,151,"\n"]],[150,150],[151,151]]]],null,"david@DESKTOP-9844NL4"]]}