{"compress":true,"commitItems":[["4ac70beb-1a28-4370-a247-caa601f63397",1566270201081,"---\nlayout: post\ntitle: Lorem ipsum\ncategories: \n  - consectetur\n  - malesuada\ntags:\n  - semper\n  - fermentum\n---\n\n![Nulla euismod, vitae aliquet orci eleifend.]($appres/images/night.jpg)\n\n# Lorem ipsum\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus eu tempor dolor. Nulla hendrerit convallis purus et elementum. Suspendisse non magna vel justo tincidunt finibus. Nullam dui erat, malesuada eget viverra non, finibus a nisl.",[[1566270144029,["david@DESKTOP-9844NL4",[[-1,189,"# Lorem ipsum"],[-1,203,"\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus eu tempor dolor. Nulla hendrerit convallis purus et elementum. Suspendisse non magna vel justo tincidunt finibus. Nullam dui erat, malesuada eget viverra non, finibus a nisl."]],[189,445],[189,189]]],[1566270144407,["david@DESKTOP-9844NL4",[[1,189,"# 线程池的优雅关闭实践\n\n[![96](https://upload.jianshu.io/users/upload_avatars/11183270/d3de5eeb-4ecc-4544-9aeb-2137e2635041?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96)](https://www.jianshu.com/u/bc1552d8e95d) \n\n[徐志毅](https://www.jianshu.com/u/bc1552d8e95d) 关注\n\n 0.7 2018.04.09 11:14* 字数 1865 阅读 10868评论 5喜欢 13\n\n**平时开发中，大家更多的关注的是线程池的创建、任务的提交和执行。往往会忽略线程池的关闭，甚至忘记调用`shutdown()`方法，导致内存溢出。大多知道需要调用shutdown()关闭线程池，也少研究其真正的关闭过程。**\n\n首先看源码中的一句注释：\n\n> A pool that is no longer referenced in a program and has no remaining threads will be shutdown automatically.\n> 如果程序中不再持有线程池的引用，并且线程池中没有线程时，线程池将会自动关闭。\n\n**线程池自动关闭的两个条件：1、线程池的引用不可达；2、线程池中没有线程；**\n\n这里对于条件2解释一下，线程池中没有线程是指线程池中的所有线程都已运行完自动消亡。然而我们常用的FixedThreadPool的核心线程没有超时策略，所以并不会自动关闭。\n\n展示两种不同线程池 **不关闭** 的情况：\n\n1、FixedThreadPool 示例\n\n```\npublic static void main(String[] args) {\n    while(true) {\n        ExecutorService executorService = Executors.newFixedThreadPool(8);\n        executorService.execute(() -> System.out.println(\"running\"));\n        executorService = null;\n    }\n}\n\n```\n\n输出结果：\n\n```\nrunning\n......\nrunning\nException in thread \"main\" java.lang.OutOfMemoryError: unable to create new native thread\n    at java.lang.Thread.start0(Native Method)\n    at java.lang.Thread.start(Thread.java:714)\n    at java.util.concurrent.ThreadPoolExecutor.addWorker(ThreadPoolExecutor.java:950)\n    at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1357)\n    at test.PoolTest.main(PoolTest.java:29)\n\n```\n\n因为FixedThreadPool的核心线程不会自动超时关闭，使用时必须在适当的时候调用shutdown()方法。\n\n2、 CachedThreadPool 示例\n\n```\npublic static void main(String[] args) {\n    while(true) {\n        // 默认keepAliveTime为 60s\n        ExecutorService executorService = Executors.newCachedThreadPool(); \n        ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) executorService;\n        // 为了更好的模拟，动态修改为1纳秒\n        threadPoolExecutor.setKeepAliveTime(1, TimeUnit.NANOSECONDS);\n        threadPoolExecutor.execute(() -> System.out.println(\"running\"));\n    }\n}\n\n```\n\n输出结果：\n\n```\nrunning\nrunning\nrunning\nrunning\nrunning\n......\n\n```\n\nCachedThreadPool 的线程 keepAliveTime 默认为 60s ，核心线程数量为 0 ，所以不会有核心线程存活阻止线程池自动关闭。 详见 [线程池之ThreadPoolExecutor构造](https://www.jianshu.com/p/f030aa5d7a28) ，为了更快的模拟，构造后将 keepAliveTime 修改为1纳秒，相当于线程执行完马上会消亡，所以线程池可以被回收。实际开发中，如果CachedThreadPool 确实忘记关闭，在一定时间后是可以被回收的。但仍然建议显示关闭。\n\n**然而，线程池关闭的意义不仅仅在于结束线程执行，避免内存溢出，因为大多使用的场景并非上述示例那样 朝生夕死。线程池一般是持续工作的全局场景，如数据库连接池。**\n\n本文更多要讨论的是当线程池调用shutdown方法后，会经历些什么？思考一下几个问题：\n\n> 1.  是否可以继续接受新任务？继续提交新任务会怎样？\n> 2.  等待队列里的任务是否还会执行？\n> 3.  正在执行的任务是否会立即中断？\n\n**问题1：是否可以继续接受新任务？继续提交新任务会怎样？**\n\n```\npublic static void main(String[] args) {\n    ThreadPoolExecutor executor = new ThreadPoolExecutor(4, 4, 10, TimeUnit.SECONDS, new LinkedBlockingQueue<>());\n    executor.execute(() -> System.out.println(\"before shutdown\"));\n    executor.shutdown();\n    executor.execute(() -> System.out.println(\"after shutdown\"));\n}\n\n```\n\n输出结果如下：\n\n```\nbefore shutdown\nException in thread \"main\" java.util.concurrent.RejectedExecutionException: Task PoolTest$$Lambda$2/142257191@3e3abc88 rejected from java.util.concurrent.ThreadPoolExecutor@6ce253f1[Terminated, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 1]\n    at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2047)\n    at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:823)\n    at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1369)\n    at PoolTest.main(PoolTest.java:12)\n\n```\n\n当线程池关闭后，继续提交新任务会抛出异常。这句话也不够准确，不一定是抛出异常，而是执行拒绝策略，默认的拒绝策略是抛出异常。可参见 [线程池之ThreadPoolExecutor构造](https://www.jianshu.com/p/f030aa5d7a28) 里面自定义线程池的例子，自定义了忽略策略，但被拒绝时并没有抛出异常。\n\n**问题2：等待队列里的任务是否还会执行？**\n\n```\npublic class WaitqueueTest {\n    public static void main(String[] args) {\n        BlockingQueue<Runnable> workQueue = new LinkedBlockingQueue<>();\n        for(int i = 1; i <= 100 ; i++){\n            workQueue.add(new Task(String.valueOf(i)));\n        }\n        ThreadPoolExecutor executor = new ThreadPoolExecutor(1, 1, 10, TimeUnit.SECONDS, workQueue);\n        executor.execute(new Task(\"0\"));\n        executor.shutdown();\n        System.out.println(\"workQueue size = \" + workQueue.size() + \" after shutdown\");\n    }\n\n    static class Task implements Runnable{\n        String name;\n\n        public Task(String name) {\n            this.name = name;\n        }\n\n        @Override\n        public void run() {\n            for(int i = 1; i <= 10; i++){\n                System.out.println(\"task \" + name + \" is running\");\n            }\n            System.out.println(\"task \" + name + \" is over\");\n        }\n    }\n}\n\n```\n\n这个demo解释一下，我们用LinkedBlockingQueue构造了一个线程池，在线程池启动前，我们先将工作队列填充100个任务，然后执行`task 0` 后立即`shutdown()`线程池，来验证线程池关闭队列的任务运行状态。\n输出结果如下：\n\n```\n......\ntask 0 is running\ntask 0 is over\nworkQueue size = 100 after shutdown //表示线程池关闭后，队列任然有100个任务\ntask 1 is running\n......\ntask 100 is running\ntask 100 is over\n\n```\n\n从结果中我们可以看到，线程池虽然关闭，但是队列中的任务任然继续执行，**所以用 `shutdown()`方式关闭线程池时需要考虑是否是你想要的效果。**\n\n如果你希望线程池中的等待队列中的任务不继续执行，可以使用`shutdownNow()`方法，将上述代码进行调整，如下：\n\n```\npublic class WaitqueueTest {\n    public static void main(String[] args) {\n        BlockingQueue<Runnable> workQueue = new LinkedBlockingQueue<>();\n        for(int i = 1; i <= 100 ; i++){\n            workQueue.add(new Task(String.valueOf(i)));\n        }\n        ThreadPoolExecutor executor = new ThreadPoolExecutor(1, 1, 10, TimeUnit.SECONDS, workQueue);\n        executor.execute(new Task(\"0\"));\n        // shutdownNow有返回值，返回被抛弃的任务list\n        List<Runnable> dropList = executor.shutdownNow();\n        System.out.println(\"workQueue size = \" + workQueue.size() + \" after shutdown\");\n        System.out.println(\"dropList size = \" + dropList.size());\n    }\n\n    static class Task implements Runnable{\n        String name;\n\n        public Task(String name) {\n            this.name = name;\n        }\n\n        @Override\n        public void run() {\n            for(int i = 1; i <= 10; i++){\n                System.out.println(\"task \" + name + \" is running\");\n            }\n            System.out.println(\"task \" + name + \" is over\");\n        }\n    }\n}\n\n```\n\n输出结果如下：\n\n```\ntask 0 is running\nworkQueue size = 0 after shutdown\ntask 0 is running\ntask 0 is running\ntask 0 is running\ntask 0 is running\ntask 0 is running\ntask 0 is running\ntask 0 is running\ntask 0 is running\ntask 0 is running\ndropList size = 100\ntask 0 is over\n\n```\n\n从上述输出可以看到，只有任务0执行完毕，其他任务都被drop掉了，dropList的size为100。通过dropList我们可以对未处理的任务进行进一步的处理，如log记录，转发等；\n\n**问题3：正在执行的任务是否会立即中断？**\n\n要验证这个问题，需要对线程的 interrupt 方法有一定了解。\n\n* * *\n\n推荐阅读 [——线程中断机制](https://www.jianshu.com/p/e0ff2e420ab6)\n关于 interrupt 方法：\n首先，一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止。\n所以，Thread.stop, Thread.suspend, Thread.resume 都已经被废弃了。\n而 Thread.interrupt 的作用其实也不是中断线程，而是「通知线程应该中断了」，具体到底中断还是继续运行，应该由被通知的线程自己处理。\n具体来说，当对一个线程，调用 interrupt() 时，\n① 如果线程处于被阻塞状态（例如处于sleep, wait, join 等状态），那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常。仅此而已。\n② 如果线程处于正常活动状态，那么会将该线程的中断标志设置为 true，仅此而已。被设置中断标志的线程将继续正常运行，不受影响。\ninterrupt() 并不能真正的中断线程，需要被调用的线程自己进行配合才行。也就是说，一个线程如果有被中断的需求，那么就可以这样做。\n① 在正常运行任务时，经常检查本线程的中断标志位，如果被设置了中断标志就自行停止线程。\n② 在调用阻塞方法时正确处理InterruptedException异常。（例如，catch异常后就结束线程。）\n\n* * *\n\n```\npublic class InteruptTest {\n\n    public static void main(String[] args) throws InterruptedException {\n        ThreadPoolExecutor executor = new ThreadPoolExecutor(1, 1, 10, TimeUnit.SECONDS, new LinkedBlockingQueue<>());\n        executor.execute(new Task(\"0\"));\n        Thread.sleep(1);\n        executor.shutdown();\n        System.out.println(\"executor has been shutdown\");\n    }\n\n    static class Task implements Runnable {\n        String name;\n\n        public Task(String name) {\n            this.name = name;\n        }\n\n        @Override\n        public void run() {\n\n            for (int i = 1; i <= 100 && !Thread.interrupted(); i++) {\n                Thread.yield();\n                System.out.println(\"task \" + name + \" is running, round \" + i);\n            }\n\n        }\n    }\n}\n\n```\n\n输出结果如下：\n\n```\ntask 0 is running, round 1\ntask 0 is running, round 2\ntask 0 is running, round 3\n......\ntask 0 is running, round 28\nexecutor has been shutdown\n......\ntask 0 is running, round 99\ntask 0 is running, round 100\n\n```\n\n为了体现在任务执行中打断，在主线程进行短暂 sleep ， task 中 调用 Thread.yield() ，出让时间片。从结果中可以看到，线程池被关闭后，正则运行的任务没有被 interrupt。说明`shutdown()`方法不会 interrupt 运行中线程。再将其改修改为`shutdownNow()` 后输出结果如下：\n\n```\ntask 0 is running, round 1\ntask 0 is running, round 2\n......\ntask 0 is running, round 56\ntask 0 is running, round 57\ntask 0 is running, round 58\ntask 0 is running, round 59\nexecutor has been shutdown\n\n```\n\n修改为`shutdownNow()` 后，task任务没有执行完，执行到中间的时候就被 interrupt 后没有继续执行了。\n\n##### 总结，想要正确的关闭线程池，并不是简单的调用shutdown方法那么简单，要考虑到应用场景的需求，如何拒绝新来的请求任务？如何处理等待队列中的任务？如何处理正在执行的任务？想好这几个问题，在确定如何优雅而正确的关闭线程池。\n\nPS：线程被 interrupt 后，需要再run方法中单独处理 interrupted 状态，interrupt 更类似一个标志位，不会直接打断线程的执行。"]],[189,189],[8979,8979]]],[1566270150561,["david@DESKTOP-9844NL4",[[-1,115,"![Nulla euismod, vitae aliquet orci eleifend.]($appres/images/night.jpg)"]],[115,187],[115,115]]],[1566270151672,["david@DESKTOP-9844NL4",[[-1,116,"\n"]],[115,115],[114,114]]],[1566270157737,["david@DESKTOP-9844NL4",[[-1,130,"[![96](https://upload.jianshu.io/users/upload_avatars/11183270/d3de5eeb-4ecc-4544-9aeb-2137e2635041?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96)](https://www.jianshu.com/u/bc1552d8e95d) \n\n[徐志毅](https://www.jianshu.com/u/bc1552d8e95d) 关注\n\n 0.7 2018.04.09 11:14* 字数 1865 阅读 10868评论 5喜欢 13"]],[130,424],[130,130]]],[1566270158157,["david@DESKTOP-9844NL4",[[-1,131,"\n"]],[130,130],[129,129]]],[1566270186636,["david@DESKTOP-9844NL4",[[1,128,"（"],[-1,129,""],[-1,551," "],[1,552," "],[-1,559," "],[1,560," "],[-1,1948," "],[1,1949," "],[-1,2015," "],[1,2016," "],[-1,3377," "],[1,3378," "],[-1,3444," "],[1,3445," "],[-1,4504," "],[1,4505," "],[-1,4762," "],[1,4763," "],[-1,6349," "],[1,6350," "],[-1,8127," "],[1,8128," "],[-1,8366," "],[1,8367," "]],[128,128],[129,129]]],[1566270186775,["david@DESKTOP-9844NL4",[[1,129,"）"]],[129,129],[130,130]]],[1566270188017,["david@DESKTOP-9844NL4",[[-1,128,"（）"]],[130,130],[128,128]]],[1566270188657,["david@DESKTOP-9844NL4",[[1,128,"（"]],[128,128],[129,129]]],[1566270189871,["david@DESKTOP-9844NL4",[[-1,128,"（"]],[129,129],[128,128]]],[1566270190652,["david@DESKTOP-9844NL4",[[1,128,"()"]],[128,128],[130,130]]],[1566270194082,["david@DESKTOP-9844NL4",[[1,129,"转载"]],[129,129],[131,131]]],[1566270203242,["david@DESKTOP-9844NL4",[[-1,53,"consectetur"],[1,64,"java"]],[53,64],[57,57]]],[1566270207955,["david@DESKTOP-9844NL4",[[-1,62,"malesuada"],[1,71,"x"]],[62,71],[63,63]]],[1566270208379,["david@DESKTOP-9844NL4",[[1,63,"ian"]],[63,63],[66,66]]],[1566270213294,["david@DESKTOP-9844NL4",[[-1,58,"  - xian"]],[66,66],[58,58]]],[1566270213583,["david@DESKTOP-9844NL4",[[-1,58,"\n"]],[58,58],[57,57]]],[1566270216100,["david@DESKTOP-9844NL4",[[-1,75,"  - fermentum"]],[75,88],[75,75]]],[1566270216454,["david@DESKTOP-9844NL4",[[-1,75,"\n"]],[75,75],[74,74]]],[1566270218207,["david@DESKTOP-9844NL4",[[-1,68,"semper"]],[74,74],[68,68]]],[1566270219283,["david@DESKTOP-9844NL4",[[1,68,"xian"]],[68,68],[72,72]]],[1566270220165,["david@DESKTOP-9844NL4",[[-1,68,"xian"]],[72,72],[68,68]]],[1566270222082,["david@DESKTOP-9844NL4",[[1,68,"线程池"]],[68,68],[71,71]]],[1566270227557,["david@DESKTOP-9844NL4",[[-1,12,"post"],[1,16,"线程池的优雅关闭实践(转载)"]],[12,16],[26,26]]],[1566270238277,["david@DESKTOP-9844NL4",[[-1,12,"线程池的优雅关闭实践(转载)"]],[12,26],[12,12]]],[1566270240115,["david@DESKTOP-9844NL4",[[-1,20,"Lorem ipsum"],[1,31,"线程池的优雅关闭实践(转载)"]],[20,31],[34,34]]],[1566270244198,["david@DESKTOP-9844NL4",[[-1,4,"layout: "]],[4,12],[4,4]]],[1566270244549,["david@DESKTOP-9844NL4",[[-1,4,"\n"]],[4,4],[3,3]]],[1566270250033,["david@DESKTOP-9844NL4",[[-1,40," - "]],[42,42],[39,39]]],[1566270250491,["david@DESKTOP-9844NL4",[[-1,38,"\n"]],[39,39],[38,38]]],[1566270256272,["david@DESKTOP-9844NL4",[[-1,50,"  - "]],[54,54],[50,50]]],[1566270256682,["david@DESKTOP-9844NL4",[[-1,49,"\n"]],[50,50],[49,49]]],[1566270268371,["david@DESKTOP-9844NL4",[[1,78,"\n"]],[77,77],[78,78]]],[1566270268571,["david@DESKTOP-9844NL4",[[1,79,"\n"]],[78,78],[79,79]]],[1566270275816,["david@DESKTOP-9844NL4",[[1,78,"| item      | Model    |  Price | Qty |\n| --------- | -------- | -----: | --: |\n| Laptop    | 13\" Pro  | $1,300 |   1 |\n| Phone     | Plus     |   $800 |   2 |\n| Watch     | Series 3 |   $400 |   3 |\n| Headphone | HD650    |   $350 |   2 |"]],[78,78],[319,319]]],[1566270280555,["david@DESKTOP-9844NL4",[[-1,80,"item"],[1,84,"方法"]],[80,80],[82,82]]],[1566270284842,["david@DESKTOP-9844NL4",[[-1,78,"| 方法      | Model    |  Price | Qty |\n| --------- | -------- | -----: | --: |\n| Laptop    | 13\" Pro  | $1,300 |   1 |\n| Phone     | Plus     |   $800 |   2 |\n| Watch     | Series 3 |   $400 |   3 |\n| Headphone | HD650    |   $350 |   2 |"]],[78,315],[78,78]]],[1566270287698,["david@DESKTOP-9844NL4",[[1,78,"总结："]],[78,78],[81,81]]],[1566270288423,["david@DESKTOP-9844NL4",[[-1,78,"总结："]],[81,81],[78,78]]],[1566270291346,["david@DESKTOP-9844NL4",[[1,78,"## 总结"]],[78,78],[83,83]]],[1566270291852,["david@DESKTOP-9844NL4",[[1,85,"\n"]],[83,83],[84,84]]],[1566270292573,["david@DESKTOP-9844NL4",[[-1,85,"\n"]],[84,84],[83,83]]],[1566270293573,["david@DESKTOP-9844NL4",[[-1,78,"## 总结"]],[83,83],[78,78]]],[1566270296423,["david@DESKTOP-9844NL4",[[1,78,"### "]],[78,78],[82,82]]],[1566270299136,["david@DESKTOP-9844NL4",[[-1,59,"# 线程池的优雅关闭实践(转载)"]],[59,75],[59,59]]],[1566270299434,["david@DESKTOP-9844NL4",[[-1,61,"\n"]],[59,59],[58,58]]],[1566270299858,["david@DESKTOP-9844NL4",[[-1,60,"\n"]],[58,58],[57,57]]],[1566270301278,["david@DESKTOP-9844NL4",[[-1,59,"\n"]],[59,59],[58,58]]],[1566270301576,["david@DESKTOP-9844NL4",[[-1,58,"\n"]],[58,58],[57,57]]],[1566270308145,["david@DESKTOP-9844NL4",[[1,62,"shutdown()Yu"]],[62,62],[74,74]]],[1566270308725,["david@DESKTOP-9844NL4",[[-1,72,"Yu"]],[74,74],[72,72]]],[1566270314314,["david@DESKTOP-9844NL4",[[1,72,"与shutdownNow()"]],[72,72],[86,86]]],[1566270315070,["david@DESKTOP-9844NL4",[[1,88,"\n"]],[86,86],[87,87]]],[1566270315268,["david@DESKTOP-9844NL4",[[1,89,"\n"]],[87,87],[88,88]]],[1566270315479,["david@DESKTOP-9844NL4",[[1,90,"\n"]],[88,88],[89,89]]],[1566270319092,["david@DESKTOP-9844NL4",[[1,88,"* shutD"]],[88,88],[95,95]]],[1566270319627,["david@DESKTOP-9844NL4",[[-1,94,"D"]],[95,95],[94,94]]],[1566270368389,["david@DESKTOP-9844NL4",[[1,94,"down() d"]],[94,94],[102,102]]],[1566270368794,["david@DESKTOP-9844NL4",[[-1,101,"d"]],[102,102],[101,101]]],[1566270371369,["david@DESKTOP-9844NL4",[[1,101,"调用或"]],[101,101],[104,104]]],[1566270372106,["david@DESKTOP-9844NL4",[[-1,100," 调用或"]],[104,104],[100,100]]],[1566270374204,["david@DESKTOP-9844NL4",[[1,100,"特点："]],[100,100],[103,103]]],[1566270374987,["david@DESKTOP-9844NL4",[[-1,102,"："]],[103,103],[102,102]]],[1566270377617,["david@DESKTOP-9844NL4",[[1,102," 1"]],[102,102],[104,104]]],[1566270378217,["david@DESKTOP-9844NL4",[[-1,103,"1"]],[104,104],[103,103]]],[1566270379740,["david@DESKTOP-9844NL4",[[1,103,"1."]],[103,103],[105,105]]],[1566270507712,["david@DESKTOP-9844NL4",[[-1,99,")特点 1."]],[105,105],[99,99]]],[1566270509624,["david@DESKTOP-9844NL4",[[1,99,"）"]],[99,99],[100,100]]],[1566270510248,["david@DESKTOP-9844NL4",[[-1,99,"）"]],[100,100],[99,99]]],[1566270510770,["david@DESKTOP-9844NL4",[[1,99,"）"]],[99,99],[100,100]]],[1566270511429,["david@DESKTOP-9844NL4",[[-1,99,"）"]],[100,100],[99,99]]],[1566270511983,["david@DESKTOP-9844NL4",[[1,99,"）"]],[99,99],[100,100]]],[1566270513117,["david@DESKTOP-9844NL4",[[-1,98,"(）"]],[100,100],[98,98]]],[1566270514794,["david@DESKTOP-9844NL4",[[1,98,"() d"]],[98,98],[102,102]]],[1566270515206,["david@DESKTOP-9844NL4",[[-1,101,"d"]],[102,102],[101,101]]],[1566270515816,["david@DESKTOP-9844NL4",[[1,101,"diao"]],[101,101],[105,105]]],[1566270517172,["david@DESKTOP-9844NL4",[[-1,100," diao"]],[105,105],[100,100]]],[1566270517594,["david@DESKTOP-9844NL4",[[1,100,"t"]],[100,100],[101,101]]],[1566270518104,["david@DESKTOP-9844NL4",[[-1,100,"t"]],[101,101],[100,100]]],[1566270518709,["david@DESKTOP-9844NL4",[[1,100,"ti"]],[100,100],[102,102]]],[1566270519286,["david@DESKTOP-9844NL4",[[-1,100,"ti"]],[102,102],[100,100]]],[1566270521145,["david@DESKTOP-9844NL4",[[1,100,"特点 "]],[100,100],[103,103]]],[1566270522502,["david@DESKTOP-9844NL4",[[-1,102," "]],[103,103],[102,102]]],[1566270524479,["david@DESKTOP-9844NL4",[[1,102,":"]],[102,102],[103,103]]],[1566270525949,["david@DESKTOP-9844NL4",[[1,104,"* \n"]],[103,103],[106,106]]],[1566270526315,["david@DESKTOP-9844NL4",[[1,106,"1"]],[106,106],[107,107]]],[1566270527348,["david@DESKTOP-9844NL4",[[-1,105," 1"]],[107,107],[105,105]]],[1566270528847,["david@DESKTOP-9844NL4",[[-1,88,"*"]],[89,89],[88,88]]],[1566270530487,["david@DESKTOP-9844NL4",[[-1,103,"*"]],[104,104],[103,103]]],[1566270530992,["david@DESKTOP-9844NL4",[[-1,105,"\n"]],[103,103],[102,102]]],[1566270531630,["david@DESKTOP-9844NL4",[[1,103," \n"]],[102,102],[104,104]]],[1566270534331,["david@DESKTOP-9844NL4",[[1,104,"* 1. s"]],[104,104],[110,110]]],[1566270534771,["david@DESKTOP-9844NL4",[[-1,109,"s"]],[110,110],[109,109]]],[1566270537373,["david@DESKTOP-9844NL4",[[1,109,"调用会"]],[109,109],[112,112]]],[1566270538125,["david@DESKTOP-9844NL4",[[-1,111,"会"]],[112,112],[111,111]]],[1566270544206,["david@DESKTOP-9844NL4",[[1,111,"后线程队列中"]],[111,111],[117,117]]],[1566270575515,["david@DESKTOP-9844NL4",[[1,88,"\n"]],[87,87],[88,88]]],[1566270582370,["david@DESKTOP-9844NL4",[[1,86,"区别"]],[86,86],[88,88]]],[1566270583729,["david@DESKTOP-9844NL4",[[1,58,"\n"]],[57,57],[58,58]]],[1566270583950,["david@DESKTOP-9844NL4",[[1,59,"\n"]],[58,58],[59,59]]],[1566270584160,["david@DESKTOP-9844NL4",[[1,60,"\n"]],[59,59],[60,60]]],[1566270594810,["david@DESKTOP-9844NL4",[[1,58,"### 1.为什么要关闭线程池？"]],[58,58],[74,74]]],[1566270595444,["david@DESKTOP-9844NL4",[[-1,73,"？"]],[74,74],[73,73]]],[1566270605938,["david@DESKTOP-9844NL4",[[1,73,"?线程不能自动结束吗？"]],[73,73],[84,84]]],[1566270613608,["david@DESKTOP-9844NL4",[[1,91,"2. "]],[91,91],[94,94]]],[1566270615824,["david@DESKTOP-9844NL4",[[1,64," "]],[64,64],[65,65]]],[1566270624587,["david@DESKTOP-9844NL4",[[-1,135,"特点:"]],[135,138],[135,135]]],[1566270626894,["david@DESKTOP-9844NL4",[[-1,124," "]],[125,125],[124,124]]],[1566270627302,["david@DESKTOP-9844NL4",[[-1,123,"\n"]],[124,124],[123,123]]],[1566270627806,["david@DESKTOP-9844NL4",[[-1,122,"\n"]],[123,123],[122,122]]],[1566270651272,["david@DESKTOP-9844NL4",[[-1,75,"线程不能自动结束吗？"]],[76,85],[75,75]]],[1566270655856,["david@DESKTOP-9844NL4",[[-1,60,"# 1. "]],[65,65],[60,60]]],[1566270656476,["david@DESKTOP-9844NL4",[[1,60," "]],[60,60],[61,61]]],[1566270658794,["david@DESKTOP-9844NL4",[[-1,76,"#"]],[77,77],[76,76]]],[1566270662169,["david@DESKTOP-9844NL4",[[-1,77,"2. "]],[79,79],[77,77]]],[1566270673700,["david@DESKTOP-9844NL4",[[1,129,"的线程会即系"]],[129,129],[135,135]]],[1566270674486,["david@DESKTOP-9844NL4",[[-1,133,"即系"]],[135,135],[133,133]]],[1566270676582,["david@DESKTOP-9844NL4",[[1,133,"继续执行"]],[133,133],[137,137]]],[1566270754515,["david@DESKTOP-9844NL4",[[-1,74,"## shutdown()与shutdownNow()区别\nshutdown()\n * 1. 调用后线程队列中的线程会继续执行"]],[74,137],[74,74]]],[1566270755415,["david@DESKTOP-9844NL4",[[-1,76,"\n"]],[74,74],[73,73]]],[1566270755709,["david@DESKTOP-9844NL4",[[-1,75,"\n"]],[73,73],[72,72]]],[1566270756026,["david@DESKTOP-9844NL4",[[-1,74,"\n"]],[72,72],[71,71]]],[1566270758769,["david@DESKTOP-9844NL4",[[1,60,"#"]],[60,60],[61,61]]],[1566270762211,["david@DESKTOP-9844NL4",[[-1,74,"\n"]],[74,74],[73,73]]],[1566270767090,["david@DESKTOP-9844NL4",[[1,62,"一。"]],[62,62],[64,64]]],[1566270767671,["david@DESKTOP-9844NL4",[[-1,63,"。"]],[64,64],[63,63]]],[1566270768019,["david@DESKTOP-9844NL4",[[1,63,"。"]],[63,63],[64,64]]],[1566270768571,["david@DESKTOP-9844NL4",[[-1,63,"。"]],[64,64],[63,63]]],[1566270769283,["david@DESKTOP-9844NL4",[[1,63,". "]],[63,63],[65,65]]],[1566270832452,["david@DESKTOP-9844NL4",[[1,77,"\n"]],[75,75],[76,76]]],[1566270834562,["david@DESKTOP-9844NL4",[[1,76,"1. bu"]],[76,76],[81,81]]],[1566270835266,["david@DESKTOP-9844NL4",[[-1,79,"bu"]],[81,81],[79,79]]],[1566270835618,["david@DESKTOP-9844NL4",[[1,79,"g"]],[79,79],[80,80]]],[1566270835929,["david@DESKTOP-9844NL4",[[-1,79,"g"]],[80,80],[79,79]]],[1566270841080,["david@DESKTOP-9844NL4",[[1,79,"不关闭线程池结束线程执行，避免内存溢出"]],[79,79],[98,98]]],[1566270845045,["david@DESKTOP-9844NL4",[[-1,85,"结束线程执行，"]],[85,92],[85,85]]],[1566270846283,["david@DESKTOP-9844NL4",[[1,85," "]],[85,85],[86,86]]],[1566270847017,["david@DESKTOP-9844NL4",[[-1,85," "]],[86,86],[85,85]]],[1566270850319,["david@DESKTOP-9844NL4",[[1,85,"容易造成"]],[85,85],[89,89]]],[1566270851912,["david@DESKTOP-9844NL4",[[-1,89,"避免"]],[91,91],[89,89]]],[1566270854877,["david@DESKTOP-9844NL4",[[1,93,"OOM"]],[93,93],[96,96]]],[1566270856192,["david@DESKTOP-9844NL4",[[1,97,"2. \n"]],[96,96],[100,100]]],[1566270857299,["david@DESKTOP-9844NL4",[[1,100,"S"]],[100,100],[101,101]]],[1566270857827,["david@DESKTOP-9844NL4",[[-1,100,"S"]],[101,101],[100,100]]],[1566270858831,["david@DESKTOP-9844NL4",[[1,100,"为"]],[100,100],[101,101]]],[1566270859153,["david@DESKTOP-9844NL4",[[-1,100,"为"]],[101,101],[100,100]]],[1566270869359,["david@DESKTOP-9844NL4",[[1,100,"不关闭线程池,线程会在后台"]],[100,100],[113,113]]],[1566270874129,["david@DESKTOP-9844NL4",[[1,113,"继续执行（"]],[113,113],[118,118]]],[1566270874548,["david@DESKTOP-9844NL4",[[-1,117,"（"]],[118,118],[117,117]]],[1566270884816,["david@DESKTOP-9844NL4",[[1,119,"\n"]],[118,118],[119,119]]],[1566270887953,["david@DESKTOP-9844NL4",[[-1,61," 一. "]],[65,65],[61,61]]],[1566270888556,["david@DESKTOP-9844NL4",[[1,61," "]],[61,61],[62,62]]],[1566270925743,["david@DESKTOP-9844NL4",[[1,115,"3. \n"]],[114,114],[118,118]]],[1566270925921,["david@DESKTOP-9844NL4",[[-1,115,"3. "]],[118,118],[116,116]]],[1566270929101,["david@DESKTOP-9844NL4",[[1,116,"### 系统"]],[116,116],[122,122]]],[1566270930590,["david@DESKTOP-9844NL4",[[-1,120,"系统"]],[122,122],[120,120]]],[1566270945452,["david@DESKTOP-9844NL4",[[1,120,"线程池自动关闭的两个条件?"]],[120,120],[133,133]]],[1566270946043,["david@DESKTOP-9844NL4",[[1,135,"\n"]],[133,133],[134,134]]],[1566270953112,["david@DESKTOP-9844NL4",[[1,134,"1.1、线程池的引用不可达；2、线程池中没有线程"]],[134,134],[158,158]]],[1566270955327,["david@DESKTOP-9844NL4",[[-1,136,"1、"]],[138,138],[136,136]]],[1566270956356,["david@DESKTOP-9844NL4",[[1,136," "]],[136,136],[137,137]]],[1566270957626,["david@DESKTOP-9844NL4",[[1,147,"\n"]],[147,147],[148,148]]],[1566270958962,["david@DESKTOP-9844NL4",[[-1,149,"、"]],[150,150],[149,149]]],[1566270960378,["david@DESKTOP-9844NL4",[[1,149,". "]],[149,149],[151,151]]],[1566270993451,["david@DESKTOP-9844NL4",[[1,93,"(ru"]],[93,93],[96,96]]],[1566270993941,["david@DESKTOP-9844NL4",[[-1,94,"ru"]],[96,96],[94,94]]],[1566270994367,["david@DESKTOP-9844NL4",[[1,94,"ru"]],[94,94],[96,96]]],[1566270995025,["david@DESKTOP-9844NL4",[[-1,94,"ru"]],[96,96],[94,94]]],[1566270997553,["david@DESKTOP-9844NL4",[[1,94,"如FixedThreadPool的核心线程没有超时策略，所以并不会自动关闭）"]],[94,94],[132,132]]],[1566270999269,["david@DESKTOP-9844NL4",[[1,136,"\n2. "]],[132,132],[136,136]]],[1566271000475,["david@DESKTOP-9844NL4",[[-1,133,"2. "]],[136,136],[133,133]]],[1566271002006,["david@DESKTOP-9844NL4",[[-1,133,"\n"]],[133,133],[132,132]]],[1566271009702,["david@DESKTOP-9844NL4",[[-1,313,"\n"]],[313,313],[312,312]]],[1566271012735,["david@DESKTOP-9844NL4",[[1,313,"\n"]],[312,312],[313,313]]],[1566271016803,["david@DESKTOP-9844NL4",[[1,202," "]],[202,202],[203,203]]],[1566271017930,["david@DESKTOP-9844NL4",[[-1,202," "]],[203,203],[202,202]]],[1566271082271,["david@DESKTOP-9844NL4",[[-1,58,"### 为什么要关闭线程池?\n1. 不关闭线程池容易造成内存溢出OOM(如FixedThreadPool的核心线程没有超时策略，所以并不会自动关闭）\n2. 不关闭线程池,线程会在后台继续执行\n\n### 线程池自动关闭的两个条件?\n1. 线程池的引用不可达；\n2. 线程池中没有线程"]],[58,198],[58,58]]],[1566271083949,["david@DESKTOP-9844NL4",[[-1,59,"\n"]],[60,60],[59,59]]],[1566271084282,["david@DESKTOP-9844NL4",[[-1,58,"\n"]],[59,59],[58,58]]],[1566271230849,["david@DESKTOP-9844NL4",[[1,49,"\n"]],[49,49],[50,50]]],[1566271232126,["david@DESKTOP-9844NL4",[[1,50,"- "]],[50,50],[52,52]]],[1566271253438,["david@DESKTOP-9844NL4",[[1,50,"  "]],[50,50],[52,52]]]],null,"david@DESKTOP-9844NL4"],["af201900-102f-41f5-a968-cf9d9ecbbb23",1566271414130,"---\ntitle: 线程池的优雅关闭实践(转载)\ncategories:  java\ntags:\n  - 线程池\n---\n\n**平时开发中，大家更多的关注的是线程池的创建、任务的提交和执行。往往会忽略线程池的关闭，甚至忘记调用`shutdown()`方法，导致内存溢出。大多知道需要调用shutdown()关闭线程池，也少研究其真正的关闭过程。**\n\n首先看源码中的一句注释：\n\n> A pool that is no longer referenced in a program and has no remaining threads will be shutdown automatically.\n> 如果程序中不再持有线程池的引用，并且线程池中没有线程时，线程池将会自动关闭。\n\n**线程池自动关闭的两个条件：1、线程池的引用不可达；2、线程池中没有线程；**\n\n这里对于条件2解释一下，线程池中没有线程是指线程池中的所有线程都已运行完自动消亡。然而我们常用的FixedThreadPool的核心线程没有超时策略，所以并不会自动关闭。\n\n展示两种不同线程池 **不关闭** 的情况：\n\n1、FixedThreadPool 示例\n\n```\npublic static void main(String[] args) {\n    while(true) {\n        ExecutorService executorService = Executors.newFixedThreadPool(8);\n        executorService.execute(() -> System.out.println(\"running\"));\n        executorService = null;\n    }\n}\n\n```\n\n输出结果：\n\n```\nrunning\n......\nrunning\nException in thread \"main\" java.lang.OutOfMemoryError: unable to create new native thread\n    at java.lang.Thread.start0(Native Method)\n    at java.lang.Thread.start(Thread.java:714)\n    at java.util.concurrent.ThreadPoolExecutor.addWorker(ThreadPoolExecutor.java:950)\n    at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1357)\n    at test.PoolTest.main(PoolTest.java:29)\n\n```\n\n因为FixedThreadPool的核心线程不会自动超时关闭，使用时必须在适当的时候调用shutdown()方法。\n\n2、 CachedThreadPool 示例\n\n```\npublic static void main(String[] args) {\n    while(true) {\n        // 默认keepAliveTime为 60s\n        ExecutorService executorService = Executors.newCachedThreadPool(); \n        ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) executorService;\n        // 为了更好的模拟，动态修改为1纳秒\n        threadPoolExecutor.setKeepAliveTime(1, TimeUnit.NANOSECONDS);\n        threadPoolExecutor.execute(() -> System.out.println(\"running\"));\n    }\n}\n\n```\n\n输出结果：\n\n```\nrunning\nrunning\nrunning\nrunning\nrunning\n......\n\n```\n\nCachedThreadPool 的线程 keepAliveTime 默认为 60s ，核心线程数量为 0 ，所以不会有核心线程存活阻止线程池自动关闭。 详见 [线程池之ThreadPoolExecutor构造](https://www.jianshu.com/p/f030aa5d7a28) ，为了更快的模拟，构造后将 keepAliveTime 修改为1纳秒，相当于线程执行完马上会消亡，所以线程池可以被回收。实际开发中，如果CachedThreadPool 确实忘记关闭，在一定时间后是可以被回收的。但仍然建议显示关闭。\n\n**然而，线程池关闭的意义不仅仅在于结束线程执行，避免内存溢出，因为大多使用的场景并非上述示例那样 朝生夕死。线程池一般是持续工作的全局场景，如数据库连接池。**\n\n本文更多要讨论的是当线程池调用shutdown方法后，会经历些什么？思考一下几个问题：\n\n> 1.  是否可以继续接受新任务？继续提交新任务会怎样？\n> 2.  等待队列里的任务是否还会执行？\n> 3.  正在执行的任务是否会立即中断？\n\n**问题1：是否可以继续接受新任务？继续提交新任务会怎样？**\n\n```\npublic static void main(String[] args) {\n    ThreadPoolExecutor executor = new ThreadPoolExecutor(4, 4, 10, TimeUnit.SECONDS, new LinkedBlockingQueue<>());\n    executor.execute(() -> System.out.println(\"before shutdown\"));\n    executor.shutdown();\n    executor.execute(() -> System.out.println(\"after shutdown\"));\n}\n\n```\n\n输出结果如下：\n\n```\nbefore shutdown\nException in thread \"main\" java.util.concurrent.RejectedExecutionException: Task PoolTest$$Lambda$2/142257191@3e3abc88 rejected from java.util.concurrent.ThreadPoolExecutor@6ce253f1[Terminated, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 1]\n    at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2047)\n    at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:823)\n    at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1369)\n    at PoolTest.main(PoolTest.java:12)\n\n```\n\n当线程池关闭后，继续提交新任务会抛出异常。这句话也不够准确，不一定是抛出异常，而是执行拒绝策略，默认的拒绝策略是抛出异常。可参见 [线程池之ThreadPoolExecutor构造](https://www.jianshu.com/p/f030aa5d7a28) 里面自定义线程池的例子，自定义了忽略策略，但被拒绝时并没有抛出异常。\n\n**问题2：等待队列里的任务是否还会执行？**\n\n```\npublic class WaitqueueTest {\n    public static void main(String[] args) {\n        BlockingQueue<Runnable> workQueue = new LinkedBlockingQueue<>();\n        for(int i = 1; i <= 100 ; i++){\n            workQueue.add(new Task(String.valueOf(i)));\n        }\n        ThreadPoolExecutor executor = new ThreadPoolExecutor(1, 1, 10, TimeUnit.SECONDS, workQueue);\n        executor.execute(new Task(\"0\"));\n        executor.shutdown();\n        System.out.println(\"workQueue size = \" + workQueue.size() + \" after shutdown\");\n    }\n\n    static class Task implements Runnable{\n        String name;\n\n        public Task(String name) {\n            this.name = name;\n        }\n\n        @Override\n        public void run() {\n            for(int i = 1; i <= 10; i++){\n                System.out.println(\"task \" + name + \" is running\");\n            }\n            System.out.println(\"task \" + name + \" is over\");\n        }\n    }\n}\n\n```\n\n这个demo解释一下，我们用LinkedBlockingQueue构造了一个线程池，在线程池启动前，我们先将工作队列填充100个任务，然后执行`task 0` 后立即`shutdown()`线程池，来验证线程池关闭队列的任务运行状态。\n输出结果如下：\n\n```\n......\ntask 0 is running\ntask 0 is over\nworkQueue size = 100 after shutdown //表示线程池关闭后，队列任然有100个任务\ntask 1 is running\n......\ntask 100 is running\ntask 100 is over\n\n```\n\n从结果中我们可以看到，线程池虽然关闭，但是队列中的任务任然继续执行，**所以用 `shutdown()`方式关闭线程池时需要考虑是否是你想要的效果。**\n\n如果你希望线程池中的等待队列中的任务不继续执行，可以使用`shutdownNow()`方法，将上述代码进行调整，如下：\n\n```\npublic class WaitqueueTest {\n    public static void main(String[] args) {\n        BlockingQueue<Runnable> workQueue = new LinkedBlockingQueue<>();\n        for(int i = 1; i <= 100 ; i++){\n            workQueue.add(new Task(String.valueOf(i)));\n        }\n        ThreadPoolExecutor executor = new ThreadPoolExecutor(1, 1, 10, TimeUnit.SECONDS, workQueue);\n        executor.execute(new Task(\"0\"));\n        // shutdownNow有返回值，返回被抛弃的任务list\n        List<Runnable> dropList = executor.shutdownNow();\n        System.out.println(\"workQueue size = \" + workQueue.size() + \" after shutdown\");\n        System.out.println(\"dropList size = \" + dropList.size());\n    }\n\n    static class Task implements Runnable{\n        String name;\n\n        public Task(String name) {\n            this.name = name;\n        }\n\n        @Override\n        public void run() {\n            for(int i = 1; i <= 10; i++){\n                System.out.println(\"task \" + name + \" is running\");\n            }\n            System.out.println(\"task \" + name + \" is over\");\n        }\n    }\n}\n\n```\n\n输出结果如下：\n\n```\ntask 0 is running\nworkQueue size = 0 after shutdown\ntask 0 is running\ntask 0 is running\ntask 0 is running\ntask 0 is running\ntask 0 is running\ntask 0 is running\ntask 0 is running\ntask 0 is running\ntask 0 is running\ndropList size = 100\ntask 0 is over\n\n```\n\n从上述输出可以看到，只有任务0执行完毕，其他任务都被drop掉了，dropList的size为100。通过dropList我们可以对未处理的任务进行进一步的处理，如log记录，转发等；\n\n**问题3：正在执行的任务是否会立即中断？**\n\n要验证这个问题，需要对线程的 interrupt 方法有一定了解。\n\n* * *\n\n推荐阅读 [——线程中断机制](https://www.jianshu.com/p/e0ff2e420ab6)\n关于 interrupt 方法：\n首先，一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止。\n所以，Thread.stop, Thread.suspend, Thread.resume 都已经被废弃了。\n而 Thread.interrupt 的作用其实也不是中断线程，而是「通知线程应该中断了」，具体到底中断还是继续运行，应该由被通知的线程自己处理。\n具体来说，当对一个线程，调用 interrupt() 时，\n① 如果线程处于被阻塞状态（例如处于sleep, wait, join 等状态），那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常。仅此而已。\n② 如果线程处于正常活动状态，那么会将该线程的中断标志设置为 true，仅此而已。被设置中断标志的线程将继续正常运行，不受影响。\ninterrupt() 并不能真正的中断线程，需要被调用的线程自己进行配合才行。也就是说，一个线程如果有被中断的需求，那么就可以这样做。\n① 在正常运行任务时，经常检查本线程的中断标志位，如果被设置了中断标志就自行停止线程。\n② 在调用阻塞方法时正确处理InterruptedException异常。（例如，catch异常后就结束线程。）\n\n* * *\n\n```\npublic class InteruptTest {\n\n    public static void main(String[] args) throws InterruptedException {\n        ThreadPoolExecutor executor = new ThreadPoolExecutor(1, 1, 10, TimeUnit.SECONDS, new LinkedBlockingQueue<>());\n        executor.execute(new Task(\"0\"));\n        Thread.sleep(1);\n        executor.shutdown();\n        System.out.println(\"executor has been shutdown\");\n    }\n\n    static class Task implements Runnable {\n        String name;\n\n        public Task(String name) {\n            this.name = name;\n        }\n\n        @Override\n        public void run() {\n\n            for (int i = 1; i <= 100 && !Thread.interrupted(); i++) {\n                Thread.yield();\n                System.out.println(\"task \" + name + \" is running, round \" + i);\n            }\n\n        }\n    }\n}\n\n```\n\n输出结果如下：\n\n```\ntask 0 is running, round 1\ntask 0 is running, round 2\ntask 0 is running, round 3\n......\ntask 0 is running, round 28\nexecutor has been shutdown\n......\ntask 0 is running, round 99\ntask 0 is running, round 100\n\n```\n\n为了体现在任务执行中打断，在主线程进行短暂 sleep ， task 中 调用 Thread.yield() ，出让时间片。从结果中可以看到，线程池被关闭后，正则运行的任务没有被 interrupt。说明`shutdown()`方法不会 interrupt 运行中线程。再将其改修改为`shutdownNow()` 后输出结果如下：\n\n```\ntask 0 is running, round 1\ntask 0 is running, round 2\n......\ntask 0 is running, round 56\ntask 0 is running, round 57\ntask 0 is running, round 58\ntask 0 is running, round 59\nexecutor has been shutdown\n\n```\n\n修改为`shutdownNow()` 后，task任务没有执行完，执行到中间的时候就被 interrupt 后没有继续执行了。\n\n##### 总结，想要正确的关闭线程池，并不是简单的调用shutdown方法那么简单，要考虑到应用场景的需求，如何拒绝新来的请求任务？如何处理等待队列中的任务？如何处理正在执行的任务？想好这几个问题，在确定如何优雅而正确的关闭线程池。\n\nPS：线程被 interrupt 后，需要再run方法中单独处理 interrupted 状态，interrupt 更类似一个标志位，不会直接打断线程的执行。\n",[[1566271358005,["david@DESKTOP-9844NL4",[[-1,50,"  "]],[52,52],[50,50]]]],null,"david@DESKTOP-9844NL4"],["b4206501-985f-4e9b-b43e-c0f16e9123c6",1566271743621,"---\ntitle: 线程池的优雅关闭实践(转载)\ncategories:  java\ntags:\n- 线程池\n---\n\n**平时开发中，大家更多的关注的是线程池的创建、任务的提交和执行。往往会忽略线程池的关闭，甚至忘记调用`shutdown()`方法，导致内存溢出。大多知道需要调用shutdown()关闭线程池，也少研究其真正的关闭过程。**\n\n首先看源码中的一句注释：\n\n> A pool that is no longer referenced in a program and has no remaining threads will be shutdown automatically.\n> 如果程序中不再持有线程池的引用，并且线程池中没有线程时，线程池将会自动关闭。\n\n**线程池自动关闭的两个条件：1、线程池的引用不可达；2、线程池中没有线程；**\n\n这里对于条件2解释一下，线程池中没有线程是指线程池中的所有线程都已运行完自动消亡。然而我们常用的FixedThreadPool的核心线程没有超时策略，所以并不会自动关闭。\n\n展示两种不同线程池 **不关闭** 的情况：\n\n1、FixedThreadPool 示例\n\n```\npublic static void main(String[] args) {\n    while(true) {\n        ExecutorService executorService = Executors.newFixedThreadPool(8);\n        executorService.execute(() -> System.out.println(\"running\"));\n        executorService = null;\n    }\n}\n\n```\n\n输出结果：\n\n```\nrunning\n......\nrunning\nException in thread \"main\" java.lang.OutOfMemoryError: unable to create new native thread\n    at java.lang.Thread.start0(Native Method)\n    at java.lang.Thread.start(Thread.java:714)\n    at java.util.concurrent.ThreadPoolExecutor.addWorker(ThreadPoolExecutor.java:950)\n    at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1357)\n    at test.PoolTest.main(PoolTest.java:29)\n\n```\n\n因为FixedThreadPool的核心线程不会自动超时关闭，使用时必须在适当的时候调用shutdown()方法。\n\n2、 CachedThreadPool 示例\n\n```\npublic static void main(String[] args) {\n    while(true) {\n        // 默认keepAliveTime为 60s\n        ExecutorService executorService = Executors.newCachedThreadPool(); \n        ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) executorService;\n        // 为了更好的模拟，动态修改为1纳秒\n        threadPoolExecutor.setKeepAliveTime(1, TimeUnit.NANOSECONDS);\n        threadPoolExecutor.execute(() -> System.out.println(\"running\"));\n    }\n}\n\n```\n\n输出结果：\n\n```\nrunning\nrunning\nrunning\nrunning\nrunning\n......\n\n```\n\nCachedThreadPool 的线程 keepAliveTime 默认为 60s ，核心线程数量为 0 ，所以不会有核心线程存活阻止线程池自动关闭。 详见 [线程池之ThreadPoolExecutor构造](https://www.jianshu.com/p/f030aa5d7a28) ，为了更快的模拟，构造后将 keepAliveTime 修改为1纳秒，相当于线程执行完马上会消亡，所以线程池可以被回收。实际开发中，如果CachedThreadPool 确实忘记关闭，在一定时间后是可以被回收的。但仍然建议显示关闭。\n\n**然而，线程池关闭的意义不仅仅在于结束线程执行，避免内存溢出，因为大多使用的场景并非上述示例那样 朝生夕死。线程池一般是持续工作的全局场景，如数据库连接池。**\n\n本文更多要讨论的是当线程池调用shutdown方法后，会经历些什么？思考一下几个问题：\n\n> 1.  是否可以继续接受新任务？继续提交新任务会怎样？\n> 2.  等待队列里的任务是否还会执行？\n> 3.  正在执行的任务是否会立即中断？\n\n**问题1：是否可以继续接受新任务？继续提交新任务会怎样？**\n\n```\npublic static void main(String[] args) {\n    ThreadPoolExecutor executor = new ThreadPoolExecutor(4, 4, 10, TimeUnit.SECONDS, new LinkedBlockingQueue<>());\n    executor.execute(() -> System.out.println(\"before shutdown\"));\n    executor.shutdown();\n    executor.execute(() -> System.out.println(\"after shutdown\"));\n}\n\n```\n\n输出结果如下：\n\n```\nbefore shutdown\nException in thread \"main\" java.util.concurrent.RejectedExecutionException: Task PoolTest$$Lambda$2/142257191@3e3abc88 rejected from java.util.concurrent.ThreadPoolExecutor@6ce253f1[Terminated, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 1]\n    at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2047)\n    at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:823)\n    at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1369)\n    at PoolTest.main(PoolTest.java:12)\n\n```\n\n当线程池关闭后，继续提交新任务会抛出异常。这句话也不够准确，不一定是抛出异常，而是执行拒绝策略，默认的拒绝策略是抛出异常。可参见 [线程池之ThreadPoolExecutor构造](https://www.jianshu.com/p/f030aa5d7a28) 里面自定义线程池的例子，自定义了忽略策略，但被拒绝时并没有抛出异常。\n\n**问题2：等待队列里的任务是否还会执行？**\n\n```\npublic class WaitqueueTest {\n    public static void main(String[] args) {\n        BlockingQueue<Runnable> workQueue = new LinkedBlockingQueue<>();\n        for(int i = 1; i <= 100 ; i++){\n            workQueue.add(new Task(String.valueOf(i)));\n        }\n        ThreadPoolExecutor executor = new ThreadPoolExecutor(1, 1, 10, TimeUnit.SECONDS, workQueue);\n        executor.execute(new Task(\"0\"));\n        executor.shutdown();\n        System.out.println(\"workQueue size = \" + workQueue.size() + \" after shutdown\");\n    }\n\n    static class Task implements Runnable{\n        String name;\n\n        public Task(String name) {\n            this.name = name;\n        }\n\n        @Override\n        public void run() {\n            for(int i = 1; i <= 10; i++){\n                System.out.println(\"task \" + name + \" is running\");\n            }\n            System.out.println(\"task \" + name + \" is over\");\n        }\n    }\n}\n\n```\n\n这个demo解释一下，我们用LinkedBlockingQueue构造了一个线程池，在线程池启动前，我们先将工作队列填充100个任务，然后执行`task 0` 后立即`shutdown()`线程池，来验证线程池关闭队列的任务运行状态。\n输出结果如下：\n\n```\n......\ntask 0 is running\ntask 0 is over\nworkQueue size = 100 after shutdown //表示线程池关闭后，队列任然有100个任务\ntask 1 is running\n......\ntask 100 is running\ntask 100 is over\n\n```\n\n从结果中我们可以看到，线程池虽然关闭，但是队列中的任务任然继续执行，**所以用 `shutdown()`方式关闭线程池时需要考虑是否是你想要的效果。**\n\n如果你希望线程池中的等待队列中的任务不继续执行，可以使用`shutdownNow()`方法，将上述代码进行调整，如下：\n\n```\npublic class WaitqueueTest {\n    public static void main(String[] args) {\n        BlockingQueue<Runnable> workQueue = new LinkedBlockingQueue<>();\n        for(int i = 1; i <= 100 ; i++){\n            workQueue.add(new Task(String.valueOf(i)));\n        }\n        ThreadPoolExecutor executor = new ThreadPoolExecutor(1, 1, 10, TimeUnit.SECONDS, workQueue);\n        executor.execute(new Task(\"0\"));\n        // shutdownNow有返回值，返回被抛弃的任务list\n        List<Runnable> dropList = executor.shutdownNow();\n        System.out.println(\"workQueue size = \" + workQueue.size() + \" after shutdown\");\n        System.out.println(\"dropList size = \" + dropList.size());\n    }\n\n    static class Task implements Runnable{\n        String name;\n\n        public Task(String name) {\n            this.name = name;\n        }\n\n        @Override\n        public void run() {\n            for(int i = 1; i <= 10; i++){\n                System.out.println(\"task \" + name + \" is running\");\n            }\n            System.out.println(\"task \" + name + \" is over\");\n        }\n    }\n}\n\n```\n\n输出结果如下：\n\n```\ntask 0 is running\nworkQueue size = 0 after shutdown\ntask 0 is running\ntask 0 is running\ntask 0 is running\ntask 0 is running\ntask 0 is running\ntask 0 is running\ntask 0 is running\ntask 0 is running\ntask 0 is running\ndropList size = 100\ntask 0 is over\n\n```\n\n从上述输出可以看到，只有任务0执行完毕，其他任务都被drop掉了，dropList的size为100。通过dropList我们可以对未处理的任务进行进一步的处理，如log记录，转发等；\n\n**问题3：正在执行的任务是否会立即中断？**\n\n要验证这个问题，需要对线程的 interrupt 方法有一定了解。\n\n* * *\n\n推荐阅读 [——线程中断机制](https://www.jianshu.com/p/e0ff2e420ab6)\n关于 interrupt 方法：\n首先，一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止。\n所以，Thread.stop, Thread.suspend, Thread.resume 都已经被废弃了。\n而 Thread.interrupt 的作用其实也不是中断线程，而是「通知线程应该中断了」，具体到底中断还是继续运行，应该由被通知的线程自己处理。\n具体来说，当对一个线程，调用 interrupt() 时，\n① 如果线程处于被阻塞状态（例如处于sleep, wait, join 等状态），那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常。仅此而已。\n② 如果线程处于正常活动状态，那么会将该线程的中断标志设置为 true，仅此而已。被设置中断标志的线程将继续正常运行，不受影响。\ninterrupt() 并不能真正的中断线程，需要被调用的线程自己进行配合才行。也就是说，一个线程如果有被中断的需求，那么就可以这样做。\n① 在正常运行任务时，经常检查本线程的中断标志位，如果被设置了中断标志就自行停止线程。\n② 在调用阻塞方法时正确处理InterruptedException异常。（例如，catch异常后就结束线程。）\n\n* * *\n\n```\npublic class InteruptTest {\n\n    public static void main(String[] args) throws InterruptedException {\n        ThreadPoolExecutor executor = new ThreadPoolExecutor(1, 1, 10, TimeUnit.SECONDS, new LinkedBlockingQueue<>());\n        executor.execute(new Task(\"0\"));\n        Thread.sleep(1);\n        executor.shutdown();\n        System.out.println(\"executor has been shutdown\");\n    }\n\n    static class Task implements Runnable {\n        String name;\n\n        public Task(String name) {\n            this.name = name;\n        }\n\n        @Override\n        public void run() {\n\n            for (int i = 1; i <= 100 && !Thread.interrupted(); i++) {\n                Thread.yield();\n                System.out.println(\"task \" + name + \" is running, round \" + i);\n            }\n\n        }\n    }\n}\n\n```\n\n输出结果如下：\n\n```\ntask 0 is running, round 1\ntask 0 is running, round 2\ntask 0 is running, round 3\n......\ntask 0 is running, round 28\nexecutor has been shutdown\n......\ntask 0 is running, round 99\ntask 0 is running, round 100\n\n```\n\n为了体现在任务执行中打断，在主线程进行短暂 sleep ， task 中 调用 Thread.yield() ，出让时间片。从结果中可以看到，线程池被关闭后，正则运行的任务没有被 interrupt。说明`shutdown()`方法不会 interrupt 运行中线程。再将其改修改为`shutdownNow()` 后输出结果如下：\n\n```\ntask 0 is running, round 1\ntask 0 is running, round 2\n......\ntask 0 is running, round 56\ntask 0 is running, round 57\ntask 0 is running, round 58\ntask 0 is running, round 59\nexecutor has been shutdown\n\n```\n\n修改为`shutdownNow()` 后，task任务没有执行完，执行到中间的时候就被 interrupt 后没有继续执行了。\n\n##### 总结，想要正确的关闭线程池，并不是简单的调用shutdown方法那么简单，要考虑到应用场景的需求，如何拒绝新来的请求任务？如何处理等待队列中的任务？如何处理正在执行的任务？想好这几个问题，在确定如何优雅而正确的关闭线程池。\n\nPS：线程被 interrupt 后，需要再run方法中单独处理 interrupted 状态，interrupt 更类似一个标志位，不会直接打断线程的执行。\n",[[1566271739183,["david@DESKTOP-9844NL4",[[-1,50,"- "]],[52,52],[50,50]]],[1566271739660,["david@DESKTOP-9844NL4",[[-1,49,"\n"]],[50,50],[49,49]]],[1566271740729,["david@DESKTOP-9844NL4",[[1,49," "]],[49,49],[50,50]]],[1566271877039,["david@DESKTOP-9844NL4",[[1,382,"<!-- more -->\n"]],[382,382],[396,396]]]],null,"david@DESKTOP-9844NL4"]]}