{"compress":true,"commitItems":[["350aa5b8-ed92-48b4-92ac-d1c83328181a",1566178944450,"",[[1566178897646,["david@DESKTOP-9844NL4",[[1,0,"# java线程池\n\n\n\n"]],[0,0],[12,12]]],[1566178908728,["david@DESKTOP-9844NL4",[[1,0,"\n"]],[0,0],[1,1]]],[1566178909647,["david@DESKTOP-9844NL4",[[1,0,"\n---\ntitle: CenOS7.5使用crontab定时备份数据库脚本\ncategories: LINUX\ntags:\n- Mysql\n---"]],[0,0],[74,74]]],[1566178912422,["david@DESKTOP-9844NL4",[[-1,75,"# java线程池"]],[75,84],[75,75]]],[1566178912810,["david@DESKTOP-9844NL4",[[-1,78,"\n"]],[75,75],[74,74]]],[1566178919912,["david@DESKTOP-9844NL4",[[-1,65,"Mysql"],[1,70,"线程池"]],[65,65],[68,68]]],[1566178924054,["david@DESKTOP-9844NL4",[[-1,51,"LINUX"],[1,56,"java"]],[51,56],[55,55]]],[1566178926982,["david@DESKTOP-9844NL4",[[-1,12,"CenOS7.5使用crontab定时备份数据库脚本"]],[12,38],[12,12]]],[1566178928415,["david@DESKTOP-9844NL4",[[1,12,"xia"]],[12,12],[15,15]]],[1566178929132,["david@DESKTOP-9844NL4",[[-1,12,"xia"]],[15,15],[12,12]]],[1566178939417,["david@DESKTOP-9844NL4",[[1,12,"# 线程池之ThreadPoolExecutor使用"]],[12,12],[38,38]]],[1566178941980,["david@DESKTOP-9844NL4",[[-1,12,"# "]],[13,13],[12,12]]],[1566178946777,["david@DESKTOP-9844NL4",[[1,73,"\n"]],[70,70],[71,71]]],[1566178947013,["david@DESKTOP-9844NL4",[[1,74,"\n"]],[71,71],[72,72]]],[1566179000005,["david@DESKTOP-9844NL4",[[1,71,"### Executors创建线程池\n\nJava中创建线程池很简单，只需要调用`Executors`中相应的便捷方法即可，比如`Executors.newFixedThreadPool(int nThreads)`，但是便捷不仅隐藏了复杂性，也为我们埋下了潜在的隐患（OOM，线程耗尽）。\n\n`Executors`创建线程池便捷方法列表：\n\n| 方法名 | 功能 |\n| --- | --- |\n| newFixedThreadPool(int nThreads) | 创建固定大小的线程池 |\n| newSingleThreadExecutor() | 创建只有一个线程的线程池 |\n| newCachedThreadPool() | 创建一个不限线程数上限的线程池，任何提交的任务都将立即执行 |\n\n小程序使用这些快捷方法没什么问题，对于服务端需要长期运行的程序，创建线程池应该直接使用`ThreadPoolExecutor`的构造方法。没错，上述`Executors`方法创建的线程池就是`ThreadPoolExecutor`。\n\n### ThreadPoolExecutor构造方法"]],[71,71],[567,567]]],[1566179058950,["david@DESKTOP-9844NL4",[[-1,214,"。"]],[215,215],[214,214]]],[1566179060743,["david@DESKTOP-9844NL4",[[1,214,". x"]],[214,214],[217,217]]],[1566179061159,["david@DESKTOP-9844NL4",[[-1,216,"x"]],[217,217],[216,216]]],[1566179067980,["david@DESKTOP-9844NL4",[[1,216,"阿里巴巴开发者规范中"]],[216,216],[226,226]]],[1566179069694,["david@DESKTOP-9844NL4",[[1,226,",不"]],[226,226],[228,228]]],[1566179072155,["david@DESKTOP-9844NL4",[[-1,216,"阿里巴巴开发者规范中,不"]],[228,228],[216,216]]],[1566179087088,["david@DESKTOP-9844NL4",[[1,216,"因此阿里巴巴java开发规范中也明确指出:"]],[216,216],[237,237]]],[1566179087430,["david@DESKTOP-9844NL4",[[1,239,"\n"]],[237,237],[238,238]]],[1566179166925,["david@DESKTOP-9844NL4",[[-1,214,". 因此阿里巴巴java开发规范中也明确指出:"]],[216,237],[214,214]]],[1566179168250,["david@DESKTOP-9844NL4",[[1,214,","]],[214,214],[215,215]]],[1566179168711,["david@DESKTOP-9844NL4",[[-1,214,","]],[215,215],[214,214]]],[1566180854400,["david@DESKTOP-9844NL4",[[1,217,"\n"]],[214,214],[215,215]]],[1566180860718,["david@DESKTOP-9844NL4",[[1,215,"阿里巴巴开发规范中，"]],[215,215],[225,225]]],[1566180861292,["david@DESKTOP-9844NL4",[[-1,224,"，"]],[225,225],[224,224]]],[1566180862072,["david@DESKTOP-9844NL4",[[1,224,",Ye"]],[224,224],[227,227]]],[1566180862706,["david@DESKTOP-9844NL4",[[-1,225,"Ye"]],[227,227],[225,225]]],[1566180883749,["david@DESKTOP-9844NL4",[[1,225,"也明确指出禁止使用Executors来创建线程,"]],[225,225],[249,249]]],[1566180884342,["david@DESKTOP-9844NL4",[[-1,248,","]],[249,249],[248,248]]],[1566180885085,["david@DESKTOP-9844NL4",[[1,251,"\n"]],[248,248],[249,249]]],[1566180885745,["david@DESKTOP-9844NL4",[[1,249,"![mark](http://blog.sjjtcloud.com/blog/20190819/q0PHMznUCrBk.png?imageslim)"]],[249,249],[324,324]]],[1566180896005,["david@DESKTOP-9844NL4",[[1,215,"\n"]],[215,215],[216,216]]],[1566180932563,["david@DESKTOP-9844NL4",[[-1,91,"Java中创建线程池很简单，只需要调用`Executors`中相应的便捷方法即可，比如`Executors.newFixedThreadPool(int nThreads)`，但是便捷不仅隐藏了复杂性，也为我们埋下了潜在的隐患（OOM，线程耗尽）\n"]],[90,214],[90,90]]],[1566180933261,["david@DESKTOP-9844NL4",[[-1,91,"\n"]],[90,90],[89,89]]],[1566180935867,["david@DESKTOP-9844NL4",[[1,91,"\n"]],[89,89],[90,90]]],[1566180939391,["david@DESKTOP-9844NL4",[[-1,92,"阿里巴巴开发规范中,也明确指出禁止使用Executors来创建线程\n![mark](http://blog.sjjtcloud.com/blog/20190819/q0PHMznUCrBk.png?imageslim)\n"]],[92,202],[92,92]]],[1566180940688,["david@DESKTOP-9844NL4",[[-1,93,"\n"]],[93,93],[92,92]]],[1566180940930,["david@DESKTOP-9844NL4",[[-1,92,"\n"]],[92,92],[91,91]]],[1566180941186,["david@DESKTOP-9844NL4",[[-1,91,"\n"]],[91,91],[90,90]]],[1566180947189,["david@DESKTOP-9844NL4",[[-1,107,"便捷"]],[107,109],[107,107]]],[1566180973691,["david@DESKTOP-9844NL4",[[1,295,"\n"]],[294,294],[295,295]]],[1566180973882,["david@DESKTOP-9844NL4",[[1,296,"\n"]],[295,295],[296,296]]],[1566180975673,["david@DESKTOP-9844NL4",[[1,295,"但是"]],[295,295],[297,297]]],[1566180977083,["david@DESKTOP-9844NL4",[[-1,295,"但是"]],[297,297],[295,295]]],[1566180992131,["david@DESKTOP-9844NL4",[[1,295,"阿里巴巴开发规范中,关于线程池部分,是这样的"]],[295,295],[317,317]]],[1566180994259,["david@DESKTOP-9844NL4",[[-1,312,",是这样的"]],[317,317],[312,312]]],[1566180995014,["david@DESKTOP-9844NL4",[[1,314,"\n"]],[312,312],[313,313]]],[1566180995376,["david@DESKTOP-9844NL4",[[1,313,"阿里巴巴开发规范中,也明确指出禁止使用Executors来创建线程\n![mark](http://blog.sjjtcloud.com/blog/20190819/q0PHMznUCrBk.png?imageslim)\n"]],[313,313],[423,423]]],[1566181001130,["david@DESKTOP-9844NL4",[[-1,295,"阿里巴巴开发规范中,关于线程池部分"]],[295,312],[295,295]]],[1566181003859,["david@DESKTOP-9844NL4",[[-1,306,"也"]],[307,307],[306,306]]],[1566181020353,["david@DESKTOP-9844NL4",[[1,329,"\n"]],[328,328],[329,329]]],[1566181020525,["david@DESKTOP-9844NL4",[[1,330,"\n"]],[329,329],[330,330]]],[1566181023481,["david@DESKTOP-9844NL4",[[1,329,"//"]],[329,329],[331,331]]],[1566181024022,["david@DESKTOP-9844NL4",[[-1,329,"//"]],[331,331],[329,329]]],[1566181025199,["david@DESKTOP-9844NL4",[[1,329,">>"]],[329,329],[331,331]]],[1566181025754,["david@DESKTOP-9844NL4",[[-1,329,">>"]],[331,331],[329,329]]],[1566181026280,["david@DESKTOP-9844NL4",[[1,329,".."]],[329,329],[331,331]]],[1566181026880,["david@DESKTOP-9844NL4",[[-1,329,".."]],[331,331],[329,329]]],[1566181031863,["david@DESKTOP-9844NL4",[[1,329,"【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样\n的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。\n说明：Executors 返回的线程池对象的弊端如下：\n1）FixedThreadPool 和 SingleThreadPool:\n允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。\n2）CachedThreadPool 和 ScheduledThreadPool:\n允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。\r"]],[329,329],[629,629]]],[1566181033929,["david@DESKTOP-9844NL4",[[-1,329,"【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样\n的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。\n说明：Executors 返回的线程池对象的弊端如下：\n1）FixedThreadPool 和 SingleThreadPool:\n允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。\n2）CachedThreadPool 和 ScheduledThreadPool:\n允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。\r"]],[629,629],[329,329]]],[1566181035314,["david@DESKTOP-9844NL4",[[1,329,"`1`"]],[329,329],[332,332]]],[1566181036365,["david@DESKTOP-9844NL4",[[-1,330,"1`"]],[332,332],[330,330]]],[1566181036970,["david@DESKTOP-9844NL4",[[1,330,"``"]],[330,330],[332,332]]],[1566181036994,["david@DESKTOP-9844NL4",[[1,332,"language\n```\n"]],[332,332],[332,340]]],[1566181039057,["david@DESKTOP-9844NL4",[[-1,332,"language"]],[332,340],[332,332]]],[1566181039371,["david@DESKTOP-9844NL4",[[1,333,"\n"]],[332,332],[333,333]]],[1566181039813,["david@DESKTOP-9844NL4",[[1,333,"【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样\n的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。\n说明：Executors 返回的线程池对象的弊端如下：\n1）FixedThreadPool 和 SingleThreadPool:\n允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。\n2）CachedThreadPool 和 ScheduledThreadPool:\n允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。\r"]],[333,333],[633,633]]],[1566181044550,["david@DESKTOP-9844NL4",[[-1,638,"\n\n![mark](http://blog.sjjtcloud.com/blog/20190819/q0PHMznUCrBk.png?imageslim"]],[638,714],[638,638]]],[1566181044827,["david@DESKTOP-9844NL4",[[-1,637,"\n"]],[638,638],[637,637]]],[1566181045278,["david@DESKTOP-9844NL4",[[-1,636,"`"]],[637,637],[636,636]]],[1566181050781,["david@DESKTOP-9844NL4",[[1,329,"\n"]],[328,328],[329,329]]],[1566181063313,["david@DESKTOP-9844NL4",[[1,328,","],[-1,633,"\r"]],[328,328],[329,329]]],[1566181064320,["david@DESKTOP-9844NL4",[[1,329,"yin"]],[329,329],[332,332]]],[1566181065054,["david@DESKTOP-9844NL4",[[-1,329,"yin"]],[332,332],[329,329]]],[1566181066791,["david@DESKTOP-9844NL4",[[1,329,"因为有"]],[329,329],[332,332]]],[1566181067049,["david@DESKTOP-9844NL4",[[-1,331,"有"]],[332,332],[331,331]]],[1566181068718,["david@DESKTOP-9844NL4",[[1,331,"这样做"]],[331,331],[334,334]]],[1566181069089,["david@DESKTOP-9844NL4",[[-1,333,"做"]],[334,334],[333,333]]],[1566181073640,["david@DESKTOP-9844NL4",[[1,333,"创建线程池,You"]],[333,333],[342,342]]],[1566181074088,["david@DESKTOP-9844NL4",[[-1,341,"u"]],[342,342],[341,341]]],[1566181074417,["david@DESKTOP-9844NL4",[[-1,339,"Yo"]],[341,341],[339,339]]],[1566181080654,["david@DESKTOP-9844NL4",[[1,339,"有OOM的"]],[339,339],[344,344]]],[1566181082674,["david@DESKTOP-9844NL4",[[-1,340,"OOM的"]],[344,344],[340,340]]],[1566181090193,["david@DESKTOP-9844NL4",[[1,340,"可能会导致OOM，"]],[340,340],[349,349]]],[1566181090831,["david@DESKTOP-9844NL4",[[-1,348,"，"]],[349,349],[348,348]]],[1566181095570,["david@DESKTOP-9844NL4",[[1,348,", chu"]],[348,348],[353,353]]],[1566181097897,["david@DESKTOP-9844NL4",[[-1,348,", chu"]],[353,353],[348,348]]],[1566181098233,["david@DESKTOP-9844NL4",[[1,348,"，"]],[348,348],[349,349]]],[1566181098866,["david@DESKTOP-9844NL4",[[-1,348,"，"]],[349,349],[348,348]]],[1566181101709,["david@DESKTOP-9844NL4",[[1,348,",因此创建"]],[348,348],[353,353]]],[1566181102571,["david@DESKTOP-9844NL4",[[-1,348,",因此创建"]],[353,353],[348,348]]],[1566181107963,["david@DESKTOP-9844NL4",[[-1,659,"\n小程序使用这些快捷方法没什么问题，对于服务端需要长期运行的程序，创建线程池应该直接使用`ThreadPoolExecutor`的构造方法。没错，上述`Executors`方法创建的线程池就是`ThreadPoolExecutor`。\n\n"]],[658,777],[658,658]]],[1566181108285,["david@DESKTOP-9844NL4",[[-1,658,"\n"]],[658,658],[657,657]]],[1566181108824,["david@DESKTOP-9844NL4",[[1,658,"\n"]],[657,657],[658,658]]],[1566181109020,["david@DESKTOP-9844NL4",[[1,659,"\n"]],[658,658],[659,659]]],[1566181131243,["david@DESKTOP-9844NL4",[[1,660,"\n"]],[658,658],[659,659]]],[1566181131434,["david@DESKTOP-9844NL4",[[1,661,"\n"]],[659,659],[660,660]]],[1566181132976,["david@DESKTOP-9844NL4",[[1,659,"zix"]],[659,659],[662,662]]],[1566181133619,["david@DESKTOP-9844NL4",[[-1,659,"zix"]],[662,662],[659,659]]],[1566181135539,["david@DESKTOP-9844NL4",[[1,659,"自诩"]],[659,659],[661,661]]],[1566181135934,["david@DESKTOP-9844NL4",[[-1,659,"自诩"]],[661,661],[659,659]]],[1566181143789,["david@DESKTOP-9844NL4",[[1,659,"通过分析Exc"]],[659,659],[666,666]]],[1566181145427,["david@DESKTOP-9844NL4",[[-1,665,"c"]],[666,666],[665,665]]],[1566181150395,["david@DESKTOP-9844NL4",[[1,665,"ecutors的源码，faxia"]],[665,665],[681,681]]],[1566181151426,["david@DESKTOP-9844NL4",[[-1,675,"，faxia"]],[681,681],[675,675]]],[1566181152525,["david@DESKTOP-9844NL4",[[1,675,"，fa"]],[675,675],[678,678]]],[1566181153228,["david@DESKTOP-9844NL4",[[-1,675,"，fa"]],[678,678],[675,675]]],[1566181157360,["david@DESKTOP-9844NL4",[[1,348,",yin"]],[348,348],[352,352]]],[1566181157960,["david@DESKTOP-9844NL4",[[-1,349,"yin"]],[352,352],[349,349]]],[1566181159127,["david@DESKTOP-9844NL4",[[1,349," tic"]],[349,349],[353,353]]],[1566181159812,["david@DESKTOP-9844NL4",[[-1,350,"tic"]],[353,353],[350,350]]],[1566181163963,["david@DESKTOP-9844NL4",[[1,350," yin"]],[350,350],[354,354]]],[1566181164568,["david@DESKTOP-9844NL4",[[-1,351,"yin"]],[354,354],[351,351]]],[1566181165693,["david@DESKTOP-9844NL4",[[1,351,"应该"]],[351,351],[353,353]]],[1566181166112,["david@DESKTOP-9844NL4",[[-1,351,"应该"]],[353,353],[351,351]]],[1566181167502,["david@DESKTOP-9844NL4",[[1,351,"创建"]],[351,351],[353,353]]],[1566181168165,["david@DESKTOP-9844NL4",[[-1,351,"创建"]],[353,353],[351,351]]],[1566181176396,["david@DESKTOP-9844NL4",[[1,351,"创建线程池应该使用ThreadPoolExecutor de"]],[351,351],[381,381]]],[1566181177206,["david@DESKTOP-9844NL4",[[-1,378," de"]],[381,381],[378,378]]],[1566181182511,["david@DESKTOP-9844NL4",[[1,378,"的方式,"]],[378,378],[382,382]]],[1566181182907,["david@DESKTOP-9844NL4",[[-1,381,","]],[382,382],[381,381]]],[1566181189462,["david@DESKTOP-9844NL4",[[1,692,"\n"]],[690,690],[691,691]]],[1566181191268,["david@DESKTOP-9844NL4",[[1,691,"```"]],[691,691],[694,694]]],[1566181192884,["david@DESKTOP-9844NL4",[[1,696,"\n"]],[694,694],[695,695]]],[1566181193084,["david@DESKTOP-9844NL4",[[1,697,"\n"]],[695,695],[696,696]]],[1566181197875,["david@DESKTOP-9844NL4",[[-1,687,"``)"]],[690,690],[687,687]]],[1566181202825,["david@DESKTOP-9844NL4",[[1,391,"\n"]],[391,391],[392,392]]],[1566181208634,["david@DESKTOP-9844NL4",[[1,508,"\n"]],[508,508],[509,509]]],[1566181210725,["david@DESKTOP-9844NL4",[[1,597,"\n"]],[597,597],[598,598]]],[1566181250311,["david@DESKTOP-9844NL4",[[-1,716,"\n"]],[714,715],[714,714]]],[1566181253168,["david@DESKTOP-9844NL4",[[-1,698,"通过分析Executors的源码"]],[714,714],[698,698]]],[1566181253331,["david@DESKTOP-9844NL4",[[-1,699,"\n"]],[698,698],[697,697]]],[1566181254529,["david@DESKTOP-9844NL4",[[-1,698,"\n"]],[697,697],[696,696]]],[1566181258051,["david@DESKTOP-9844NL4",[[1,381,", yi"]],[381,381],[385,385]]],[1566181258645,["david@DESKTOP-9844NL4",[[-1,383,"yi"]],[385,385],[383,383]]],[1566181266352,["david@DESKTOP-9844NL4",[[1,383,"其实Executors创建"]],[383,383],[396,396]]],[1566181266977,["david@DESKTOP-9844NL4",[[-1,394,"创建"]],[396,396],[394,394]]],[1566181278760,["david@DESKTOP-9844NL4",[[1,394,"这些便捷的方法，背后也是在使用![mark](http://blog.sjjtcloud.com/blog/20190819/URrvW1kKs3p3.png?imageslim)"]],[394,394],[484,484]]],[1566181280053,["david@DESKTOP-9844NL4",[[-1,394,"这些便捷的方法，背后也是在使用![mark](http://blog.sjjtcloud.com/blog/20190819/URrvW1kKs3p3.png?imageslim)"]],[484,484],[394,394]]],[1566181283360,["david@DESKTOP-9844NL4",[[1,394,"。"]],[394,394],[395,395]]],[1566181290619,["david@DESKTOP-9844NL4",[[-1,385,"Executors。"]],[395,395],[385,385]]],[1566181300265,["david@DESKTOP-9844NL4",[[1,385,"这些创建线程池的方法，背后"]],[385,385],[398,398]]],[1566181300817,["david@DESKTOP-9844NL4",[[-1,395,"，背后"]],[398,398],[395,395]]],[1566181311237,["david@DESKTOP-9844NL4",[[1,395,",背后原理也是使用Tree"]],[395,395],[408,408]]],[1566181311714,["david@DESKTOP-9844NL4",[[-1,407,"e"]],[408,408],[407,407]]],[1566181314083,["david@DESKTOP-9844NL4",[[1,407,"adPoolEx"]],[407,407],[415,415]]],[1566181321436,["david@DESKTOP-9844NL4",[[1,415,"ecutors构造器"]],[415,415],[425,425]]],[1566181323043,["david@DESKTOP-9844NL4",[[-1,421,"s构造器"]],[425,425],[421,421]]],[1566181328554,["david@DESKTOP-9844NL4",[[1,421,"来创建的，因此"]],[421,421],[428,428]]],[1566181330686,["david@DESKTOP-9844NL4",[[-1,425,"，因此"]],[428,428],[425,425]]],[1566181342320,["david@DESKTOP-9844NL4",[[1,425,",因此浙西简单的创建线程池的房"]],[425,425],[440,440]]],[1566181343412,["david@DESKTOP-9844NL4",[[-1,439,"房"]],[440,440],[439,439]]],[1566181349287,["david@DESKTOP-9844NL4",[[1,439,"方法，用以小的程序"]],[439,439],[448,448]]],[1566181356191,["david@DESKTOP-9844NL4",[[-1,425,",因此浙西简单的创建线程池的方法，用以小的程序"]],[448,448],[425,425]]],[1566181359333,["david@DESKTOP-9844NL4",[[1,742,"\n"]],[739,739],[740,740]]],[1566181360340,["david@DESKTOP-9844NL4",[[1,739,"T"]],[739,739],[740,740]]],[1566181360807,["david@DESKTOP-9844NL4",[[1,744,"\n"]],[740,740],[741,741]]],[1566181361317,["david@DESKTOP-9844NL4",[[-1,744,"\n"]],[741,741],[740,740]]],[1566181361515,["david@DESKTOP-9844NL4",[[-1,739,"T"]],[740,740],[739,739]]],[1566181361903,["david@DESKTOP-9844NL4",[[1,743,"\n"]],[739,739],[740,740]]],[1566181368864,["david@DESKTOP-9844NL4",[[1,740,"Thread.new Fi"]],[740,740],[753,753]]],[1566181369590,["david@DESKTOP-9844NL4",[[-1,750," Fi"]],[753,753],[750,750]]],[1566181370554,["david@DESKTOP-9844NL4",[[1,750,"f"]],[750,750],[751,751]]],[1566181370969,["david@DESKTOP-9844NL4",[[-1,750,"f"]],[751,751],[750,750]]],[1566181372120,["david@DESKTOP-9844NL4",[[1,750,"f"]],[750,750],[751,751]]],[1566181372477,["david@DESKTOP-9844NL4",[[-1,750,"f"]],[751,751],[750,750]]],[1566181373291,["david@DESKTOP-9844NL4",[[1,750,"File"]],[750,750],[754,754]]],[1566181373958,["david@DESKTOP-9844NL4",[[-1,753,"e"]],[754,754],[753,753]]],[1566181375559,["david@DESKTOP-9844NL4",[[-1,752,"l"]],[753,753],[752,752]]],[1566181384065,["david@DESKTOP-9844NL4",[[1,752,"xedThreadPool()"]],[752,752],[767,767]]],[1566181388296,["david@DESKTOP-9844NL4",[[1,766,"int poolS"]],[766,766],[775,775]]],[1566181389889,["david@DESKTOP-9844NL4",[[-1,770,"poolS"]],[775,775],[770,770]]],[1566181390319,["david@DESKTOP-9844NL4",[[1,770,"N"]],[770,770],[771,771]]],[1566181391022,["david@DESKTOP-9844NL4",[[-1,770,"N"]],[771,771],[770,770]]],[1566181392794,["david@DESKTOP-9844NL4",[[1,770,"nThrea"]],[770,770],[776,776]]],[1566181393376,["david@DESKTOP-9844NL4",[[-1,775,"a"]],[776,776],[775,775]]],[1566181394526,["david@DESKTOP-9844NL4",[[1,775,"ads"]],[775,775],[778,778]]],[1566181398426,["david@DESKTOP-9844NL4",[[1,779,"源码"]],[779,779],[781,781]]],[1566181399256,["david@DESKTOP-9844NL4",[[1,785,"\n"]],[781,781],[782,782]]],[1566181399581,["david@DESKTOP-9844NL4",[[1,782,"newFixedThreadPool"]],[782,782],[800,800]]],[1566181405742,["david@DESKTOP-9844NL4",[[-1,782,"newFixedThreadPool"]],[782,800],[782,782]]],[1566181405993,["david@DESKTOP-9844NL4",[[1,782,"![mark](http://blog.sjjtcloud.com/blog/20190819/URrvW1kKs3p3.png?imageslim)"]],[782,782],[857,857]]],[1566181423150,["david@DESKTOP-9844NL4",[[-1,860,"\n"]],[860,860],[859,859]]],[1566181423428,["david@DESKTOP-9844NL4",[[-1,859,"\n"]],[859,859],[858,858]]],[1566181436512,["david@DESKTOP-9844NL4",[[-1,427,"```\n【强制】\n线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样\n的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。\n说明：Executors 返回的线程池对象的弊端如下：\n\n1）FixedThreadPool 和 SingleThreadPool:\n允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。\n\n2）CachedThreadPool 和 ScheduledThreadPool:\n允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。\n\n```"]],[427,738],[427,427]]],[1566181441702,["david@DESKTOP-9844NL4",[[1,71,"\n"]],[70,70],[71,71]]],[1566181441892,["david@DESKTOP-9844NL4",[[1,72,"\n"]],[71,71],[72,72]]],[1566181456969,["david@DESKTOP-9844NL4",[[1,71,"### 阿里巴巴线程池开发规范"]],[71,71],[86,86]]],[1566181457256,["david@DESKTOP-9844NL4",[[1,88,"\n"]],[86,86],[87,87]]],[1566181457910,["david@DESKTOP-9844NL4",[[1,87,"```\n【强制】\n线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样\n的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。\n说明：Executors 返回的线程池对象的弊端如下：\n\n1）FixedThreadPool 和 SingleThreadPool:\n允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。\n\n2）CachedThreadPool 和 ScheduledThreadPool:\n允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。\n\n```"]],[87,87],[398,398]]],[1566181458587,["david@DESKTOP-9844NL4",[[1,400,"\n"]],[398,398],[399,399]]],[1566181465388,["david@DESKTOP-9844NL4",[[1,71,"\n"]],[70,70],[71,71]]],[1566181472875,["david@DESKTOP-9844NL4",[[1,88,"\n"]],[87,87],[88,88]]],[1566181486909,["david@DESKTOP-9844NL4",[[-1,124,"过 "]],[126,126],[124,124]]],[1566181488882,["david@DESKTOP-9844NL4",[[1,124,"过 "]],[124,124],[126,126]]],[1566181500213,["david@DESKTOP-9844NL4",[[-1,628,"阿里巴巴开发规范中,明确指出禁止使用Executors来创建线程,因为这样创建线程池,有可能会导致OOM,  创建线程池应该使用ThreadPoolExecutor的方式, 其实这些创建线程池的方法,背后原理也是使用TreadPoolExecutor来创建的\n"]],[628,758],[628,628]]],[1566181503597,["david@DESKTOP-9844NL4",[[1,89,"\n"]],[88,88],[89,89]]],[1566181504029,["david@DESKTOP-9844NL4",[[1,89,"阿里巴巴开发规范中,明确指出禁止使用Executors来创建线程,因为这样创建线程池,有可能会导致OOM,  创建线程池应该使用ThreadPoolExecutor的方式, 其实这些创建线程池的方法,背后原理也是使用TreadPoolExecutor来创建的\n"]],[89,89],[219,219]]],[1566181512401,["david@DESKTOP-9844NL4",[[-1,761,"\n"]],[761,761],[760,760]]],[1566181512619,["david@DESKTOP-9844NL4",[[-1,760,"\n"]],[760,760],[759,759]]],[1566181512807,["david@DESKTOP-9844NL4",[[-1,759,"\n"]],[759,759],[758,758]]],[1566181513012,["david@DESKTOP-9844NL4",[[-1,758,"\n"]],[758,758],[757,757]]],[1566181519633,["david@DESKTOP-9844NL4",[[1,907,"\n"]],[903,903],[904,904]]],[1566181539792,["david@DESKTOP-9844NL4",[[1,904,"![mark](http://blog.sjjtcloud.com/blog/20190819/voP4iKK3jVUw.png?imageslim)"]],[904,904],[979,979]]],[1566181544433,["david@DESKTOP-9844NL4",[[1,983,"\n"]],[979,979],[980,980]]],[1566181544623,["david@DESKTOP-9844NL4",[[1,984,"\n"]],[980,980],[981,981]]],[1566181637392,["david@DESKTOP-9844NL4",[[-1,533,"\n"]],[533,533],[532,532]]],[1566181637881,["david@DESKTOP-9844NL4",[[1,533,"\n"]],[532,532],[533,533]]],[1566181661047,["david@DESKTOP-9844NL4",[[1,985,"\n"]],[979,979],[980,980]]],[1566181661242,["david@DESKTOP-9844NL4",[[1,986,"\n"]],[980,980],[981,981]]],[1566181661408,["david@DESKTOP-9844NL4",[[1,987,"\n"]],[981,981],[982,982]]],[1566181661829,["david@DESKTOP-9844NL4",[[1,982,"我们以最后一个构造方法（参数最多的那个），对其参数进行解释：\n\n```\n public ThreadPoolExecutor(int corePoolSize, // 1\n                              int maximumPoolSize,  // 2\n                              long keepAliveTime,  // 3\n                              TimeUnit unit,  // 4\n                              BlockingQueue<Runnable> workQueue, // 5\n                              ThreadFactory threadFactory,  // 6\n                              RejectedExecutionHandler handler ) { //7\n        if (corePoolSize < 0 ||\n            maximumPoolSize <= 0 ||\n            maximumPoolSize < corePoolSize ||\n            keepAliveTime < 0)\n            throw new IllegalArgumentException();\n        if (workQueue == null || threadFactory == null || handler == null)\n            throw new NullPointerException();\n        this.corePoolSize = corePoolSize;\n        this.maximumPoolSize = maximumPoolSize;\n        this.workQueue = workQueue;\n        this.keepAliveTime = unit.toNanos(keepAliveTime);\n        this.threadFactory = threadFactory;\n        this.handler = handler;\n    }\n\n```\n\n| 序号 | 名称 | 类型 | 含义 |\n| --- | --- | --- | --- |\n| 1 | corePoolSize | int | 核心线程池大小 |\n| 2 | maximumPoolSize | int | 最大线程池大小 |\n| 3 | keepAliveTime | long | 线程最大空闲时间 |\n| 4 | unit | TimeUnit | 时间单位 |\n| 5 | workQueue | BlockingQueue<Runnable> | 线程等待队列 |\n| 6 | threadFactory | ThreadFactory | 线程创建工厂 |\n| 7 | handler | RejectedExecutionHandler | 拒绝策略 |\n\n如果对这些参数作用有疑惑的请看 [ThreadPoolExecutor概述](https://www.jianshu.com/p/c41e942bcd64)。\n知道了各个参数的作用后，我们开始构造符合我们期待的线程池。首先看JDK给我们预定义的几种线程池：\n\n##### 一、预定义线程池\n\n1.  **FixedThreadPool**\n\n```\n    public static ExecutorService newFixedThreadPool(int nThreads) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue<Runnable>());\n    }\n\n```\n\n> *   corePoolSize与maximumPoolSize相等，即其线程全为核心线程，是一个固定大小的线程池，是其优势；\n> *   keepAliveTime = 0 该参数默认对核心线程无效，而FixedThreadPool全部为核心线程；\n> *   workQueue 为LinkedBlockingQueue（无界阻塞队列），队列最大值为Integer.MAX_VALUE。如果任务提交速度持续大余任务处理速度，会造成队列大量阻塞。因为队列很大，很有可能在拒绝策略前，内存溢出。是其劣势；\n> *   FixedThreadPool的任务执行是无序的；\n\n适用场景：可用于Web服务瞬时削峰，但需注意长时间持续高峰情况造成的队列阻塞。\n\n1.  **CachedThreadPool**\n\n```\n     public static ExecutorService newCachedThreadPool() {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue<Runnable>());\n    }\n\n```\n\n> *   corePoolSize = 0，maximumPoolSize = Integer.MAX_VALUE，即线程数量几乎无限制；\n> *   keepAliveTime = 60s，线程空闲60s后自动结束。\n> *   workQueue 为 SynchronousQueue 同步队列，这个队列类似于一个接力棒，入队出队必须同时传递，因为CachedThreadPool线程创建无限制，不会有队列等待，所以使用SynchronousQueue；\n\n适用场景：快速处理大量耗时较短的任务，如Netty的NIO接受请求时，可使用CachedThreadPool。\n\n1.  **SingleThreadExecutor**\n\n```\n    public static ExecutorService newSingleThreadExecutor() {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>()));\n    }\n\n```\n\n咋一瞅，不就是newFixedThreadPool(1)吗？定眼一看，这里多了一层FinalizableDelegatedExecutorService包装，这一层有什么用呢，写个dome来解释一下：\n\n```\n    public static void main(String[] args) {\n        ExecutorService fixedExecutorService = Executors.newFixedThreadPool(1);\n        ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) fixedExecutorService;\n        System.out.println(threadPoolExecutor.getMaximumPoolSize());\n        threadPoolExecutor.setCorePoolSize(8);\n\n        ExecutorService singleExecutorService = Executors.newSingleThreadExecutor();\n//      运行时异常 java.lang.ClassCastException\n//      ThreadPoolExecutor threadPoolExecutor2 = (ThreadPoolExecutor) singleExecutorService;\n    }\n\n```\n\n对比可以看出，FixedThreadPool可以向下转型为ThreadPoolExecutor，并对其线程池进行配置，而SingleThreadExecutor被包装后，无法成功向下转型。**因此，SingleThreadExecutor被定以后，无法修改，做到了真正的Single。**\n\n1.  **ScheduledThreadPool**\n\n```\n    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {\n        return new ScheduledThreadPoolExecutor(corePoolSize);\n    }\n\n```\n\nnewScheduledThreadPool调用的是ScheduledThreadPoolExecutor的构造方法，而ScheduledThreadPoolExecutor继承了ThreadPoolExecutor，构造是还是调用了其父类的构造方法。\n\n```\n    public ScheduledThreadPoolExecutor(int corePoolSize) {\n        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,\n              new DelayedWorkQueue());\n    }\n\n```\n\n对于ScheduledThreadPool本文不做描述，其特性请关注后续篇章。\n\n作者：徐志毅\n链接：https://www.jianshu.com/p/f030aa5d7a28\n来源：简书\n简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。"]],[982,982],[5530,5530]]],[1566181756306,["david@DESKTOP-9844NL4",[[-1,5400,"对于ScheduledThreadPool本文不做描述，其特性请关注后续篇章。\n\n作者：徐志毅\n链接：https://www.jianshu.com/p/f030aa5d7a28\n来源：简书\n简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。\n"]],[5400,5531],[5400,5400]]],[1566181786814,["david@DESKTOP-9844NL4",[[1,5400,"##### 二、自定义线程池\n\n以下是自定义线程池，使用了有界队列，自定义ThreadFactory和拒绝策略的demo：\n\n```\npublic class ThreadTest {\n\n    public static void main(String[] args) throws InterruptedException, IOException {\n        int corePoolSize = 2;\n        int maximumPoolSize = 4;\n        long keepAliveTime = 10;\n        TimeUnit unit = TimeUnit.SECONDS;\n        BlockingQueue<Runnable> workQueue = new ArrayBlockingQueue<>(2);\n        ThreadFactory threadFactory = new NameTreadFactory();\n        RejectedExecutionHandler handler = new MyIgnorePolicy();\n        ThreadPoolExecutor executor = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit,\n                workQueue, threadFactory, handler);\n        executor.prestartAllCoreThreads(); // 预启动所有核心线程\n\n        for (int i = 1; i <= 10; i++) {\n            MyTask task = new MyTask(String.valueOf(i));\n            executor.execute(task);\n        }\n\n        System.in.read(); //阻塞主线程\n    }\n\n    static class NameTreadFactory implements ThreadFactory {\n\n        private final AtomicInteger mThreadNum = new AtomicInteger(1);\n\n        @Override\n        public Thread newThread(Runnable r) {\n            Thread t = new Thread(r, \"my-thread-\" + mThreadNum.getAndIncrement());\n            System.out.println(t.getName() + \" has been created\");\n            return t;\n        }\n    }\n\n    public static class MyIgnorePolicy implements RejectedExecutionHandler {\n\n        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n            doLog(r, e);\n        }\n\n        private void doLog(Runnable r, ThreadPoolExecutor e) {\n            // 可做日志记录等\n            System.err.println( r.toString() + \" rejected\");\n//          System.out.println(\"completedTaskCount: \" + e.getCompletedTaskCount());\n        }\n    }\n\n    static class MyTask implements Runnable {\n        private String name;\n\n        public MyTask(String name) {\n            this.name = name;\n        }\n\n        @Override\n        public void run() {\n            try {\n                System.out.println(this.toString() + \" is running!\");\n                Thread.sleep(3000); //让任务执行慢点\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        @Override\n        public String toString() {\n            return \"MyTask [name=\" + name + \"]\";\n        }\n    }\n}\n\n```\n\n输出结果如下：\n\n![](//upload-images.jianshu.io/upload_images/11183270-ef3cb072affbec03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/398/format/webp)\n\nimage.png\n\n其中线程线程1-4先占满了核心线程和最大线程数量，然后4、5线程进入等待队列，7-10线程被直接忽略拒绝执行，等1-4线程中有线程执行完后通知4、5线程继续执行。\n\n#### 总结，通过自定义线程池，我们可以更好的让线程池为我们所用，更加适应我的实际场景。\n\n作者：徐志毅\n链接：https://www.jianshu.com/p/f030aa5d7a28\n来源：简书\n简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。"]],[5400,5400],[8165,8165]]],[1566181793530,["david@DESKTOP-9844NL4",[[-1,8076,"作者：徐志毅\n链接：https://www.jianshu.com/p/f030aa5d7a28\n来源：简书\n简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。\n"]],[8076,8166],[8076,8076]]],[1566181793979,["david@DESKTOP-9844NL4",[[-1,8079,"\n"]],[8076,8076],[8075,8075]]],[1566181794802,["david@DESKTOP-9844NL4",[[-1,8078,"\n"]],[8075,8075],[8074,8074]]],[1566181835146,["david@DESKTOP-9844NL4",[[-1,76,"阿里巴巴线程池开发规范"]],[76,87],[76,76]]],[1566181836877,["david@DESKTOP-9844NL4",[[1,76,"E"]],[76,76],[77,77]]],[1566181837363,["david@DESKTOP-9844NL4",[[-1,76,"E"]],[77,77],[76,76]]],[1566181837854,["david@DESKTOP-9844NL4",[[1,76,"YU"]],[76,76],[78,78]]],[1566181838367,["david@DESKTOP-9844NL4",[[-1,76,"YU"]],[78,78],[76,76]]],[1566181851826,["david@DESKTOP-9844NL4",[[1,76,"预定义的线程池便捷创建方法"]],[76,76],[89,89]]],[1566181871090,["david@DESKTOP-9844NL4",[[1,91,"虽然这种创建线程池的方法比较简便，但是"]],[91,91],[110,110]]],[1566181889351,["david@DESKTOP-9844NL4",[[-1,2524,"##### 一、预定义线程池\n\n1.  **FixedThreadPool**\n\n```\n    public static ExecutorService newFixedThreadPool(int nThreads) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue<Runnable>());\n    }\n\n```\n\n> *   corePoolSize与maximumPoolSize相等，即其线程全为核心线程，是一个固定大小的线程池，是其优势；\n> *   keepAliveTime = 0 该参数默认对核心线程无效，而FixedThreadPool全部为核心线程；\n> *   workQueue 为LinkedBlockingQueue（无界阻塞队列），队列最大值为Integer.MAX_VALUE。如果任务提交速度持续大余任务处理速度，会造成队列大量阻塞。因为队列很大，很有可能在拒绝策略前，内存溢出。是其劣势；\n> *   FixedThreadPool的任务执行是无序的；\n\n适用场景：可用于Web服务瞬时削峰，但需注意长时间持续高峰情况造成的队列阻塞。\n\n1.  **CachedThreadPool**\n\n```\n     public static ExecutorService newCachedThreadPool() {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue<Runnable>());\n    }\n\n```\n\n> *   corePoolSize = 0，maximumPoolSize = Integer.MAX_VALUE，即线程数量几乎无限制；\n> *   keepAliveTime = 60s，线程空闲60s后自动结束。\n> *   workQueue 为 SynchronousQueue 同步队列，这个队列类似于一个接力棒，入队出队必须同时传递，因为CachedThreadPool线程创建无限制，不会有队列等待，所以使用SynchronousQueue；\n\n适用场景：快速处理大量耗时较短的任务，如Netty的NIO接受请求时，可使用CachedThreadPool。\n\n1.  **SingleThreadExecutor**\n\n```\n    public static ExecutorService newSingleThreadExecutor() {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>()));\n    }\n\n```\n\n咋一瞅，不就是newFixedThreadPool(1)吗？定眼一看，这里多了一层FinalizableDelegatedExecutorService包装，这一层有什么用呢，写个dome来解释一下：\n\n```\n    public static void main(String[] args) {\n        ExecutorService fixedExecutorService = Executors.newFixedThreadPool(1);\n        ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) fixedExecutorService;\n        System.out.println(threadPoolExecutor.getMaximumPoolSize());\n        threadPoolExecutor.setCorePoolSize(8);\n\n        ExecutorService singleExecutorService = Executors.newSingleThreadExecutor();\n//      运行时异常 java.lang.ClassCastException\n//      ThreadPoolExecutor threadPoolExecutor2 = (ThreadPoolExecutor) singleExecutorService;\n    }\n\n```\n\n对比可以看出，FixedThreadPool可以向下转型为ThreadPoolExecutor，并对其线程池进行配置，而SingleThreadExecutor被包装后，无法成功向下转型。**因此，SingleThreadExecutor被定以后，无法修改，做到了真正的Single。**\n\n1.  **ScheduledThreadPool**\n\n```\n    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {\n        return new ScheduledThreadPoolExecutor(corePoolSize);\n    }\n\n```\n\nnewScheduledThreadPool调用的是ScheduledThreadPoolExecutor的构造方法，而ScheduledThreadPoolExecutor继承了ThreadPoolExecutor，构造是还是调用了其父类的构造方法。\n\n```\n    public ScheduledThreadPoolExecutor(int corePoolSize) {\n        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,\n              new DelayedWorkQueue());\n    }\n\n```"]],[2524,5419],[2524,2524]]],[1566181899689,["david@DESKTOP-9844NL4",[[-1,779,"Thread.newFixedThreadPool(int nThreads)源码\n![mark](http://blog.sjjtcloud.com/blog/20190819/URrvW1kKs3p3.png?imageslim)"]],[779,896],[779,779]]],[1566181900226,["david@DESKTOP-9844NL4",[[1,779,"\\"]],[779,779],[780,780]]],[1566181900740,["david@DESKTOP-9844NL4",[[-1,779,"\\"]],[780,780],[779,779]]],[1566181901225,["david@DESKTOP-9844NL4",[[1,781,"\n"]],[779,779],[780,780]]],[1566181901406,["david@DESKTOP-9844NL4",[[1,782,"\n"]],[780,780],[781,781]]],[1566181902914,["david@DESKTOP-9844NL4",[[1,779,"xiam"]],[779,779],[783,783]]],[1566181903910,["david@DESKTOP-9844NL4",[[-1,779,"xiam"]],[783,783],[779,779]]],[1566181904502,["david@DESKTOP-9844NL4",[[1,779,"##### 一、预定义线程池\n\n1.  **FixedThreadPool**\n\n```\n    public static ExecutorService newFixedThreadPool(int nThreads) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue<Runnable>());\n    }\n\n```\n\n> *   corePoolSize与maximumPoolSize相等，即其线程全为核心线程，是一个固定大小的线程池，是其优势；\n> *   keepAliveTime = 0 该参数默认对核心线程无效，而FixedThreadPool全部为核心线程；\n> *   workQueue 为LinkedBlockingQueue（无界阻塞队列），队列最大值为Integer.MAX_VALUE。如果任务提交速度持续大余任务处理速度，会造成队列大量阻塞。因为队列很大，很有可能在拒绝策略前，内存溢出。是其劣势；\n> *   FixedThreadPool的任务执行是无序的；\n\n适用场景：可用于Web服务瞬时削峰，但需注意长时间持续高峰情况造成的队列阻塞。\n\n1.  **CachedThreadPool**\n\n```\n     public static ExecutorService newCachedThreadPool() {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue<Runnable>());\n    }\n\n```\n\n> *   corePoolSize = 0，maximumPoolSize = Integer.MAX_VALUE，即线程数量几乎无限制；\n> *   keepAliveTime = 60s，线程空闲60s后自动结束。\n> *   workQueue 为 SynchronousQueue 同步队列，这个队列类似于一个接力棒，入队出队必须同时传递，因为CachedThreadPool线程创建无限制，不会有队列等待，所以使用SynchronousQueue；\n\n适用场景：快速处理大量耗时较短的任务，如Netty的NIO接受请求时，可使用CachedThreadPool。\n\n1.  **SingleThreadExecutor**\n\n```\n    public static ExecutorService newSingleThreadExecutor() {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>()));\n    }\n\n```\n\n咋一瞅，不就是newFixedThreadPool(1)吗？定眼一看，这里多了一层FinalizableDelegatedExecutorService包装，这一层有什么用呢，写个dome来解释一下：\n\n```\n    public static void main(String[] args) {\n        ExecutorService fixedExecutorService = Executors.newFixedThreadPool(1);\n        ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) fixedExecutorService;\n        System.out.println(threadPoolExecutor.getMaximumPoolSize());\n        threadPoolExecutor.setCorePoolSize(8);\n\n        ExecutorService singleExecutorService = Executors.newSingleThreadExecutor();\n//      运行时异常 java.lang.ClassCastException\n//      ThreadPoolExecutor threadPoolExecutor2 = (ThreadPoolExecutor) singleExecutorService;\n    }\n\n```\n\n对比可以看出，FixedThreadPool可以向下转型为ThreadPoolExecutor，并对其线程池进行配置，而SingleThreadExecutor被包装后，无法成功向下转型。**因此，SingleThreadExecutor被定以后，无法修改，做到了真正的Single。**\n\n1.  **ScheduledThreadPool**\n\n```\n    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {\n        return new ScheduledThreadPoolExecutor(corePoolSize);\n    }\n\n```\n\nnewScheduledThreadPool调用的是ScheduledThreadPoolExecutor的构造方法，而ScheduledThreadPoolExecutor继承了ThreadPoolExecutor，构造是还是调用了其父类的构造方法。\n\n```\n    public ScheduledThreadPoolExecutor(int corePoolSize) {\n        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,\n              new DelayedWorkQueue());\n    }\n\n```"]],[779,779],[3674,3674]]],[1566181907943,["david@DESKTOP-9844NL4",[[1,793,"jie"]],[793,793],[796,796]]],[1566181908752,["david@DESKTOP-9844NL4",[[-1,793,"jie"]],[796,796],[793,793]]],[1566181910143,["david@DESKTOP-9844NL4",[[1,793,"分析"]],[793,793],[795,795]]],[1566181917080,["david@DESKTOP-9844NL4",[[1,803,"new"]],[803,818],[821,821]]],[1566181924264,["david@DESKTOP-9844NL4",[[1,1444,"new"]],[1444,1460],[1463,1463]]],[1566181934669,["david@DESKTOP-9844NL4",[[-1,783,"# 一、"]],[787,787],[783,783]]],[1566181935701,["david@DESKTOP-9844NL4",[[1,783," "]],[783,783],[784,784]]],[1566181943576,["david@DESKTOP-9844NL4",[[-1,784,"预定义线程池分析"]],[792,792],[784,784]]],[1566181945198,["david@DESKTOP-9844NL4",[[1,784,"便捷"]],[784,784],[786,786]]],[1566181945782,["david@DESKTOP-9844NL4",[[-1,784,"便捷"]],[786,786],[784,784]]],[1566181951302,["david@DESKTOP-9844NL4",[[1,784,"方法分析"]],[784,784],[788,788]]],[1566181955136,["david@DESKTOP-9844NL4",[[-1,784,"方法"]],[786,786],[784,784]]],[1566181957665,["david@DESKTOP-9844NL4",[[1,784,"源码"]],[784,784],[786,786]]],[1566181962721,["david@DESKTOP-9844NL4",[[-1,1431,"1"]],[1432,1432],[1431,1431]]],[1566181962929,["david@DESKTOP-9844NL4",[[1,1431,"2"]],[1431,1431],[1432,1432]]],[1566181978672,["david@DESKTOP-9844NL4",[[1,2024,"new"]],[2024,2044],[2047,2047]]],[1566181980825,["david@DESKTOP-9844NL4",[[-1,2018,"1"]],[2019,2019],[2018,2018]]],[1566181981008,["david@DESKTOP-9844NL4",[[1,2018,"3"]],[2018,2018],[2019,2019]]],[1566181989549,["david@DESKTOP-9844NL4",[[-1,3182,"1"]],[3183,3183],[3182,3182]]],[1566181989759,["david@DESKTOP-9844NL4",[[1,3182,"4"]],[3182,3182],[3183,3183]]],[1566181997205,["david@DESKTOP-9844NL4",[[-1,2024,"new"]],[2027,2027],[2024,2024]]],[1566182001077,["david@DESKTOP-9844NL4",[[-1,1437,"new"]],[1440,1440],[1437,1437]]],[1566182005486,["david@DESKTOP-9844NL4",[[-1,796,"new"]],[799,799],[796,796]]],[1566182023238,["david@DESKTOP-9844NL4",[[1,778,"|     |     |\n"]],[777,777],[779,784]]],[1566182026280,["david@DESKTOP-9844NL4",[[1,781,"ScheduledExecutorService newScheduledThreadPool(int corePoolSize)"]],[781,781],[846,846]]],[1566182031931,["david@DESKTOP-9844NL4",[[-1,780," ScheduledExecutorService "]],[781,806],[780,780]]],[1566183131127,["david@DESKTOP-9844NL4",[[1,825,"此线程池支持定时以及周期性执行任务的需求"]],[825,825],[845,845]]],[1566183174719,["david@DESKTOP-9844NL4",[[-1,83,"便捷创建方法"]],[83,89],[83,83]]],[1566184026601,["david@DESKTOP-9844NL4",[[1,666,"（）"]],[666,666],[668,668]]],[1566184042919,["david@DESKTOP-9844NL4",[[1,667,"请求队列不受限制"]],[667,667],[675,675]]],[1566184048544,["david@DESKTOP-9844NL4",[[1,721,"（请求队列不受限制）"]],[721,721],[731,731]]],[1566184116698,["david@DESKTOP-9844NL4",[[1,789,"（）"]],[789,789],[791,791]]],[1566184124285,["david@DESKTOP-9844NL4",[[1,790,"线程数不受限制"]],[790,790],[797,797]]],[1566184127363,["david@DESKTOP-9844NL4",[[1,868,"（）"]],[868,868],[870,870]]],[1566184130567,["david@DESKTOP-9844NL4",[[1,869,"线程池"]],[869,869],[872,872]]],[1566184138750,["david@DESKTOP-9844NL4",[[-1,871,"池"]],[872,872],[871,871]]],[1566184143148,["david@DESKTOP-9844NL4",[[1,871,"数不受限制"]],[871,871],[876,876]]],[1566184147933,["david@DESKTOP-9844NL4",[[-1,877,"    "]],[881,881],[877,877]]],[1566184603164,["david@DESKTOP-9844NL4",[[-1,72,"### 预定义的线程池\n\n虽然这种创建线程池的方法比较简便，但是阿里巴巴开发规范中,明确指出禁止使用Executors来创建线程,因为这样创建线程池,有可能会导致OOM,  创建线程池应该使用ThreadPoolExecutor的方式, 其实这些创建线程池的方法,背后原理也是使用TreadPoolExecutor来创建的\n\n```\n【强制】\n线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样\n的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。\n说明：Executors 返回的线程池对象的弊端如下：\n\n1）FixedThreadPool 和 SingleThreadPool:\n允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。\n\n2）CachedThreadPool 和 ScheduledThreadPool:\n允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。\n\n```\n\n\n### Executors创建线程池\n\n`Executors`创建线程池方法列表：\n\n| 方法名 | 功能 |\n| --- | --- |\n| newFixedThreadPool(int nThreads) | 创建固定大小的线程池（请求队列不受限制） |\n| newSingleThreadExecutor() | 创建只有一个线程的线程池（请求队列不受限制） |\n| newCachedThreadPool() | 创建一个不限线程数上限的线程池，任何提交的任务都将立即执行（线程数不受限制） |\n| newScheduledThreadPool(int corePoolSize)   | 此线程池支持定时以及周期性执行任务的需求（线程数不受限制）|\n\n#### 源码分析\n\n1.  **FixedThreadPool**\n\n```\n    public static ExecutorService newFixedThreadPool(int nThreads) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue<Runnable>());\n    }\n\n```\n\n> *   corePoolSize与maximumPoolSize相等，即其线程全为核心线程，是一个固定大小的线程池，是其优势；\n> *   keepAliveTime = 0 该参数默认对核心线程无效，而FixedThreadPool全部为核心线程；\n> *   workQueue 为LinkedBlockingQueue（无界阻塞队列），队列最大值为Integer.MAX_VALUE。如果任务提交速度持续大余任务处理速度，会造成队列大量阻塞。因为队列很大，很有可能在拒绝策略前，内存溢出。是其劣势；\n> *   FixedThreadPool的任务执行是无序的；\n\n适用场景：可用于Web服务瞬时削峰，但需注意长时间持续高峰情况造成的队列阻塞。\n\n2.  **CachedThreadPool**\n\n```\n     public static ExecutorService newCachedThreadPool() {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue<Runnable>());\n    }\n\n```\n\n> *   corePoolSize = 0，maximumPoolSize = Integer.MAX_VALUE，即线程数量几乎无限制；\n> *   keepAliveTime = 60s，线程空闲60s后自动结束。\n> *   workQueue 为 SynchronousQueue 同步队列，这个队列类似于一个接力棒，入队出队必须同时传递，因为CachedThreadPool线程创建无限制，不会有队列等待，所以使用SynchronousQueue；\n\n适用场景：快速处理大量耗时较短的任务，如Netty的NIO接受请求时，可使用CachedThreadPool。\n\n3.  **SingleThreadExecutor**\n\n```\n    public static ExecutorService newSingleThreadExecutor() {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>()));\n    }\n\n```\n\n咋一瞅，不就是newFixedThreadPool(1)吗？定眼一看，这里多了一层FinalizableDelegatedExecutorService包装，这一层有什么用呢，写个dome来解释一下：\n\n```\n    public static void main(String[] args) {\n        ExecutorService fixedExecutorService = Executors.newFixedThreadPool(1);\n        ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) fixedExecutorService;\n        System.out.println(threadPoolExecutor.getMaximumPoolSize());\n        threadPoolExecutor.setCorePoolSize(8);\n\n        ExecutorService singleExecutorService = Executors.newSingleThreadExecutor();\n//      运行时异常 java.lang.ClassCastException\n//      ThreadPoolExecutor threadPoolExecutor2 = (ThreadPoolExecutor) singleExecutorService;\n    }\n\n```\n\n对比可以看出，FixedThreadPool可以向下转型为ThreadPoolExecutor，并对其线程池进行配置，而SingleThreadExecutor被包装后，无法成功向下转型。**因此，SingleThreadExecutor被定以后，无法修改，做到了真正的Single。**\n\n4.  **ScheduledThreadPool**\n\n```\n    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {\n        return new ScheduledThreadPoolExecutor(corePoolSize);\n    }\n\n```\n\nnewScheduledThreadPool调用的是ScheduledThreadPoolExecutor的构造方法，而ScheduledThreadPoolExecutor继承了ThreadPoolExecutor，构造是还是调用了其父类的构造方法。\n\n```\n    public ScheduledThreadPoolExecutor(int corePoolSize) {\n        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,\n              new DelayedWorkQueue());\n    }\n\n```\n"]],[72,3771],[72,72]]],[1566184605993,["david@DESKTOP-9844NL4",[[-1,74,"\n"]],[74,74],[73,73]]],[1566184606240,["david@DESKTOP-9844NL4",[[-1,73,"\n"]],[73,73],[72,72]]],[1566184606429,["david@DESKTOP-9844NL4",[[-1,72,"\n"]],[72,72],[71,71]]],[1566184606648,["david@DESKTOP-9844NL4",[[-1,71,"\n"]],[71,71],[70,70]]],[1566184610565,["david@DESKTOP-9844NL4",[[1,1699,"\n"]],[1695,1695],[1696,1696]]],[1566184610844,["david@DESKTOP-9844NL4",[[1,1700,"\n"]],[1696,1696],[1697,1697]]],[1566184611442,["david@DESKTOP-9844NL4",[[1,1697,"### 预定义的线程池\n\n虽然这种创建线程池的方法比较简便，但是阿里巴巴开发规范中,明确指出禁止使用Executors来创建线程,因为这样创建线程池,有可能会导致OOM,  创建线程池应该使用ThreadPoolExecutor的方式, 其实这些创建线程池的方法,背后原理也是使用TreadPoolExecutor来创建的\n\n```\n【强制】\n线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样\n的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。\n说明：Executors 返回的线程池对象的弊端如下：\n\n1）FixedThreadPool 和 SingleThreadPool:\n允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。\n\n2）CachedThreadPool 和 ScheduledThreadPool:\n允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。\n\n```\n\n\n### Executors创建线程池\n\n`Executors`创建线程池方法列表：\n\n| 方法名 | 功能 |\n| --- | --- |\n| newFixedThreadPool(int nThreads) | 创建固定大小的线程池（请求队列不受限制） |\n| newSingleThreadExecutor() | 创建只有一个线程的线程池（请求队列不受限制） |\n| newCachedThreadPool() | 创建一个不限线程数上限的线程池，任何提交的任务都将立即执行（线程数不受限制） |\n| newScheduledThreadPool(int corePoolSize)   | 此线程池支持定时以及周期性执行任务的需求（线程数不受限制）|\n\n#### 源码分析\n\n1.  **FixedThreadPool**\n\n```\n    public static ExecutorService newFixedThreadPool(int nThreads) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue<Runnable>());\n    }\n\n```\n\n> *   corePoolSize与maximumPoolSize相等，即其线程全为核心线程，是一个固定大小的线程池，是其优势；\n> *   keepAliveTime = 0 该参数默认对核心线程无效，而FixedThreadPool全部为核心线程；\n> *   workQueue 为LinkedBlockingQueue（无界阻塞队列），队列最大值为Integer.MAX_VALUE。如果任务提交速度持续大余任务处理速度，会造成队列大量阻塞。因为队列很大，很有可能在拒绝策略前，内存溢出。是其劣势；\n> *   FixedThreadPool的任务执行是无序的；\n\n适用场景：可用于Web服务瞬时削峰，但需注意长时间持续高峰情况造成的队列阻塞。\n\n2.  **CachedThreadPool**\n\n```\n     public static ExecutorService newCachedThreadPool() {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue<Runnable>());\n    }\n\n```\n\n> *   corePoolSize = 0，maximumPoolSize = Integer.MAX_VALUE，即线程数量几乎无限制；\n> *   keepAliveTime = 60s，线程空闲60s后自动结束。\n> *   workQueue 为 SynchronousQueue 同步队列，这个队列类似于一个接力棒，入队出队必须同时传递，因为CachedThreadPool线程创建无限制，不会有队列等待，所以使用SynchronousQueue；\n\n适用场景：快速处理大量耗时较短的任务，如Netty的NIO接受请求时，可使用CachedThreadPool。\n\n3.  **SingleThreadExecutor**\n\n```\n    public static ExecutorService newSingleThreadExecutor() {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>()));\n    }\n\n```\n\n咋一瞅，不就是newFixedThreadPool(1)吗？定眼一看，这里多了一层FinalizableDelegatedExecutorService包装，这一层有什么用呢，写个dome来解释一下：\n\n```\n    public static void main(String[] args) {\n        ExecutorService fixedExecutorService = Executors.newFixedThreadPool(1);\n        ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) fixedExecutorService;\n        System.out.println(threadPoolExecutor.getMaximumPoolSize());\n        threadPoolExecutor.setCorePoolSize(8);\n\n        ExecutorService singleExecutorService = Executors.newSingleThreadExecutor();\n//      运行时异常 java.lang.ClassCastException\n//      ThreadPoolExecutor threadPoolExecutor2 = (ThreadPoolExecutor) singleExecutorService;\n    }\n\n```\n\n对比可以看出，FixedThreadPool可以向下转型为ThreadPoolExecutor，并对其线程池进行配置，而SingleThreadExecutor被包装后，无法成功向下转型。**因此，SingleThreadExecutor被定以后，无法修改，做到了真正的Single。**\n\n4.  **ScheduledThreadPool**\n\n```\n    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {\n        return new ScheduledThreadPoolExecutor(corePoolSize);\n    }\n\n```\n\nnewScheduledThreadPool调用的是ScheduledThreadPoolExecutor的构造方法，而ScheduledThreadPoolExecutor继承了ThreadPoolExecutor，构造是还是调用了其父类的构造方法。\n\n```\n    public ScheduledThreadPoolExecutor(int corePoolSize) {\n        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,\n              new DelayedWorkQueue());\n    }\n\n```\n"]],[1697,1697],[5396,5396]]]],null,"david@DESKTOP-9844NL4"],["38214207-4860-4b85-a835-968a5136ebc9",1566271646146,"\n---\ntitle: 线程池之ThreadPoolExecutor使用\ncategories: java\ntags:\n- 线程池\n---\n\n### ThreadPoolExecutor构造方法\n![mark](http://blog.sjjtcloud.com/blog/20190819/voP4iKK3jVUw.png?imageslim)\n\n\n我们以最后一个构造方法（参数最多的那个），对其参数进行解释：\n\n```\n public ThreadPoolExecutor(int corePoolSize, // 1\n                              int maximumPoolSize,  // 2\n                              long keepAliveTime,  // 3\n                              TimeUnit unit,  // 4\n                              BlockingQueue<Runnable> workQueue, // 5\n                              ThreadFactory threadFactory,  // 6\n                              RejectedExecutionHandler handler ) { //7\n        if (corePoolSize < 0 ||\n            maximumPoolSize <= 0 ||\n            maximumPoolSize < corePoolSize ||\n            keepAliveTime < 0)\n            throw new IllegalArgumentException();\n        if (workQueue == null || threadFactory == null || handler == null)\n            throw new NullPointerException();\n        this.corePoolSize = corePoolSize;\n        this.maximumPoolSize = maximumPoolSize;\n        this.workQueue = workQueue;\n        this.keepAliveTime = unit.toNanos(keepAliveTime);\n        this.threadFactory = threadFactory;\n        this.handler = handler;\n    }\n\n```\n\n| 序号 | 名称 | 类型 | 含义 |\n| --- | --- | --- | --- |\n| 1 | corePoolSize | int | 核心线程池大小 |\n| 2 | maximumPoolSize | int | 最大线程池大小 |\n| 3 | keepAliveTime | long | 线程最大空闲时间 |\n| 4 | unit | TimeUnit | 时间单位 |\n| 5 | workQueue | BlockingQueue<Runnable> | 线程等待队列 |\n| 6 | threadFactory | ThreadFactory | 线程创建工厂 |\n| 7 | handler | RejectedExecutionHandler | 拒绝策略 |\n\n如果对这些参数作用有疑惑的请看 [ThreadPoolExecutor概述](https://www.jianshu.com/p/c41e942bcd64)。\n知道了各个参数的作用后，我们开始构造符合我们期待的线程池。首先看JDK给我们预定义的几种线程池：\n\n### 预定义的线程池\n\n虽然这种创建线程池的方法比较简便，但是阿里巴巴开发规范中,明确指出禁止使用Executors来创建线程,因为这样创建线程池,有可能会导致OOM,  创建线程池应该使用ThreadPoolExecutor的方式, 其实这些创建线程池的方法,背后原理也是使用TreadPoolExecutor来创建的\n\n```\n【强制】\n线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样\n的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。\n说明：Executors 返回的线程池对象的弊端如下：\n\n1）FixedThreadPool 和 SingleThreadPool:\n允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。\n\n2）CachedThreadPool 和 ScheduledThreadPool:\n允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。\n\n```\n\n\n### Executors创建线程池\n\n`Executors`创建线程池方法列表：\n\n| 方法名 | 功能 |\n| --- | --- |\n| newFixedThreadPool(int nThreads) | 创建固定大小的线程池（请求队列不受限制） |\n| newSingleThreadExecutor() | 创建只有一个线程的线程池（请求队列不受限制） |\n| newCachedThreadPool() | 创建一个不限线程数上限的线程池，任何提交的任务都将立即执行（线程数不受限制） |\n| newScheduledThreadPool(int corePoolSize)   | 此线程池支持定时以及周期性执行任务的需求（线程数不受限制）|\n\n#### 源码分析\n\n1.  **FixedThreadPool**\n\n```\n    public static ExecutorService newFixedThreadPool(int nThreads) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue<Runnable>());\n    }\n\n```\n\n> *   corePoolSize与maximumPoolSize相等，即其线程全为核心线程，是一个固定大小的线程池，是其优势；\n> *   keepAliveTime = 0 该参数默认对核心线程无效，而FixedThreadPool全部为核心线程；\n> *   workQueue 为LinkedBlockingQueue（无界阻塞队列），队列最大值为Integer.MAX_VALUE。如果任务提交速度持续大余任务处理速度，会造成队列大量阻塞。因为队列很大，很有可能在拒绝策略前，内存溢出。是其劣势；\n> *   FixedThreadPool的任务执行是无序的；\n\n适用场景：可用于Web服务瞬时削峰，但需注意长时间持续高峰情况造成的队列阻塞。\n\n2.  **CachedThreadPool**\n\n```\n     public static ExecutorService newCachedThreadPool() {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue<Runnable>());\n    }\n\n```\n\n> *   corePoolSize = 0，maximumPoolSize = Integer.MAX_VALUE，即线程数量几乎无限制；\n> *   keepAliveTime = 60s，线程空闲60s后自动结束。\n> *   workQueue 为 SynchronousQueue 同步队列，这个队列类似于一个接力棒，入队出队必须同时传递，因为CachedThreadPool线程创建无限制，不会有队列等待，所以使用SynchronousQueue；\n\n适用场景：快速处理大量耗时较短的任务，如Netty的NIO接受请求时，可使用CachedThreadPool。\n\n3.  **SingleThreadExecutor**\n\n```\n    public static ExecutorService newSingleThreadExecutor() {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>()));\n    }\n\n```\n\n咋一瞅，不就是newFixedThreadPool(1)吗？定眼一看，这里多了一层FinalizableDelegatedExecutorService包装，这一层有什么用呢，写个dome来解释一下：\n\n```\n    public static void main(String[] args) {\n        ExecutorService fixedExecutorService = Executors.newFixedThreadPool(1);\n        ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) fixedExecutorService;\n        System.out.println(threadPoolExecutor.getMaximumPoolSize());\n        threadPoolExecutor.setCorePoolSize(8);\n\n        ExecutorService singleExecutorService = Executors.newSingleThreadExecutor();\n//      运行时异常 java.lang.ClassCastException\n//      ThreadPoolExecutor threadPoolExecutor2 = (ThreadPoolExecutor) singleExecutorService;\n    }\n\n```\n\n对比可以看出，FixedThreadPool可以向下转型为ThreadPoolExecutor，并对其线程池进行配置，而SingleThreadExecutor被包装后，无法成功向下转型。**因此，SingleThreadExecutor被定以后，无法修改，做到了真正的Single。**\n\n4.  **ScheduledThreadPool**\n\n```\n    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {\n        return new ScheduledThreadPoolExecutor(corePoolSize);\n    }\n\n```\n\nnewScheduledThreadPool调用的是ScheduledThreadPoolExecutor的构造方法，而ScheduledThreadPoolExecutor继承了ThreadPoolExecutor，构造是还是调用了其父类的构造方法。\n\n```\n    public ScheduledThreadPoolExecutor(int corePoolSize) {\n        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,\n              new DelayedWorkQueue());\n    }\n\n```\n\n\n\n\n##### 二、自定义线程池\n\n以下是自定义线程池，使用了有界队列，自定义ThreadFactory和拒绝策略的demo：\n\n```\npublic class ThreadTest {\n\n    public static void main(String[] args) throws InterruptedException, IOException {\n        int corePoolSize = 2;\n        int maximumPoolSize = 4;\n        long keepAliveTime = 10;\n        TimeUnit unit = TimeUnit.SECONDS;\n        BlockingQueue<Runnable> workQueue = new ArrayBlockingQueue<>(2);\n        ThreadFactory threadFactory = new NameTreadFactory();\n        RejectedExecutionHandler handler = new MyIgnorePolicy();\n        ThreadPoolExecutor executor = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit,\n                workQueue, threadFactory, handler);\n        executor.prestartAllCoreThreads(); // 预启动所有核心线程\n\n        for (int i = 1; i <= 10; i++) {\n            MyTask task = new MyTask(String.valueOf(i));\n            executor.execute(task);\n        }\n\n        System.in.read(); //阻塞主线程\n    }\n\n    static class NameTreadFactory implements ThreadFactory {\n\n        private final AtomicInteger mThreadNum = new AtomicInteger(1);\n\n        @Override\n        public Thread newThread(Runnable r) {\n            Thread t = new Thread(r, \"my-thread-\" + mThreadNum.getAndIncrement());\n            System.out.println(t.getName() + \" has been created\");\n            return t;\n        }\n    }\n\n    public static class MyIgnorePolicy implements RejectedExecutionHandler {\n\n        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n            doLog(r, e);\n        }\n\n        private void doLog(Runnable r, ThreadPoolExecutor e) {\n            // 可做日志记录等\n            System.err.println( r.toString() + \" rejected\");\n//          System.out.println(\"completedTaskCount: \" + e.getCompletedTaskCount());\n        }\n    }\n\n    static class MyTask implements Runnable {\n        private String name;\n\n        public MyTask(String name) {\n            this.name = name;\n        }\n\n        @Override\n        public void run() {\n            try {\n                System.out.println(this.toString() + \" is running!\");\n                Thread.sleep(3000); //让任务执行慢点\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        @Override\n        public String toString() {\n            return \"MyTask [name=\" + name + \"]\";\n        }\n    }\n}\n\n```\n\n输出结果如下：\n\n![](//upload-images.jianshu.io/upload_images/11183270-ef3cb072affbec03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/398/format/webp)\n\nimage.png\n\n其中线程线程1-4先占满了核心线程和最大线程数量，然后4、5线程进入等待队列，7-10线程被直接忽略拒绝执行，等1-4线程中有线程执行完后通知4、5线程继续执行。\n\n#### 总结，通过自定义线程池，我们可以更好的让线程池为我们所用，更加适应我的实际场景。\n\n\n\n",[[1566271621928,["david@DESKTOP-9844NL4",[[-1,60,"- "]],[62,62],[60,60]]],[1566271622275,["david@DESKTOP-9844NL4",[[-1,59,"\n"]],[60,60],[59,59]]],[1566271623358,["david@DESKTOP-9844NL4",[[1,59," "]],[59,59],[60,60]]],[1566271631623,["david@DESKTOP-9844NL4",[[1,69,"\n"]],[67,67],[68,68]]],[1566271631795,["david@DESKTOP-9844NL4",[[1,70,"\n"]],[68,68],[69,69]]],[1566271632333,["david@DESKTOP-9844NL4",[[1,69,"---\ntitle: 阿里FastJson如何处理返回值中nulll值问题\ntags: java\ncategories: fastJson\n---"]],[69,69],[142,142]]],[1566271654903,["david@DESKTOP-9844NL4",[[-1,69,"---\ntitle: 阿里FastJson如何处理返回值中nulll值问题\ntags: java\ncategories: fastJson\n---"]],[69,142],[69,69]]],[1566271655405,["david@DESKTOP-9844NL4",[[-1,70,"\n"]],[69,69],[68,68]]],[1566271655686,["david@DESKTOP-9844NL4",[[-1,69,"\n"]],[68,68],[67,67]]],[1566271709145,["david@DESKTOP-9844NL4",[[-1,0,"\n---\ntitle: 线程池之ThreadPoolExecutor使用\ncategories: java\ntags: 线程池\n---\n"]],[0,68],[0,0]]],[1566271710199,["david@DESKTOP-9844NL4",[[1,0,"---\ntitle: 阿里FastJson如何处理返回值中nulll值问题\ntags: java\ncategories: fastJson\n---"]],[0,0],[73,73]]],[1566271711540,["david@DESKTOP-9844NL4",[[-1,0,"---\ntitle: 阿里FastJson如何处理返回值中nulll值问题\ntags: java\ncategories: fastJson\n---"]],[73,73],[0,0]]],[1566271712216,["david@DESKTOP-9844NL4",[[1,0,"\n---\ntitle: 线程池之ThreadPoolExecutor使用\ncategories: java\ntags: 线程池\n---\n"]],[0,0],[0,68]]],[1566271713953,["david@DESKTOP-9844NL4",[[1,69,"\n"]],[68,68],[69,69]]],[1566271715401,["david@DESKTOP-9844NL4",[[1,69,"---\ntitle: 阿里FastJson如何处理返回值中nulll值问题\ntags: java\ncategories: fastJson\n---"]],[69,69],[142,142]]],[1566271716250,["david@DESKTOP-9844NL4",[[1,143,"\n"]],[142,142],[143,143]]],[1566271721376,["david@DESKTOP-9844NL4",[[-1,0,"\n"]],[1,1],[0,0]]],[1566271724841,["david@DESKTOP-9844NL4",[[-1,68,"---\ntitle: 阿里FastJson如何处理返回值中nulll值问题\ntags: java\ncategories: fastJson\n---"]],[68,141],[68,68]]],[1566271725118,["david@DESKTOP-9844NL4",[[-1,69,"\n"]],[68,68],[67,67]]],[1566271725521,["david@DESKTOP-9844NL4",[[-1,68,"\n"]],[67,67],[66,66]]],[1566271822396,["david@DESKTOP-9844NL4",[[1,1217,"\n"]],[1216,1216],[1217,1217]]],[1566271822900,["david@DESKTOP-9844NL4",[[1,1218,"\n"]],[1217,1217],[1218,1218]]],[1566271824926,["david@DESKTOP-9844NL4",[[1,1217,"《"]],[1217,1217],[1218,1218]]],[1566271825590,["david@DESKTOP-9844NL4",[[-1,1217,"《"]],[1218,1218],[1217,1217]]],[1566271830620,["david@DESKTOP-9844NL4",[[1,1217,"<!--more-->"]],[1217,1217],[1228,1228]]],[1566271834264,["david@DESKTOP-9844NL4",[[-1,1217,"<!--more-->"]],[1217,1228],[1217,1217]]],[1566271869175,["david@DESKTOP-9844NL4",[[1,1217,"<!-- more -->\n"]],[1217,1217],[1231,1231]]]],null,"david@DESKTOP-9844NL4"]]}