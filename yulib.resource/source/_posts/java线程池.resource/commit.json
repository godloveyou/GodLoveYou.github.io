{"compress":true,"commitItems":[["350aa5b8-ed92-48b4-92ac-d1c83328181a",1566178944450,"",[[1566178897646,["david@DESKTOP-9844NL4",[[1,0,"# java线程池\n\n\n\n"]],[0,0],[12,12]]],[1566178908728,["david@DESKTOP-9844NL4",[[1,0,"\n"]],[0,0],[1,1]]],[1566178909647,["david@DESKTOP-9844NL4",[[1,0,"\n---\ntitle: CenOS7.5使用crontab定时备份数据库脚本\ncategories: LINUX\ntags:\n- Mysql\n---"]],[0,0],[74,74]]],[1566178912422,["david@DESKTOP-9844NL4",[[-1,75,"# java线程池"]],[75,84],[75,75]]],[1566178912810,["david@DESKTOP-9844NL4",[[-1,78,"\n"]],[75,75],[74,74]]],[1566178919912,["david@DESKTOP-9844NL4",[[-1,65,"Mysql"],[1,70,"线程池"]],[65,65],[68,68]]],[1566178924054,["david@DESKTOP-9844NL4",[[-1,51,"LINUX"],[1,56,"java"]],[51,56],[55,55]]],[1566178926982,["david@DESKTOP-9844NL4",[[-1,12,"CenOS7.5使用crontab定时备份数据库脚本"]],[12,38],[12,12]]],[1566178928415,["david@DESKTOP-9844NL4",[[1,12,"xia"]],[12,12],[15,15]]],[1566178929132,["david@DESKTOP-9844NL4",[[-1,12,"xia"]],[15,15],[12,12]]],[1566178939417,["david@DESKTOP-9844NL4",[[1,12,"# 线程池之ThreadPoolExecutor使用"]],[12,12],[38,38]]],[1566178941980,["david@DESKTOP-9844NL4",[[-1,12,"# "]],[13,13],[12,12]]],[1566178946777,["david@DESKTOP-9844NL4",[[1,73,"\n"]],[70,70],[71,71]]],[1566178947013,["david@DESKTOP-9844NL4",[[1,74,"\n"]],[71,71],[72,72]]],[1566179000005,["david@DESKTOP-9844NL4",[[1,71,"### Executors创建线程池\n\nJava中创建线程池很简单，只需要调用`Executors`中相应的便捷方法即可，比如`Executors.newFixedThreadPool(int nThreads)`，但是便捷不仅隐藏了复杂性，也为我们埋下了潜在的隐患（OOM，线程耗尽）。\n\n`Executors`创建线程池便捷方法列表：\n\n| 方法名 | 功能 |\n| --- | --- |\n| newFixedThreadPool(int nThreads) | 创建固定大小的线程池 |\n| newSingleThreadExecutor() | 创建只有一个线程的线程池 |\n| newCachedThreadPool() | 创建一个不限线程数上限的线程池，任何提交的任务都将立即执行 |\n\n小程序使用这些快捷方法没什么问题，对于服务端需要长期运行的程序，创建线程池应该直接使用`ThreadPoolExecutor`的构造方法。没错，上述`Executors`方法创建的线程池就是`ThreadPoolExecutor`。\n\n### ThreadPoolExecutor构造方法"]],[71,71],[567,567]]],[1566179058950,["david@DESKTOP-9844NL4",[[-1,214,"。"]],[215,215],[214,214]]],[1566179060743,["david@DESKTOP-9844NL4",[[1,214,". x"]],[214,214],[217,217]]],[1566179061159,["david@DESKTOP-9844NL4",[[-1,216,"x"]],[217,217],[216,216]]],[1566179067980,["david@DESKTOP-9844NL4",[[1,216,"阿里巴巴开发者规范中"]],[216,216],[226,226]]],[1566179069694,["david@DESKTOP-9844NL4",[[1,226,",不"]],[226,226],[228,228]]],[1566179072155,["david@DESKTOP-9844NL4",[[-1,216,"阿里巴巴开发者规范中,不"]],[228,228],[216,216]]],[1566179087088,["david@DESKTOP-9844NL4",[[1,216,"因此阿里巴巴java开发规范中也明确指出:"]],[216,216],[237,237]]],[1566179087430,["david@DESKTOP-9844NL4",[[1,239,"\n"]],[237,237],[238,238]]],[1566179166925,["david@DESKTOP-9844NL4",[[-1,214,". 因此阿里巴巴java开发规范中也明确指出:"]],[216,237],[214,214]]],[1566179168250,["david@DESKTOP-9844NL4",[[1,214,","]],[214,214],[215,215]]],[1566179168711,["david@DESKTOP-9844NL4",[[-1,214,","]],[215,215],[214,214]]],[1566180854400,["david@DESKTOP-9844NL4",[[1,217,"\n"]],[214,214],[215,215]]],[1566180860718,["david@DESKTOP-9844NL4",[[1,215,"阿里巴巴开发规范中，"]],[215,215],[225,225]]],[1566180861292,["david@DESKTOP-9844NL4",[[-1,224,"，"]],[225,225],[224,224]]],[1566180862072,["david@DESKTOP-9844NL4",[[1,224,",Ye"]],[224,224],[227,227]]],[1566180862706,["david@DESKTOP-9844NL4",[[-1,225,"Ye"]],[227,227],[225,225]]],[1566180883749,["david@DESKTOP-9844NL4",[[1,225,"也明确指出禁止使用Executors来创建线程,"]],[225,225],[249,249]]],[1566180884342,["david@DESKTOP-9844NL4",[[-1,248,","]],[249,249],[248,248]]],[1566180885085,["david@DESKTOP-9844NL4",[[1,251,"\n"]],[248,248],[249,249]]],[1566180885745,["david@DESKTOP-9844NL4",[[1,249,"![mark](http://blog.sjjtcloud.com/blog/20190819/q0PHMznUCrBk.png?imageslim)"]],[249,249],[324,324]]],[1566180896005,["david@DESKTOP-9844NL4",[[1,215,"\n"]],[215,215],[216,216]]],[1566180932563,["david@DESKTOP-9844NL4",[[-1,91,"Java中创建线程池很简单，只需要调用`Executors`中相应的便捷方法即可，比如`Executors.newFixedThreadPool(int nThreads)`，但是便捷不仅隐藏了复杂性，也为我们埋下了潜在的隐患（OOM，线程耗尽）\n"]],[90,214],[90,90]]],[1566180933261,["david@DESKTOP-9844NL4",[[-1,91,"\n"]],[90,90],[89,89]]],[1566180935867,["david@DESKTOP-9844NL4",[[1,91,"\n"]],[89,89],[90,90]]],[1566180939391,["david@DESKTOP-9844NL4",[[-1,92,"阿里巴巴开发规范中,也明确指出禁止使用Executors来创建线程\n![mark](http://blog.sjjtcloud.com/blog/20190819/q0PHMznUCrBk.png?imageslim)\n"]],[92,202],[92,92]]],[1566180940688,["david@DESKTOP-9844NL4",[[-1,93,"\n"]],[93,93],[92,92]]],[1566180940930,["david@DESKTOP-9844NL4",[[-1,92,"\n"]],[92,92],[91,91]]],[1566180941186,["david@DESKTOP-9844NL4",[[-1,91,"\n"]],[91,91],[90,90]]],[1566180947189,["david@DESKTOP-9844NL4",[[-1,107,"便捷"]],[107,109],[107,107]]],[1566180973691,["david@DESKTOP-9844NL4",[[1,295,"\n"]],[294,294],[295,295]]],[1566180973882,["david@DESKTOP-9844NL4",[[1,296,"\n"]],[295,295],[296,296]]],[1566180975673,["david@DESKTOP-9844NL4",[[1,295,"但是"]],[295,295],[297,297]]],[1566180977083,["david@DESKTOP-9844NL4",[[-1,295,"但是"]],[297,297],[295,295]]],[1566180992131,["david@DESKTOP-9844NL4",[[1,295,"阿里巴巴开发规范中,关于线程池部分,是这样的"]],[295,295],[317,317]]],[1566180994259,["david@DESKTOP-9844NL4",[[-1,312,",是这样的"]],[317,317],[312,312]]],[1566180995014,["david@DESKTOP-9844NL4",[[1,314,"\n"]],[312,312],[313,313]]],[1566180995376,["david@DESKTOP-9844NL4",[[1,313,"阿里巴巴开发规范中,也明确指出禁止使用Executors来创建线程\n![mark](http://blog.sjjtcloud.com/blog/20190819/q0PHMznUCrBk.png?imageslim)\n"]],[313,313],[423,423]]],[1566181001130,["david@DESKTOP-9844NL4",[[-1,295,"阿里巴巴开发规范中,关于线程池部分"]],[295,312],[295,295]]],[1566181003859,["david@DESKTOP-9844NL4",[[-1,306,"也"]],[307,307],[306,306]]],[1566181020353,["david@DESKTOP-9844NL4",[[1,329,"\n"]],[328,328],[329,329]]],[1566181020525,["david@DESKTOP-9844NL4",[[1,330,"\n"]],[329,329],[330,330]]],[1566181023481,["david@DESKTOP-9844NL4",[[1,329,"//"]],[329,329],[331,331]]],[1566181024022,["david@DESKTOP-9844NL4",[[-1,329,"//"]],[331,331],[329,329]]],[1566181025199,["david@DESKTOP-9844NL4",[[1,329,">>"]],[329,329],[331,331]]],[1566181025754,["david@DESKTOP-9844NL4",[[-1,329,">>"]],[331,331],[329,329]]],[1566181026280,["david@DESKTOP-9844NL4",[[1,329,".."]],[329,329],[331,331]]],[1566181026880,["david@DESKTOP-9844NL4",[[-1,329,".."]],[331,331],[329,329]]],[1566181031863,["david@DESKTOP-9844NL4",[[1,329,"【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样\n的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。\n说明：Executors 返回的线程池对象的弊端如下：\n1）FixedThreadPool 和 SingleThreadPool:\n允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。\n2）CachedThreadPool 和 ScheduledThreadPool:\n允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。\r"]],[329,329],[629,629]]],[1566181033929,["david@DESKTOP-9844NL4",[[-1,329,"【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样\n的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。\n说明：Executors 返回的线程池对象的弊端如下：\n1）FixedThreadPool 和 SingleThreadPool:\n允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。\n2）CachedThreadPool 和 ScheduledThreadPool:\n允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。\r"]],[629,629],[329,329]]],[1566181035314,["david@DESKTOP-9844NL4",[[1,329,"`1`"]],[329,329],[332,332]]],[1566181036365,["david@DESKTOP-9844NL4",[[-1,330,"1`"]],[332,332],[330,330]]],[1566181036970,["david@DESKTOP-9844NL4",[[1,330,"``"]],[330,330],[332,332]]],[1566181036994,["david@DESKTOP-9844NL4",[[1,332,"language\n```\n"]],[332,332],[332,340]]],[1566181039057,["david@DESKTOP-9844NL4",[[-1,332,"language"]],[332,340],[332,332]]],[1566181039371,["david@DESKTOP-9844NL4",[[1,333,"\n"]],[332,332],[333,333]]],[1566181039813,["david@DESKTOP-9844NL4",[[1,333,"【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样\n的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。\n说明：Executors 返回的线程池对象的弊端如下：\n1）FixedThreadPool 和 SingleThreadPool:\n允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。\n2）CachedThreadPool 和 ScheduledThreadPool:\n允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。\r"]],[333,333],[633,633]]],[1566181044550,["david@DESKTOP-9844NL4",[[-1,638,"\n\n![mark](http://blog.sjjtcloud.com/blog/20190819/q0PHMznUCrBk.png?imageslim"]],[638,714],[638,638]]],[1566181044827,["david@DESKTOP-9844NL4",[[-1,637,"\n"]],[638,638],[637,637]]],[1566181045278,["david@DESKTOP-9844NL4",[[-1,636,"`"]],[637,637],[636,636]]],[1566181050781,["david@DESKTOP-9844NL4",[[1,329,"\n"]],[328,328],[329,329]]],[1566181063313,["david@DESKTOP-9844NL4",[[1,328,","],[-1,633,"\r"]],[328,328],[329,329]]],[1566181064320,["david@DESKTOP-9844NL4",[[1,329,"yin"]],[329,329],[332,332]]],[1566181065054,["david@DESKTOP-9844NL4",[[-1,329,"yin"]],[332,332],[329,329]]],[1566181066791,["david@DESKTOP-9844NL4",[[1,329,"因为有"]],[329,329],[332,332]]],[1566181067049,["david@DESKTOP-9844NL4",[[-1,331,"有"]],[332,332],[331,331]]],[1566181068718,["david@DESKTOP-9844NL4",[[1,331,"这样做"]],[331,331],[334,334]]],[1566181069089,["david@DESKTOP-9844NL4",[[-1,333,"做"]],[334,334],[333,333]]],[1566181073640,["david@DESKTOP-9844NL4",[[1,333,"创建线程池,You"]],[333,333],[342,342]]],[1566181074088,["david@DESKTOP-9844NL4",[[-1,341,"u"]],[342,342],[341,341]]],[1566181074417,["david@DESKTOP-9844NL4",[[-1,339,"Yo"]],[341,341],[339,339]]],[1566181080654,["david@DESKTOP-9844NL4",[[1,339,"有OOM的"]],[339,339],[344,344]]],[1566181082674,["david@DESKTOP-9844NL4",[[-1,340,"OOM的"]],[344,344],[340,340]]],[1566181090193,["david@DESKTOP-9844NL4",[[1,340,"可能会导致OOM，"]],[340,340],[349,349]]],[1566181090831,["david@DESKTOP-9844NL4",[[-1,348,"，"]],[349,349],[348,348]]],[1566181095570,["david@DESKTOP-9844NL4",[[1,348,", chu"]],[348,348],[353,353]]],[1566181097897,["david@DESKTOP-9844NL4",[[-1,348,", chu"]],[353,353],[348,348]]],[1566181098233,["david@DESKTOP-9844NL4",[[1,348,"，"]],[348,348],[349,349]]],[1566181098866,["david@DESKTOP-9844NL4",[[-1,348,"，"]],[349,349],[348,348]]],[1566181101709,["david@DESKTOP-9844NL4",[[1,348,",因此创建"]],[348,348],[353,353]]],[1566181102571,["david@DESKTOP-9844NL4",[[-1,348,",因此创建"]],[353,353],[348,348]]],[1566181107963,["david@DESKTOP-9844NL4",[[-1,659,"\n小程序使用这些快捷方法没什么问题，对于服务端需要长期运行的程序，创建线程池应该直接使用`ThreadPoolExecutor`的构造方法。没错，上述`Executors`方法创建的线程池就是`ThreadPoolExecutor`。\n\n"]],[658,777],[658,658]]],[1566181108285,["david@DESKTOP-9844NL4",[[-1,658,"\n"]],[658,658],[657,657]]],[1566181108824,["david@DESKTOP-9844NL4",[[1,658,"\n"]],[657,657],[658,658]]],[1566181109020,["david@DESKTOP-9844NL4",[[1,659,"\n"]],[658,658],[659,659]]],[1566181131243,["david@DESKTOP-9844NL4",[[1,660,"\n"]],[658,658],[659,659]]],[1566181131434,["david@DESKTOP-9844NL4",[[1,661,"\n"]],[659,659],[660,660]]],[1566181132976,["david@DESKTOP-9844NL4",[[1,659,"zix"]],[659,659],[662,662]]],[1566181133619,["david@DESKTOP-9844NL4",[[-1,659,"zix"]],[662,662],[659,659]]],[1566181135539,["david@DESKTOP-9844NL4",[[1,659,"自诩"]],[659,659],[661,661]]],[1566181135934,["david@DESKTOP-9844NL4",[[-1,659,"自诩"]],[661,661],[659,659]]],[1566181143789,["david@DESKTOP-9844NL4",[[1,659,"通过分析Exc"]],[659,659],[666,666]]],[1566181145427,["david@DESKTOP-9844NL4",[[-1,665,"c"]],[666,666],[665,665]]],[1566181150395,["david@DESKTOP-9844NL4",[[1,665,"ecutors的源码，faxia"]],[665,665],[681,681]]],[1566181151426,["david@DESKTOP-9844NL4",[[-1,675,"，faxia"]],[681,681],[675,675]]],[1566181152525,["david@DESKTOP-9844NL4",[[1,675,"，fa"]],[675,675],[678,678]]],[1566181153228,["david@DESKTOP-9844NL4",[[-1,675,"，fa"]],[678,678],[675,675]]],[1566181157360,["david@DESKTOP-9844NL4",[[1,348,",yin"]],[348,348],[352,352]]],[1566181157960,["david@DESKTOP-9844NL4",[[-1,349,"yin"]],[352,352],[349,349]]],[1566181159127,["david@DESKTOP-9844NL4",[[1,349," tic"]],[349,349],[353,353]]],[1566181159812,["david@DESKTOP-9844NL4",[[-1,350,"tic"]],[353,353],[350,350]]],[1566181163963,["david@DESKTOP-9844NL4",[[1,350," yin"]],[350,350],[354,354]]],[1566181164568,["david@DESKTOP-9844NL4",[[-1,351,"yin"]],[354,354],[351,351]]],[1566181165693,["david@DESKTOP-9844NL4",[[1,351,"应该"]],[351,351],[353,353]]],[1566181166112,["david@DESKTOP-9844NL4",[[-1,351,"应该"]],[353,353],[351,351]]],[1566181167502,["david@DESKTOP-9844NL4",[[1,351,"创建"]],[351,351],[353,353]]],[1566181168165,["david@DESKTOP-9844NL4",[[-1,351,"创建"]],[353,353],[351,351]]],[1566181176396,["david@DESKTOP-9844NL4",[[1,351,"创建线程池应该使用ThreadPoolExecutor de"]],[351,351],[381,381]]],[1566181177206,["david@DESKTOP-9844NL4",[[-1,378," de"]],[381,381],[378,378]]],[1566181182511,["david@DESKTOP-9844NL4",[[1,378,"的方式,"]],[378,378],[382,382]]],[1566181182907,["david@DESKTOP-9844NL4",[[-1,381,","]],[382,382],[381,381]]],[1566181189462,["david@DESKTOP-9844NL4",[[1,692,"\n"]],[690,690],[691,691]]],[1566181191268,["david@DESKTOP-9844NL4",[[1,691,"```"]],[691,691],[694,694]]],[1566181192884,["david@DESKTOP-9844NL4",[[1,696,"\n"]],[694,694],[695,695]]],[1566181193084,["david@DESKTOP-9844NL4",[[1,697,"\n"]],[695,695],[696,696]]],[1566181197875,["david@DESKTOP-9844NL4",[[-1,687,"``)"]],[690,690],[687,687]]],[1566181202825,["david@DESKTOP-9844NL4",[[1,391,"\n"]],[391,391],[392,392]]],[1566181208634,["david@DESKTOP-9844NL4",[[1,508,"\n"]],[508,508],[509,509]]],[1566181210725,["david@DESKTOP-9844NL4",[[1,597,"\n"]],[597,597],[598,598]]],[1566181250311,["david@DESKTOP-9844NL4",[[-1,716,"\n"]],[714,715],[714,714]]],[1566181253168,["david@DESKTOP-9844NL4",[[-1,698,"通过分析Executors的源码"]],[714,714],[698,698]]],[1566181253331,["david@DESKTOP-9844NL4",[[-1,699,"\n"]],[698,698],[697,697]]],[1566181254529,["david@DESKTOP-9844NL4",[[-1,698,"\n"]],[697,697],[696,696]]],[1566181258051,["david@DESKTOP-9844NL4",[[1,381,", yi"]],[381,381],[385,385]]],[1566181258645,["david@DESKTOP-9844NL4",[[-1,383,"yi"]],[385,385],[383,383]]],[1566181266352,["david@DESKTOP-9844NL4",[[1,383,"其实Executors创建"]],[383,383],[396,396]]],[1566181266977,["david@DESKTOP-9844NL4",[[-1,394,"创建"]],[396,396],[394,394]]],[1566181278760,["david@DESKTOP-9844NL4",[[1,394,"这些便捷的方法，背后也是在使用![mark](http://blog.sjjtcloud.com/blog/20190819/URrvW1kKs3p3.png?imageslim)"]],[394,394],[484,484]]],[1566181280053,["david@DESKTOP-9844NL4",[[-1,394,"这些便捷的方法，背后也是在使用![mark](http://blog.sjjtcloud.com/blog/20190819/URrvW1kKs3p3.png?imageslim)"]],[484,484],[394,394]]],[1566181283360,["david@DESKTOP-9844NL4",[[1,394,"。"]],[394,394],[395,395]]],[1566181290619,["david@DESKTOP-9844NL4",[[-1,385,"Executors。"]],[395,395],[385,385]]],[1566181300265,["david@DESKTOP-9844NL4",[[1,385,"这些创建线程池的方法，背后"]],[385,385],[398,398]]],[1566181300817,["david@DESKTOP-9844NL4",[[-1,395,"，背后"]],[398,398],[395,395]]],[1566181311237,["david@DESKTOP-9844NL4",[[1,395,",背后原理也是使用Tree"]],[395,395],[408,408]]],[1566181311714,["david@DESKTOP-9844NL4",[[-1,407,"e"]],[408,408],[407,407]]],[1566181314083,["david@DESKTOP-9844NL4",[[1,407,"adPoolEx"]],[407,407],[415,415]]],[1566181321436,["david@DESKTOP-9844NL4",[[1,415,"ecutors构造器"]],[415,415],[425,425]]],[1566181323043,["david@DESKTOP-9844NL4",[[-1,421,"s构造器"]],[425,425],[421,421]]],[1566181328554,["david@DESKTOP-9844NL4",[[1,421,"来创建的，因此"]],[421,421],[428,428]]],[1566181330686,["david@DESKTOP-9844NL4",[[-1,425,"，因此"]],[428,428],[425,425]]],[1566181342320,["david@DESKTOP-9844NL4",[[1,425,",因此浙西简单的创建线程池的房"]],[425,425],[440,440]]],[1566181343412,["david@DESKTOP-9844NL4",[[-1,439,"房"]],[440,440],[439,439]]],[1566181349287,["david@DESKTOP-9844NL4",[[1,439,"方法，用以小的程序"]],[439,439],[448,448]]],[1566181356191,["david@DESKTOP-9844NL4",[[-1,425,",因此浙西简单的创建线程池的方法，用以小的程序"]],[448,448],[425,425]]],[1566181359333,["david@DESKTOP-9844NL4",[[1,742,"\n"]],[739,739],[740,740]]],[1566181360340,["david@DESKTOP-9844NL4",[[1,739,"T"]],[739,739],[740,740]]],[1566181360807,["david@DESKTOP-9844NL4",[[1,744,"\n"]],[740,740],[741,741]]],[1566181361317,["david@DESKTOP-9844NL4",[[-1,744,"\n"]],[741,741],[740,740]]],[1566181361515,["david@DESKTOP-9844NL4",[[-1,739,"T"]],[740,740],[739,739]]],[1566181361903,["david@DESKTOP-9844NL4",[[1,743,"\n"]],[739,739],[740,740]]],[1566181368864,["david@DESKTOP-9844NL4",[[1,740,"Thread.new Fi"]],[740,740],[753,753]]],[1566181369590,["david@DESKTOP-9844NL4",[[-1,750," Fi"]],[753,753],[750,750]]],[1566181370554,["david@DESKTOP-9844NL4",[[1,750,"f"]],[750,750],[751,751]]],[1566181370969,["david@DESKTOP-9844NL4",[[-1,750,"f"]],[751,751],[750,750]]],[1566181372120,["david@DESKTOP-9844NL4",[[1,750,"f"]],[750,750],[751,751]]],[1566181372477,["david@DESKTOP-9844NL4",[[-1,750,"f"]],[751,751],[750,750]]],[1566181373291,["david@DESKTOP-9844NL4",[[1,750,"File"]],[750,750],[754,754]]],[1566181373958,["david@DESKTOP-9844NL4",[[-1,753,"e"]],[754,754],[753,753]]],[1566181375559,["david@DESKTOP-9844NL4",[[-1,752,"l"]],[753,753],[752,752]]],[1566181384065,["david@DESKTOP-9844NL4",[[1,752,"xedThreadPool()"]],[752,752],[767,767]]],[1566181388296,["david@DESKTOP-9844NL4",[[1,766,"int poolS"]],[766,766],[775,775]]],[1566181389889,["david@DESKTOP-9844NL4",[[-1,770,"poolS"]],[775,775],[770,770]]],[1566181390319,["david@DESKTOP-9844NL4",[[1,770,"N"]],[770,770],[771,771]]],[1566181391022,["david@DESKTOP-9844NL4",[[-1,770,"N"]],[771,771],[770,770]]],[1566181392794,["david@DESKTOP-9844NL4",[[1,770,"nThrea"]],[770,770],[776,776]]],[1566181393376,["david@DESKTOP-9844NL4",[[-1,775,"a"]],[776,776],[775,775]]],[1566181394526,["david@DESKTOP-9844NL4",[[1,775,"ads"]],[775,775],[778,778]]],[1566181398426,["david@DESKTOP-9844NL4",[[1,779,"源码"]],[779,779],[781,781]]],[1566181399256,["david@DESKTOP-9844NL4",[[1,785,"\n"]],[781,781],[782,782]]],[1566181399581,["david@DESKTOP-9844NL4",[[1,782,"newFixedThreadPool"]],[782,782],[800,800]]],[1566181405742,["david@DESKTOP-9844NL4",[[-1,782,"newFixedThreadPool"]],[782,800],[782,782]]],[1566181405993,["david@DESKTOP-9844NL4",[[1,782,"![mark](http://blog.sjjtcloud.com/blog/20190819/URrvW1kKs3p3.png?imageslim)"]],[782,782],[857,857]]],[1566181423150,["david@DESKTOP-9844NL4",[[-1,860,"\n"]],[860,860],[859,859]]],[1566181423428,["david@DESKTOP-9844NL4",[[-1,859,"\n"]],[859,859],[858,858]]],[1566181436512,["david@DESKTOP-9844NL4",[[-1,427,"```\n【强制】\n线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样\n的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。\n说明：Executors 返回的线程池对象的弊端如下：\n\n1）FixedThreadPool 和 SingleThreadPool:\n允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。\n\n2）CachedThreadPool 和 ScheduledThreadPool:\n允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。\n\n```"]],[427,738],[427,427]]],[1566181441702,["david@DESKTOP-9844NL4",[[1,71,"\n"]],[70,70],[71,71]]],[1566181441892,["david@DESKTOP-9844NL4",[[1,72,"\n"]],[71,71],[72,72]]],[1566181456969,["david@DESKTOP-9844NL4",[[1,71,"### 阿里巴巴线程池开发规范"]],[71,71],[86,86]]],[1566181457256,["david@DESKTOP-9844NL4",[[1,88,"\n"]],[86,86],[87,87]]],[1566181457910,["david@DESKTOP-9844NL4",[[1,87,"```\n【强制】\n线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样\n的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。\n说明：Executors 返回的线程池对象的弊端如下：\n\n1）FixedThreadPool 和 SingleThreadPool:\n允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。\n\n2）CachedThreadPool 和 ScheduledThreadPool:\n允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。\n\n```"]],[87,87],[398,398]]],[1566181458587,["david@DESKTOP-9844NL4",[[1,400,"\n"]],[398,398],[399,399]]],[1566181465388,["david@DESKTOP-9844NL4",[[1,71,"\n"]],[70,70],[71,71]]],[1566181472875,["david@DESKTOP-9844NL4",[[1,88,"\n"]],[87,87],[88,88]]],[1566181486909,["david@DESKTOP-9844NL4",[[-1,124,"过 "]],[126,126],[124,124]]],[1566181488882,["david@DESKTOP-9844NL4",[[1,124,"过 "]],[124,124],[126,126]]],[1566181500213,["david@DESKTOP-9844NL4",[[-1,628,"阿里巴巴开发规范中,明确指出禁止使用Executors来创建线程,因为这样创建线程池,有可能会导致OOM,  创建线程池应该使用ThreadPoolExecutor的方式, 其实这些创建线程池的方法,背后原理也是使用TreadPoolExecutor来创建的\n"]],[628,758],[628,628]]],[1566181503597,["david@DESKTOP-9844NL4",[[1,89,"\n"]],[88,88],[89,89]]],[1566181504029,["david@DESKTOP-9844NL4",[[1,89,"阿里巴巴开发规范中,明确指出禁止使用Executors来创建线程,因为这样创建线程池,有可能会导致OOM,  创建线程池应该使用ThreadPoolExecutor的方式, 其实这些创建线程池的方法,背后原理也是使用TreadPoolExecutor来创建的\n"]],[89,89],[219,219]]],[1566181512401,["david@DESKTOP-9844NL4",[[-1,761,"\n"]],[761,761],[760,760]]],[1566181512619,["david@DESKTOP-9844NL4",[[-1,760,"\n"]],[760,760],[759,759]]],[1566181512807,["david@DESKTOP-9844NL4",[[-1,759,"\n"]],[759,759],[758,758]]],[1566181513012,["david@DESKTOP-9844NL4",[[-1,758,"\n"]],[758,758],[757,757]]],[1566181519633,["david@DESKTOP-9844NL4",[[1,907,"\n"]],[903,903],[904,904]]],[1566181539792,["david@DESKTOP-9844NL4",[[1,904,"![mark](http://blog.sjjtcloud.com/blog/20190819/voP4iKK3jVUw.png?imageslim)"]],[904,904],[979,979]]],[1566181544433,["david@DESKTOP-9844NL4",[[1,983,"\n"]],[979,979],[980,980]]],[1566181544623,["david@DESKTOP-9844NL4",[[1,984,"\n"]],[980,980],[981,981]]],[1566181637392,["david@DESKTOP-9844NL4",[[-1,533,"\n"]],[533,533],[532,532]]],[1566181637881,["david@DESKTOP-9844NL4",[[1,533,"\n"]],[532,532],[533,533]]],[1566181661047,["david@DESKTOP-9844NL4",[[1,985,"\n"]],[979,979],[980,980]]],[1566181661242,["david@DESKTOP-9844NL4",[[1,986,"\n"]],[980,980],[981,981]]],[1566181661408,["david@DESKTOP-9844NL4",[[1,987,"\n"]],[981,981],[982,982]]],[1566181661829,["david@DESKTOP-9844NL4",[[1,982,"我们以最后一个构造方法（参数最多的那个），对其参数进行解释：\n\n```\n public ThreadPoolExecutor(int corePoolSize, // 1\n                              int maximumPoolSize,  // 2\n                              long keepAliveTime,  // 3\n                              TimeUnit unit,  // 4\n                              BlockingQueue<Runnable> workQueue, // 5\n                              ThreadFactory threadFactory,  // 6\n                              RejectedExecutionHandler handler ) { //7\n        if (corePoolSize < 0 ||\n            maximumPoolSize <= 0 ||\n            maximumPoolSize < corePoolSize ||\n            keepAliveTime < 0)\n            throw new IllegalArgumentException();\n        if (workQueue == null || threadFactory == null || handler == null)\n            throw new NullPointerException();\n        this.corePoolSize = corePoolSize;\n        this.maximumPoolSize = maximumPoolSize;\n        this.workQueue = workQueue;\n        this.keepAliveTime = unit.toNanos(keepAliveTime);\n        this.threadFactory = threadFactory;\n        this.handler = handler;\n    }\n\n```\n\n| 序号 | 名称 | 类型 | 含义 |\n| --- | --- | --- | --- |\n| 1 | corePoolSize | int | 核心线程池大小 |\n| 2 | maximumPoolSize | int | 最大线程池大小 |\n| 3 | keepAliveTime | long | 线程最大空闲时间 |\n| 4 | unit | TimeUnit | 时间单位 |\n| 5 | workQueue | BlockingQueue<Runnable> | 线程等待队列 |\n| 6 | threadFactory | ThreadFactory | 线程创建工厂 |\n| 7 | handler | RejectedExecutionHandler | 拒绝策略 |\n\n如果对这些参数作用有疑惑的请看 [ThreadPoolExecutor概述](https://www.jianshu.com/p/c41e942bcd64)。\n知道了各个参数的作用后，我们开始构造符合我们期待的线程池。首先看JDK给我们预定义的几种线程池：\n\n##### 一、预定义线程池\n\n1.  **FixedThreadPool**\n\n```\n    public static ExecutorService newFixedThreadPool(int nThreads) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue<Runnable>());\n    }\n\n```\n\n> *   corePoolSize与maximumPoolSize相等，即其线程全为核心线程，是一个固定大小的线程池，是其优势；\n> *   keepAliveTime = 0 该参数默认对核心线程无效，而FixedThreadPool全部为核心线程；\n> *   workQueue 为LinkedBlockingQueue（无界阻塞队列），队列最大值为Integer.MAX_VALUE。如果任务提交速度持续大余任务处理速度，会造成队列大量阻塞。因为队列很大，很有可能在拒绝策略前，内存溢出。是其劣势；\n> *   FixedThreadPool的任务执行是无序的；\n\n适用场景：可用于Web服务瞬时削峰，但需注意长时间持续高峰情况造成的队列阻塞。\n\n1.  **CachedThreadPool**\n\n```\n     public static ExecutorService newCachedThreadPool() {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue<Runnable>());\n    }\n\n```\n\n> *   corePoolSize = 0，maximumPoolSize = Integer.MAX_VALUE，即线程数量几乎无限制；\n> *   keepAliveTime = 60s，线程空闲60s后自动结束。\n> *   workQueue 为 SynchronousQueue 同步队列，这个队列类似于一个接力棒，入队出队必须同时传递，因为CachedThreadPool线程创建无限制，不会有队列等待，所以使用SynchronousQueue；\n\n适用场景：快速处理大量耗时较短的任务，如Netty的NIO接受请求时，可使用CachedThreadPool。\n\n1.  **SingleThreadExecutor**\n\n```\n    public static ExecutorService newSingleThreadExecutor() {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>()));\n    }\n\n```\n\n咋一瞅，不就是newFixedThreadPool(1)吗？定眼一看，这里多了一层FinalizableDelegatedExecutorService包装，这一层有什么用呢，写个dome来解释一下：\n\n```\n    public static void main(String[] args) {\n        ExecutorService fixedExecutorService = Executors.newFixedThreadPool(1);\n        ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) fixedExecutorService;\n        System.out.println(threadPoolExecutor.getMaximumPoolSize());\n        threadPoolExecutor.setCorePoolSize(8);\n\n        ExecutorService singleExecutorService = Executors.newSingleThreadExecutor();\n//      运行时异常 java.lang.ClassCastException\n//      ThreadPoolExecutor threadPoolExecutor2 = (ThreadPoolExecutor) singleExecutorService;\n    }\n\n```\n\n对比可以看出，FixedThreadPool可以向下转型为ThreadPoolExecutor，并对其线程池进行配置，而SingleThreadExecutor被包装后，无法成功向下转型。**因此，SingleThreadExecutor被定以后，无法修改，做到了真正的Single。**\n\n1.  **ScheduledThreadPool**\n\n```\n    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {\n        return new ScheduledThreadPoolExecutor(corePoolSize);\n    }\n\n```\n\nnewScheduledThreadPool调用的是ScheduledThreadPoolExecutor的构造方法，而ScheduledThreadPoolExecutor继承了ThreadPoolExecutor，构造是还是调用了其父类的构造方法。\n\n```\n    public ScheduledThreadPoolExecutor(int corePoolSize) {\n        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,\n              new DelayedWorkQueue());\n    }\n\n```\n\n对于ScheduledThreadPool本文不做描述，其特性请关注后续篇章。\n\n作者：徐志毅\n链接：https://www.jianshu.com/p/f030aa5d7a28\n来源：简书\n简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。"]],[982,982],[5530,5530]]],[1566181756306,["david@DESKTOP-9844NL4",[[-1,5400,"对于ScheduledThreadPool本文不做描述，其特性请关注后续篇章。\n\n作者：徐志毅\n链接：https://www.jianshu.com/p/f030aa5d7a28\n来源：简书\n简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。\n"]],[5400,5531],[5400,5400]]],[1566181786814,["david@DESKTOP-9844NL4",[[1,5400,"##### 二、自定义线程池\n\n以下是自定义线程池，使用了有界队列，自定义ThreadFactory和拒绝策略的demo：\n\n```\npublic class ThreadTest {\n\n    public static void main(String[] args) throws InterruptedException, IOException {\n        int corePoolSize = 2;\n        int maximumPoolSize = 4;\n        long keepAliveTime = 10;\n        TimeUnit unit = TimeUnit.SECONDS;\n        BlockingQueue<Runnable> workQueue = new ArrayBlockingQueue<>(2);\n        ThreadFactory threadFactory = new NameTreadFactory();\n        RejectedExecutionHandler handler = new MyIgnorePolicy();\n        ThreadPoolExecutor executor = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit,\n                workQueue, threadFactory, handler);\n        executor.prestartAllCoreThreads(); // 预启动所有核心线程\n\n        for (int i = 1; i <= 10; i++) {\n            MyTask task = new MyTask(String.valueOf(i));\n            executor.execute(task);\n        }\n\n        System.in.read(); //阻塞主线程\n    }\n\n    static class NameTreadFactory implements ThreadFactory {\n\n        private final AtomicInteger mThreadNum = new AtomicInteger(1);\n\n        @Override\n        public Thread newThread(Runnable r) {\n            Thread t = new Thread(r, \"my-thread-\" + mThreadNum.getAndIncrement());\n            System.out.println(t.getName() + \" has been created\");\n            return t;\n        }\n    }\n\n    public static class MyIgnorePolicy implements RejectedExecutionHandler {\n\n        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n            doLog(r, e);\n        }\n\n        private void doLog(Runnable r, ThreadPoolExecutor e) {\n            // 可做日志记录等\n            System.err.println( r.toString() + \" rejected\");\n//          System.out.println(\"completedTaskCount: \" + e.getCompletedTaskCount());\n        }\n    }\n\n    static class MyTask implements Runnable {\n        private String name;\n\n        public MyTask(String name) {\n            this.name = name;\n        }\n\n        @Override\n        public void run() {\n            try {\n                System.out.println(this.toString() + \" is running!\");\n                Thread.sleep(3000); //让任务执行慢点\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        @Override\n        public String toString() {\n            return \"MyTask [name=\" + name + \"]\";\n        }\n    }\n}\n\n```\n\n输出结果如下：\n\n![](//upload-images.jianshu.io/upload_images/11183270-ef3cb072affbec03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/398/format/webp)\n\nimage.png\n\n其中线程线程1-4先占满了核心线程和最大线程数量，然后4、5线程进入等待队列，7-10线程被直接忽略拒绝执行，等1-4线程中有线程执行完后通知4、5线程继续执行。\n\n#### 总结，通过自定义线程池，我们可以更好的让线程池为我们所用，更加适应我的实际场景。\n\n作者：徐志毅\n链接：https://www.jianshu.com/p/f030aa5d7a28\n来源：简书\n简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。"]],[5400,5400],[8165,8165]]],[1566181793530,["david@DESKTOP-9844NL4",[[-1,8076,"作者：徐志毅\n链接：https://www.jianshu.com/p/f030aa5d7a28\n来源：简书\n简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。\n"]],[8076,8166],[8076,8076]]],[1566181793979,["david@DESKTOP-9844NL4",[[-1,8079,"\n"]],[8076,8076],[8075,8075]]],[1566181794802,["david@DESKTOP-9844NL4",[[-1,8078,"\n"]],[8075,8075],[8074,8074]]],[1566181835146,["david@DESKTOP-9844NL4",[[-1,76,"阿里巴巴线程池开发规范"]],[76,87],[76,76]]],[1566181836877,["david@DESKTOP-9844NL4",[[1,76,"E"]],[76,76],[77,77]]],[1566181837363,["david@DESKTOP-9844NL4",[[-1,76,"E"]],[77,77],[76,76]]],[1566181837854,["david@DESKTOP-9844NL4",[[1,76,"YU"]],[76,76],[78,78]]],[1566181838367,["david@DESKTOP-9844NL4",[[-1,76,"YU"]],[78,78],[76,76]]],[1566181851826,["david@DESKTOP-9844NL4",[[1,76,"预定义的线程池便捷创建方法"]],[76,76],[89,89]]],[1566181871090,["david@DESKTOP-9844NL4",[[1,91,"虽然这种创建线程池的方法比较简便，但是"]],[91,91],[110,110]]],[1566181889351,["david@DESKTOP-9844NL4",[[-1,2524,"##### 一、预定义线程池\n\n1.  **FixedThreadPool**\n\n```\n    public static ExecutorService newFixedThreadPool(int nThreads) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue<Runnable>());\n    }\n\n```\n\n> *   corePoolSize与maximumPoolSize相等，即其线程全为核心线程，是一个固定大小的线程池，是其优势；\n> *   keepAliveTime = 0 该参数默认对核心线程无效，而FixedThreadPool全部为核心线程；\n> *   workQueue 为LinkedBlockingQueue（无界阻塞队列），队列最大值为Integer.MAX_VALUE。如果任务提交速度持续大余任务处理速度，会造成队列大量阻塞。因为队列很大，很有可能在拒绝策略前，内存溢出。是其劣势；\n> *   FixedThreadPool的任务执行是无序的；\n\n适用场景：可用于Web服务瞬时削峰，但需注意长时间持续高峰情况造成的队列阻塞。\n\n1.  **CachedThreadPool**\n\n```\n     public static ExecutorService newCachedThreadPool() {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue<Runnable>());\n    }\n\n```\n\n> *   corePoolSize = 0，maximumPoolSize = Integer.MAX_VALUE，即线程数量几乎无限制；\n> *   keepAliveTime = 60s，线程空闲60s后自动结束。\n> *   workQueue 为 SynchronousQueue 同步队列，这个队列类似于一个接力棒，入队出队必须同时传递，因为CachedThreadPool线程创建无限制，不会有队列等待，所以使用SynchronousQueue；\n\n适用场景：快速处理大量耗时较短的任务，如Netty的NIO接受请求时，可使用CachedThreadPool。\n\n1.  **SingleThreadExecutor**\n\n```\n    public static ExecutorService newSingleThreadExecutor() {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>()));\n    }\n\n```\n\n咋一瞅，不就是newFixedThreadPool(1)吗？定眼一看，这里多了一层FinalizableDelegatedExecutorService包装，这一层有什么用呢，写个dome来解释一下：\n\n```\n    public static void main(String[] args) {\n        ExecutorService fixedExecutorService = Executors.newFixedThreadPool(1);\n        ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) fixedExecutorService;\n        System.out.println(threadPoolExecutor.getMaximumPoolSize());\n        threadPoolExecutor.setCorePoolSize(8);\n\n        ExecutorService singleExecutorService = Executors.newSingleThreadExecutor();\n//      运行时异常 java.lang.ClassCastException\n//      ThreadPoolExecutor threadPoolExecutor2 = (ThreadPoolExecutor) singleExecutorService;\n    }\n\n```\n\n对比可以看出，FixedThreadPool可以向下转型为ThreadPoolExecutor，并对其线程池进行配置，而SingleThreadExecutor被包装后，无法成功向下转型。**因此，SingleThreadExecutor被定以后，无法修改，做到了真正的Single。**\n\n1.  **ScheduledThreadPool**\n\n```\n    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {\n        return new ScheduledThreadPoolExecutor(corePoolSize);\n    }\n\n```\n\nnewScheduledThreadPool调用的是ScheduledThreadPoolExecutor的构造方法，而ScheduledThreadPoolExecutor继承了ThreadPoolExecutor，构造是还是调用了其父类的构造方法。\n\n```\n    public ScheduledThreadPoolExecutor(int corePoolSize) {\n        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,\n              new DelayedWorkQueue());\n    }\n\n```"]],[2524,5419],[2524,2524]]],[1566181899689,["david@DESKTOP-9844NL4",[[-1,779,"Thread.newFixedThreadPool(int nThreads)源码\n![mark](http://blog.sjjtcloud.com/blog/20190819/URrvW1kKs3p3.png?imageslim)"]],[779,896],[779,779]]],[1566181900226,["david@DESKTOP-9844NL4",[[1,779,"\\"]],[779,779],[780,780]]],[1566181900740,["david@DESKTOP-9844NL4",[[-1,779,"\\"]],[780,780],[779,779]]],[1566181901225,["david@DESKTOP-9844NL4",[[1,781,"\n"]],[779,779],[780,780]]],[1566181901406,["david@DESKTOP-9844NL4",[[1,782,"\n"]],[780,780],[781,781]]],[1566181902914,["david@DESKTOP-9844NL4",[[1,779,"xiam"]],[779,779],[783,783]]],[1566181903910,["david@DESKTOP-9844NL4",[[-1,779,"xiam"]],[783,783],[779,779]]],[1566181904502,["david@DESKTOP-9844NL4",[[1,779,"##### 一、预定义线程池\n\n1.  **FixedThreadPool**\n\n```\n    public static ExecutorService newFixedThreadPool(int nThreads) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue<Runnable>());\n    }\n\n```\n\n> *   corePoolSize与maximumPoolSize相等，即其线程全为核心线程，是一个固定大小的线程池，是其优势；\n> *   keepAliveTime = 0 该参数默认对核心线程无效，而FixedThreadPool全部为核心线程；\n> *   workQueue 为LinkedBlockingQueue（无界阻塞队列），队列最大值为Integer.MAX_VALUE。如果任务提交速度持续大余任务处理速度，会造成队列大量阻塞。因为队列很大，很有可能在拒绝策略前，内存溢出。是其劣势；\n> *   FixedThreadPool的任务执行是无序的；\n\n适用场景：可用于Web服务瞬时削峰，但需注意长时间持续高峰情况造成的队列阻塞。\n\n1.  **CachedThreadPool**\n\n```\n     public static ExecutorService newCachedThreadPool() {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue<Runnable>());\n    }\n\n```\n\n> *   corePoolSize = 0，maximumPoolSize = Integer.MAX_VALUE，即线程数量几乎无限制；\n> *   keepAliveTime = 60s，线程空闲60s后自动结束。\n> *   workQueue 为 SynchronousQueue 同步队列，这个队列类似于一个接力棒，入队出队必须同时传递，因为CachedThreadPool线程创建无限制，不会有队列等待，所以使用SynchronousQueue；\n\n适用场景：快速处理大量耗时较短的任务，如Netty的NIO接受请求时，可使用CachedThreadPool。\n\n1.  **SingleThreadExecutor**\n\n```\n    public static ExecutorService newSingleThreadExecutor() {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>()));\n    }\n\n```\n\n咋一瞅，不就是newFixedThreadPool(1)吗？定眼一看，这里多了一层FinalizableDelegatedExecutorService包装，这一层有什么用呢，写个dome来解释一下：\n\n```\n    public static void main(String[] args) {\n        ExecutorService fixedExecutorService = Executors.newFixedThreadPool(1);\n        ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) fixedExecutorService;\n        System.out.println(threadPoolExecutor.getMaximumPoolSize());\n        threadPoolExecutor.setCorePoolSize(8);\n\n        ExecutorService singleExecutorService = Executors.newSingleThreadExecutor();\n//      运行时异常 java.lang.ClassCastException\n//      ThreadPoolExecutor threadPoolExecutor2 = (ThreadPoolExecutor) singleExecutorService;\n    }\n\n```\n\n对比可以看出，FixedThreadPool可以向下转型为ThreadPoolExecutor，并对其线程池进行配置，而SingleThreadExecutor被包装后，无法成功向下转型。**因此，SingleThreadExecutor被定以后，无法修改，做到了真正的Single。**\n\n1.  **ScheduledThreadPool**\n\n```\n    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {\n        return new ScheduledThreadPoolExecutor(corePoolSize);\n    }\n\n```\n\nnewScheduledThreadPool调用的是ScheduledThreadPoolExecutor的构造方法，而ScheduledThreadPoolExecutor继承了ThreadPoolExecutor，构造是还是调用了其父类的构造方法。\n\n```\n    public ScheduledThreadPoolExecutor(int corePoolSize) {\n        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,\n              new DelayedWorkQueue());\n    }\n\n```"]],[779,779],[3674,3674]]],[1566181907943,["david@DESKTOP-9844NL4",[[1,793,"jie"]],[793,793],[796,796]]],[1566181908752,["david@DESKTOP-9844NL4",[[-1,793,"jie"]],[796,796],[793,793]]],[1566181910143,["david@DESKTOP-9844NL4",[[1,793,"分析"]],[793,793],[795,795]]],[1566181917080,["david@DESKTOP-9844NL4",[[1,803,"new"]],[803,818],[821,821]]],[1566181924264,["david@DESKTOP-9844NL4",[[1,1444,"new"]],[1444,1460],[1463,1463]]],[1566181934669,["david@DESKTOP-9844NL4",[[-1,783,"# 一、"]],[787,787],[783,783]]],[1566181935701,["david@DESKTOP-9844NL4",[[1,783," "]],[783,783],[784,784]]],[1566181943576,["david@DESKTOP-9844NL4",[[-1,784,"预定义线程池分析"]],[792,792],[784,784]]],[1566181945198,["david@DESKTOP-9844NL4",[[1,784,"便捷"]],[784,784],[786,786]]],[1566181945782,["david@DESKTOP-9844NL4",[[-1,784,"便捷"]],[786,786],[784,784]]],[1566181951302,["david@DESKTOP-9844NL4",[[1,784,"方法分析"]],[784,784],[788,788]]],[1566181955136,["david@DESKTOP-9844NL4",[[-1,784,"方法"]],[786,786],[784,784]]],[1566181957665,["david@DESKTOP-9844NL4",[[1,784,"源码"]],[784,784],[786,786]]],[1566181962721,["david@DESKTOP-9844NL4",[[-1,1431,"1"]],[1432,1432],[1431,1431]]],[1566181962929,["david@DESKTOP-9844NL4",[[1,1431,"2"]],[1431,1431],[1432,1432]]],[1566181978672,["david@DESKTOP-9844NL4",[[1,2024,"new"]],[2024,2044],[2047,2047]]],[1566181980825,["david@DESKTOP-9844NL4",[[-1,2018,"1"]],[2019,2019],[2018,2018]]],[1566181981008,["david@DESKTOP-9844NL4",[[1,2018,"3"]],[2018,2018],[2019,2019]]],[1566181989549,["david@DESKTOP-9844NL4",[[-1,3182,"1"]],[3183,3183],[3182,3182]]],[1566181989759,["david@DESKTOP-9844NL4",[[1,3182,"4"]],[3182,3182],[3183,3183]]],[1566181997205,["david@DESKTOP-9844NL4",[[-1,2024,"new"]],[2027,2027],[2024,2024]]],[1566182001077,["david@DESKTOP-9844NL4",[[-1,1437,"new"]],[1440,1440],[1437,1437]]],[1566182005486,["david@DESKTOP-9844NL4",[[-1,796,"new"]],[799,799],[796,796]]],[1566182023238,["david@DESKTOP-9844NL4",[[1,778,"|     |     |\n"]],[777,777],[779,784]]],[1566182026280,["david@DESKTOP-9844NL4",[[1,781,"ScheduledExecutorService newScheduledThreadPool(int corePoolSize)"]],[781,781],[846,846]]],[1566182031931,["david@DESKTOP-9844NL4",[[-1,780," ScheduledExecutorService "]],[781,806],[780,780]]],[1566183131127,["david@DESKTOP-9844NL4",[[1,825,"此线程池支持定时以及周期性执行任务的需求"]],[825,825],[845,845]]],[1566183174719,["david@DESKTOP-9844NL4",[[-1,83,"便捷创建方法"]],[83,89],[83,83]]],[1566184026601,["david@DESKTOP-9844NL4",[[1,666,"（）"]],[666,666],[668,668]]],[1566184042919,["david@DESKTOP-9844NL4",[[1,667,"请求队列不受限制"]],[667,667],[675,675]]],[1566184048544,["david@DESKTOP-9844NL4",[[1,721,"（请求队列不受限制）"]],[721,721],[731,731]]],[1566184116698,["david@DESKTOP-9844NL4",[[1,789,"（）"]],[789,789],[791,791]]],[1566184124285,["david@DESKTOP-9844NL4",[[1,790,"线程数不受限制"]],[790,790],[797,797]]],[1566184127363,["david@DESKTOP-9844NL4",[[1,868,"（）"]],[868,868],[870,870]]],[1566184130567,["david@DESKTOP-9844NL4",[[1,869,"线程池"]],[869,869],[872,872]]],[1566184138750,["david@DESKTOP-9844NL4",[[-1,871,"池"]],[872,872],[871,871]]],[1566184143148,["david@DESKTOP-9844NL4",[[1,871,"数不受限制"]],[871,871],[876,876]]],[1566184147933,["david@DESKTOP-9844NL4",[[-1,877,"    "]],[881,881],[877,877]]],[1566184603164,["david@DESKTOP-9844NL4",[[-1,72,"### 预定义的线程池\n\n虽然这种创建线程池的方法比较简便，但是阿里巴巴开发规范中,明确指出禁止使用Executors来创建线程,因为这样创建线程池,有可能会导致OOM,  创建线程池应该使用ThreadPoolExecutor的方式, 其实这些创建线程池的方法,背后原理也是使用TreadPoolExecutor来创建的\n\n```\n【强制】\n线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样\n的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。\n说明：Executors 返回的线程池对象的弊端如下：\n\n1）FixedThreadPool 和 SingleThreadPool:\n允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。\n\n2）CachedThreadPool 和 ScheduledThreadPool:\n允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。\n\n```\n\n\n### Executors创建线程池\n\n`Executors`创建线程池方法列表：\n\n| 方法名 | 功能 |\n| --- | --- |\n| newFixedThreadPool(int nThreads) | 创建固定大小的线程池（请求队列不受限制） |\n| newSingleThreadExecutor() | 创建只有一个线程的线程池（请求队列不受限制） |\n| newCachedThreadPool() | 创建一个不限线程数上限的线程池，任何提交的任务都将立即执行（线程数不受限制） |\n| newScheduledThreadPool(int corePoolSize)   | 此线程池支持定时以及周期性执行任务的需求（线程数不受限制）|\n\n#### 源码分析\n\n1.  **FixedThreadPool**\n\n```\n    public static ExecutorService newFixedThreadPool(int nThreads) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue<Runnable>());\n    }\n\n```\n\n> *   corePoolSize与maximumPoolSize相等，即其线程全为核心线程，是一个固定大小的线程池，是其优势；\n> *   keepAliveTime = 0 该参数默认对核心线程无效，而FixedThreadPool全部为核心线程；\n> *   workQueue 为LinkedBlockingQueue（无界阻塞队列），队列最大值为Integer.MAX_VALUE。如果任务提交速度持续大余任务处理速度，会造成队列大量阻塞。因为队列很大，很有可能在拒绝策略前，内存溢出。是其劣势；\n> *   FixedThreadPool的任务执行是无序的；\n\n适用场景：可用于Web服务瞬时削峰，但需注意长时间持续高峰情况造成的队列阻塞。\n\n2.  **CachedThreadPool**\n\n```\n     public static ExecutorService newCachedThreadPool() {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue<Runnable>());\n    }\n\n```\n\n> *   corePoolSize = 0，maximumPoolSize = Integer.MAX_VALUE，即线程数量几乎无限制；\n> *   keepAliveTime = 60s，线程空闲60s后自动结束。\n> *   workQueue 为 SynchronousQueue 同步队列，这个队列类似于一个接力棒，入队出队必须同时传递，因为CachedThreadPool线程创建无限制，不会有队列等待，所以使用SynchronousQueue；\n\n适用场景：快速处理大量耗时较短的任务，如Netty的NIO接受请求时，可使用CachedThreadPool。\n\n3.  **SingleThreadExecutor**\n\n```\n    public static ExecutorService newSingleThreadExecutor() {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>()));\n    }\n\n```\n\n咋一瞅，不就是newFixedThreadPool(1)吗？定眼一看，这里多了一层FinalizableDelegatedExecutorService包装，这一层有什么用呢，写个dome来解释一下：\n\n```\n    public static void main(String[] args) {\n        ExecutorService fixedExecutorService = Executors.newFixedThreadPool(1);\n        ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) fixedExecutorService;\n        System.out.println(threadPoolExecutor.getMaximumPoolSize());\n        threadPoolExecutor.setCorePoolSize(8);\n\n        ExecutorService singleExecutorService = Executors.newSingleThreadExecutor();\n//      运行时异常 java.lang.ClassCastException\n//      ThreadPoolExecutor threadPoolExecutor2 = (ThreadPoolExecutor) singleExecutorService;\n    }\n\n```\n\n对比可以看出，FixedThreadPool可以向下转型为ThreadPoolExecutor，并对其线程池进行配置，而SingleThreadExecutor被包装后，无法成功向下转型。**因此，SingleThreadExecutor被定以后，无法修改，做到了真正的Single。**\n\n4.  **ScheduledThreadPool**\n\n```\n    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {\n        return new ScheduledThreadPoolExecutor(corePoolSize);\n    }\n\n```\n\nnewScheduledThreadPool调用的是ScheduledThreadPoolExecutor的构造方法，而ScheduledThreadPoolExecutor继承了ThreadPoolExecutor，构造是还是调用了其父类的构造方法。\n\n```\n    public ScheduledThreadPoolExecutor(int corePoolSize) {\n        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,\n              new DelayedWorkQueue());\n    }\n\n```\n"]],[72,3771],[72,72]]],[1566184605993,["david@DESKTOP-9844NL4",[[-1,74,"\n"]],[74,74],[73,73]]],[1566184606240,["david@DESKTOP-9844NL4",[[-1,73,"\n"]],[73,73],[72,72]]],[1566184606429,["david@DESKTOP-9844NL4",[[-1,72,"\n"]],[72,72],[71,71]]],[1566184606648,["david@DESKTOP-9844NL4",[[-1,71,"\n"]],[71,71],[70,70]]],[1566184610565,["david@DESKTOP-9844NL4",[[1,1699,"\n"]],[1695,1695],[1696,1696]]],[1566184610844,["david@DESKTOP-9844NL4",[[1,1700,"\n"]],[1696,1696],[1697,1697]]],[1566184611442,["david@DESKTOP-9844NL4",[[1,1697,"### 预定义的线程池\n\n虽然这种创建线程池的方法比较简便，但是阿里巴巴开发规范中,明确指出禁止使用Executors来创建线程,因为这样创建线程池,有可能会导致OOM,  创建线程池应该使用ThreadPoolExecutor的方式, 其实这些创建线程池的方法,背后原理也是使用TreadPoolExecutor来创建的\n\n```\n【强制】\n线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样\n的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。\n说明：Executors 返回的线程池对象的弊端如下：\n\n1）FixedThreadPool 和 SingleThreadPool:\n允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。\n\n2）CachedThreadPool 和 ScheduledThreadPool:\n允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。\n\n```\n\n\n### Executors创建线程池\n\n`Executors`创建线程池方法列表：\n\n| 方法名 | 功能 |\n| --- | --- |\n| newFixedThreadPool(int nThreads) | 创建固定大小的线程池（请求队列不受限制） |\n| newSingleThreadExecutor() | 创建只有一个线程的线程池（请求队列不受限制） |\n| newCachedThreadPool() | 创建一个不限线程数上限的线程池，任何提交的任务都将立即执行（线程数不受限制） |\n| newScheduledThreadPool(int corePoolSize)   | 此线程池支持定时以及周期性执行任务的需求（线程数不受限制）|\n\n#### 源码分析\n\n1.  **FixedThreadPool**\n\n```\n    public static ExecutorService newFixedThreadPool(int nThreads) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue<Runnable>());\n    }\n\n```\n\n> *   corePoolSize与maximumPoolSize相等，即其线程全为核心线程，是一个固定大小的线程池，是其优势；\n> *   keepAliveTime = 0 该参数默认对核心线程无效，而FixedThreadPool全部为核心线程；\n> *   workQueue 为LinkedBlockingQueue（无界阻塞队列），队列最大值为Integer.MAX_VALUE。如果任务提交速度持续大余任务处理速度，会造成队列大量阻塞。因为队列很大，很有可能在拒绝策略前，内存溢出。是其劣势；\n> *   FixedThreadPool的任务执行是无序的；\n\n适用场景：可用于Web服务瞬时削峰，但需注意长时间持续高峰情况造成的队列阻塞。\n\n2.  **CachedThreadPool**\n\n```\n     public static ExecutorService newCachedThreadPool() {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue<Runnable>());\n    }\n\n```\n\n> *   corePoolSize = 0，maximumPoolSize = Integer.MAX_VALUE，即线程数量几乎无限制；\n> *   keepAliveTime = 60s，线程空闲60s后自动结束。\n> *   workQueue 为 SynchronousQueue 同步队列，这个队列类似于一个接力棒，入队出队必须同时传递，因为CachedThreadPool线程创建无限制，不会有队列等待，所以使用SynchronousQueue；\n\n适用场景：快速处理大量耗时较短的任务，如Netty的NIO接受请求时，可使用CachedThreadPool。\n\n3.  **SingleThreadExecutor**\n\n```\n    public static ExecutorService newSingleThreadExecutor() {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>()));\n    }\n\n```\n\n咋一瞅，不就是newFixedThreadPool(1)吗？定眼一看，这里多了一层FinalizableDelegatedExecutorService包装，这一层有什么用呢，写个dome来解释一下：\n\n```\n    public static void main(String[] args) {\n        ExecutorService fixedExecutorService = Executors.newFixedThreadPool(1);\n        ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) fixedExecutorService;\n        System.out.println(threadPoolExecutor.getMaximumPoolSize());\n        threadPoolExecutor.setCorePoolSize(8);\n\n        ExecutorService singleExecutorService = Executors.newSingleThreadExecutor();\n//      运行时异常 java.lang.ClassCastException\n//      ThreadPoolExecutor threadPoolExecutor2 = (ThreadPoolExecutor) singleExecutorService;\n    }\n\n```\n\n对比可以看出，FixedThreadPool可以向下转型为ThreadPoolExecutor，并对其线程池进行配置，而SingleThreadExecutor被包装后，无法成功向下转型。**因此，SingleThreadExecutor被定以后，无法修改，做到了真正的Single。**\n\n4.  **ScheduledThreadPool**\n\n```\n    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {\n        return new ScheduledThreadPoolExecutor(corePoolSize);\n    }\n\n```\n\nnewScheduledThreadPool调用的是ScheduledThreadPoolExecutor的构造方法，而ScheduledThreadPoolExecutor继承了ThreadPoolExecutor，构造是还是调用了其父类的构造方法。\n\n```\n    public ScheduledThreadPoolExecutor(int corePoolSize) {\n        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,\n              new DelayedWorkQueue());\n    }\n\n```\n"]],[1697,1697],[5396,5396]]]],null,"david@DESKTOP-9844NL4"],["38214207-4860-4b85-a835-968a5136ebc9",1566271646146,"\n---\ntitle: 线程池之ThreadPoolExecutor使用\ncategories: java\ntags:\n- 线程池\n---\n\n### ThreadPoolExecutor构造方法\n![mark](http://blog.sjjtcloud.com/blog/20190819/voP4iKK3jVUw.png?imageslim)\n\n\n我们以最后一个构造方法（参数最多的那个），对其参数进行解释：\n\n```\n public ThreadPoolExecutor(int corePoolSize, // 1\n                              int maximumPoolSize,  // 2\n                              long keepAliveTime,  // 3\n                              TimeUnit unit,  // 4\n                              BlockingQueue<Runnable> workQueue, // 5\n                              ThreadFactory threadFactory,  // 6\n                              RejectedExecutionHandler handler ) { //7\n        if (corePoolSize < 0 ||\n            maximumPoolSize <= 0 ||\n            maximumPoolSize < corePoolSize ||\n            keepAliveTime < 0)\n            throw new IllegalArgumentException();\n        if (workQueue == null || threadFactory == null || handler == null)\n            throw new NullPointerException();\n        this.corePoolSize = corePoolSize;\n        this.maximumPoolSize = maximumPoolSize;\n        this.workQueue = workQueue;\n        this.keepAliveTime = unit.toNanos(keepAliveTime);\n        this.threadFactory = threadFactory;\n        this.handler = handler;\n    }\n\n```\n\n| 序号 | 名称 | 类型 | 含义 |\n| --- | --- | --- | --- |\n| 1 | corePoolSize | int | 核心线程池大小 |\n| 2 | maximumPoolSize | int | 最大线程池大小 |\n| 3 | keepAliveTime | long | 线程最大空闲时间 |\n| 4 | unit | TimeUnit | 时间单位 |\n| 5 | workQueue | BlockingQueue<Runnable> | 线程等待队列 |\n| 6 | threadFactory | ThreadFactory | 线程创建工厂 |\n| 7 | handler | RejectedExecutionHandler | 拒绝策略 |\n\n如果对这些参数作用有疑惑的请看 [ThreadPoolExecutor概述](https://www.jianshu.com/p/c41e942bcd64)。\n知道了各个参数的作用后，我们开始构造符合我们期待的线程池。首先看JDK给我们预定义的几种线程池：\n\n### 预定义的线程池\n\n虽然这种创建线程池的方法比较简便，但是阿里巴巴开发规范中,明确指出禁止使用Executors来创建线程,因为这样创建线程池,有可能会导致OOM,  创建线程池应该使用ThreadPoolExecutor的方式, 其实这些创建线程池的方法,背后原理也是使用TreadPoolExecutor来创建的\n\n```\n【强制】\n线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样\n的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。\n说明：Executors 返回的线程池对象的弊端如下：\n\n1）FixedThreadPool 和 SingleThreadPool:\n允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。\n\n2）CachedThreadPool 和 ScheduledThreadPool:\n允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。\n\n```\n\n\n### Executors创建线程池\n\n`Executors`创建线程池方法列表：\n\n| 方法名 | 功能 |\n| --- | --- |\n| newFixedThreadPool(int nThreads) | 创建固定大小的线程池（请求队列不受限制） |\n| newSingleThreadExecutor() | 创建只有一个线程的线程池（请求队列不受限制） |\n| newCachedThreadPool() | 创建一个不限线程数上限的线程池，任何提交的任务都将立即执行（线程数不受限制） |\n| newScheduledThreadPool(int corePoolSize)   | 此线程池支持定时以及周期性执行任务的需求（线程数不受限制）|\n\n#### 源码分析\n\n1.  **FixedThreadPool**\n\n```\n    public static ExecutorService newFixedThreadPool(int nThreads) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue<Runnable>());\n    }\n\n```\n\n> *   corePoolSize与maximumPoolSize相等，即其线程全为核心线程，是一个固定大小的线程池，是其优势；\n> *   keepAliveTime = 0 该参数默认对核心线程无效，而FixedThreadPool全部为核心线程；\n> *   workQueue 为LinkedBlockingQueue（无界阻塞队列），队列最大值为Integer.MAX_VALUE。如果任务提交速度持续大余任务处理速度，会造成队列大量阻塞。因为队列很大，很有可能在拒绝策略前，内存溢出。是其劣势；\n> *   FixedThreadPool的任务执行是无序的；\n\n适用场景：可用于Web服务瞬时削峰，但需注意长时间持续高峰情况造成的队列阻塞。\n\n2.  **CachedThreadPool**\n\n```\n     public static ExecutorService newCachedThreadPool() {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue<Runnable>());\n    }\n\n```\n\n> *   corePoolSize = 0，maximumPoolSize = Integer.MAX_VALUE，即线程数量几乎无限制；\n> *   keepAliveTime = 60s，线程空闲60s后自动结束。\n> *   workQueue 为 SynchronousQueue 同步队列，这个队列类似于一个接力棒，入队出队必须同时传递，因为CachedThreadPool线程创建无限制，不会有队列等待，所以使用SynchronousQueue；\n\n适用场景：快速处理大量耗时较短的任务，如Netty的NIO接受请求时，可使用CachedThreadPool。\n\n3.  **SingleThreadExecutor**\n\n```\n    public static ExecutorService newSingleThreadExecutor() {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>()));\n    }\n\n```\n\n咋一瞅，不就是newFixedThreadPool(1)吗？定眼一看，这里多了一层FinalizableDelegatedExecutorService包装，这一层有什么用呢，写个dome来解释一下：\n\n```\n    public static void main(String[] args) {\n        ExecutorService fixedExecutorService = Executors.newFixedThreadPool(1);\n        ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) fixedExecutorService;\n        System.out.println(threadPoolExecutor.getMaximumPoolSize());\n        threadPoolExecutor.setCorePoolSize(8);\n\n        ExecutorService singleExecutorService = Executors.newSingleThreadExecutor();\n//      运行时异常 java.lang.ClassCastException\n//      ThreadPoolExecutor threadPoolExecutor2 = (ThreadPoolExecutor) singleExecutorService;\n    }\n\n```\n\n对比可以看出，FixedThreadPool可以向下转型为ThreadPoolExecutor，并对其线程池进行配置，而SingleThreadExecutor被包装后，无法成功向下转型。**因此，SingleThreadExecutor被定以后，无法修改，做到了真正的Single。**\n\n4.  **ScheduledThreadPool**\n\n```\n    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {\n        return new ScheduledThreadPoolExecutor(corePoolSize);\n    }\n\n```\n\nnewScheduledThreadPool调用的是ScheduledThreadPoolExecutor的构造方法，而ScheduledThreadPoolExecutor继承了ThreadPoolExecutor，构造是还是调用了其父类的构造方法。\n\n```\n    public ScheduledThreadPoolExecutor(int corePoolSize) {\n        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,\n              new DelayedWorkQueue());\n    }\n\n```\n\n\n\n\n##### 二、自定义线程池\n\n以下是自定义线程池，使用了有界队列，自定义ThreadFactory和拒绝策略的demo：\n\n```\npublic class ThreadTest {\n\n    public static void main(String[] args) throws InterruptedException, IOException {\n        int corePoolSize = 2;\n        int maximumPoolSize = 4;\n        long keepAliveTime = 10;\n        TimeUnit unit = TimeUnit.SECONDS;\n        BlockingQueue<Runnable> workQueue = new ArrayBlockingQueue<>(2);\n        ThreadFactory threadFactory = new NameTreadFactory();\n        RejectedExecutionHandler handler = new MyIgnorePolicy();\n        ThreadPoolExecutor executor = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit,\n                workQueue, threadFactory, handler);\n        executor.prestartAllCoreThreads(); // 预启动所有核心线程\n\n        for (int i = 1; i <= 10; i++) {\n            MyTask task = new MyTask(String.valueOf(i));\n            executor.execute(task);\n        }\n\n        System.in.read(); //阻塞主线程\n    }\n\n    static class NameTreadFactory implements ThreadFactory {\n\n        private final AtomicInteger mThreadNum = new AtomicInteger(1);\n\n        @Override\n        public Thread newThread(Runnable r) {\n            Thread t = new Thread(r, \"my-thread-\" + mThreadNum.getAndIncrement());\n            System.out.println(t.getName() + \" has been created\");\n            return t;\n        }\n    }\n\n    public static class MyIgnorePolicy implements RejectedExecutionHandler {\n\n        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n            doLog(r, e);\n        }\n\n        private void doLog(Runnable r, ThreadPoolExecutor e) {\n            // 可做日志记录等\n            System.err.println( r.toString() + \" rejected\");\n//          System.out.println(\"completedTaskCount: \" + e.getCompletedTaskCount());\n        }\n    }\n\n    static class MyTask implements Runnable {\n        private String name;\n\n        public MyTask(String name) {\n            this.name = name;\n        }\n\n        @Override\n        public void run() {\n            try {\n                System.out.println(this.toString() + \" is running!\");\n                Thread.sleep(3000); //让任务执行慢点\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        @Override\n        public String toString() {\n            return \"MyTask [name=\" + name + \"]\";\n        }\n    }\n}\n\n```\n\n输出结果如下：\n\n![](//upload-images.jianshu.io/upload_images/11183270-ef3cb072affbec03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/398/format/webp)\n\nimage.png\n\n其中线程线程1-4先占满了核心线程和最大线程数量，然后4、5线程进入等待队列，7-10线程被直接忽略拒绝执行，等1-4线程中有线程执行完后通知4、5线程继续执行。\n\n#### 总结，通过自定义线程池，我们可以更好的让线程池为我们所用，更加适应我的实际场景。\n\n\n\n",[[1566271621928,["david@DESKTOP-9844NL4",[[-1,60,"- "]],[62,62],[60,60]]],[1566271622275,["david@DESKTOP-9844NL4",[[-1,59,"\n"]],[60,60],[59,59]]],[1566271623358,["david@DESKTOP-9844NL4",[[1,59," "]],[59,59],[60,60]]],[1566271631623,["david@DESKTOP-9844NL4",[[1,69,"\n"]],[67,67],[68,68]]],[1566271631795,["david@DESKTOP-9844NL4",[[1,70,"\n"]],[68,68],[69,69]]],[1566271632333,["david@DESKTOP-9844NL4",[[1,69,"---\ntitle: 阿里FastJson如何处理返回值中nulll值问题\ntags: java\ncategories: fastJson\n---"]],[69,69],[142,142]]],[1566271654903,["david@DESKTOP-9844NL4",[[-1,69,"---\ntitle: 阿里FastJson如何处理返回值中nulll值问题\ntags: java\ncategories: fastJson\n---"]],[69,142],[69,69]]],[1566271655405,["david@DESKTOP-9844NL4",[[-1,70,"\n"]],[69,69],[68,68]]],[1566271655686,["david@DESKTOP-9844NL4",[[-1,69,"\n"]],[68,68],[67,67]]],[1566271709145,["david@DESKTOP-9844NL4",[[-1,0,"\n---\ntitle: 线程池之ThreadPoolExecutor使用\ncategories: java\ntags: 线程池\n---\n"]],[0,68],[0,0]]],[1566271710199,["david@DESKTOP-9844NL4",[[1,0,"---\ntitle: 阿里FastJson如何处理返回值中nulll值问题\ntags: java\ncategories: fastJson\n---"]],[0,0],[73,73]]],[1566271711540,["david@DESKTOP-9844NL4",[[-1,0,"---\ntitle: 阿里FastJson如何处理返回值中nulll值问题\ntags: java\ncategories: fastJson\n---"]],[73,73],[0,0]]],[1566271712216,["david@DESKTOP-9844NL4",[[1,0,"\n---\ntitle: 线程池之ThreadPoolExecutor使用\ncategories: java\ntags: 线程池\n---\n"]],[0,0],[0,68]]],[1566271713953,["david@DESKTOP-9844NL4",[[1,69,"\n"]],[68,68],[69,69]]],[1566271715401,["david@DESKTOP-9844NL4",[[1,69,"---\ntitle: 阿里FastJson如何处理返回值中nulll值问题\ntags: java\ncategories: fastJson\n---"]],[69,69],[142,142]]],[1566271716250,["david@DESKTOP-9844NL4",[[1,143,"\n"]],[142,142],[143,143]]],[1566271721376,["david@DESKTOP-9844NL4",[[-1,0,"\n"]],[1,1],[0,0]]],[1566271724841,["david@DESKTOP-9844NL4",[[-1,68,"---\ntitle: 阿里FastJson如何处理返回值中nulll值问题\ntags: java\ncategories: fastJson\n---"]],[68,141],[68,68]]],[1566271725118,["david@DESKTOP-9844NL4",[[-1,69,"\n"]],[68,68],[67,67]]],[1566271725521,["david@DESKTOP-9844NL4",[[-1,68,"\n"]],[67,67],[66,66]]],[1566271822396,["david@DESKTOP-9844NL4",[[1,1217,"\n"]],[1216,1216],[1217,1217]]],[1566271822900,["david@DESKTOP-9844NL4",[[1,1218,"\n"]],[1217,1217],[1218,1218]]],[1566271824926,["david@DESKTOP-9844NL4",[[1,1217,"《"]],[1217,1217],[1218,1218]]],[1566271825590,["david@DESKTOP-9844NL4",[[-1,1217,"《"]],[1218,1218],[1217,1217]]],[1566271830620,["david@DESKTOP-9844NL4",[[1,1217,"<!--more-->"]],[1217,1217],[1228,1228]]],[1566271834264,["david@DESKTOP-9844NL4",[[-1,1217,"<!--more-->"]],[1217,1228],[1217,1217]]],[1566271869175,["david@DESKTOP-9844NL4",[[1,1217,"<!-- more -->\n"]],[1217,1217],[1231,1231]]]],null,"david@DESKTOP-9844NL4"],["e355f454-25ec-41f6-a124-187fa0793e96",1574739072827,"---\ntitle: 线程池之ThreadPoolExecutor使用\ncategories: java\ntags: 线程池\n---\n\n### ThreadPoolExecutor构造方法\n![mark](http://blog.sjjtcloud.com/blog/20190819/voP4iKK3jVUw.png?imageslim)\n\n\n我们以最后一个构造方法（参数最多的那个），对其参数进行解释：\n\n```\n public ThreadPoolExecutor(int corePoolSize, // 1\n                              int maximumPoolSize,  // 2\n                              long keepAliveTime,  // 3\n                              TimeUnit unit,  // 4\n                              BlockingQueue<Runnable> workQueue, // 5\n                              ThreadFactory threadFactory,  // 6\n                              RejectedExecutionHandler handler ) { //7\n        if (corePoolSize < 0 ||\n            maximumPoolSize <= 0 ||\n            maximumPoolSize < corePoolSize ||\n            keepAliveTime < 0)\n            throw new IllegalArgumentException();\n        if (workQueue == null || threadFactory == null || handler == null)\n            throw new NullPointerException();\n        this.corePoolSize = corePoolSize;\n        this.maximumPoolSize = maximumPoolSize;\n        this.workQueue = workQueue;\n        this.keepAliveTime = unit.toNanos(keepAliveTime);\n        this.threadFactory = threadFactory;\n        this.handler = handler;\n    }\n\n```\n\n<!-- more -->\n\n\n| 序号 | 名称 | 类型 | 含义 |\n| --- | --- | --- | --- |\n| 1 | corePoolSize | int | 核心线程池大小 |\n| 2 | maximumPoolSize | int | 最大线程池大小 |\n| 3 | keepAliveTime | long | 线程最大空闲时间 |\n| 4 | unit | TimeUnit | 时间单位 |\n| 5 | workQueue | BlockingQueue<Runnable> | 线程等待队列 |\n| 6 | threadFactory | ThreadFactory | 线程创建工厂 |\n| 7 | handler | RejectedExecutionHandler | 拒绝策略 |\n\n如果对这些参数作用有疑惑的请看 [ThreadPoolExecutor概述](https://www.jianshu.com/p/c41e942bcd64)。\n知道了各个参数的作用后，我们开始构造符合我们期待的线程池。首先看JDK给我们预定义的几种线程池：\n\n### 预定义的线程池\n\n虽然这种创建线程池的方法比较简便，但是阿里巴巴开发规范中,明确指出禁止使用Executors来创建线程,因为这样创建线程池,有可能会导致OOM,  创建线程池应该使用ThreadPoolExecutor的方式, 其实这些创建线程池的方法,背后原理也是使用TreadPoolExecutor来创建的\n\n```\n【强制】\n线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样\n的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。\n说明：Executors 返回的线程池对象的弊端如下：\n\n1）FixedThreadPool 和 SingleThreadPool:\n允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。\n\n2）CachedThreadPool 和 ScheduledThreadPool:\n允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。\n\n```\n\n\n### Executors创建线程池\n\n`Executors`创建线程池方法列表：\n\n| 方法名 | 功能 |\n| --- | --- |\n| newFixedThreadPool(int nThreads) | 创建固定大小的线程池（请求队列不受限制） |\n| newSingleThreadExecutor() | 创建只有一个线程的线程池（请求队列不受限制） |\n| newCachedThreadPool() | 创建一个不限线程数上限的线程池，任何提交的任务都将立即执行（线程数不受限制） |\n| newScheduledThreadPool(int corePoolSize)   | 此线程池支持定时以及周期性执行任务的需求（线程数不受限制）|\n\n#### 源码分析\n\n1.  **FixedThreadPool**\n\n```\n    public static ExecutorService newFixedThreadPool(int nThreads) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue<Runnable>());\n    }\n\n```\n\n> *   corePoolSize与maximumPoolSize相等，即其线程全为核心线程，是一个固定大小的线程池，是其优势；\n> *   keepAliveTime = 0 该参数默认对核心线程无效，而FixedThreadPool全部为核心线程；\n> *   workQueue 为LinkedBlockingQueue（无界阻塞队列），队列最大值为Integer.MAX_VALUE。如果任务提交速度持续大余任务处理速度，会造成队列大量阻塞。因为队列很大，很有可能在拒绝策略前，内存溢出。是其劣势；\n> *   FixedThreadPool的任务执行是无序的；\n\n适用场景：可用于Web服务瞬时削峰，但需注意长时间持续高峰情况造成的队列阻塞。\n\n2.  **CachedThreadPool**\n\n```\n     public static ExecutorService newCachedThreadPool() {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue<Runnable>());\n    }\n\n```\n\n> *   corePoolSize = 0，maximumPoolSize = Integer.MAX_VALUE，即线程数量几乎无限制；\n> *   keepAliveTime = 60s，线程空闲60s后自动结束。\n> *   workQueue 为 SynchronousQueue 同步队列，这个队列类似于一个接力棒，入队出队必须同时传递，因为CachedThreadPool线程创建无限制，不会有队列等待，所以使用SynchronousQueue；\n\n适用场景：快速处理大量耗时较短的任务，如Netty的NIO接受请求时，可使用CachedThreadPool。\n\n3.  **SingleThreadExecutor**\n\n```\n    public static ExecutorService newSingleThreadExecutor() {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>()));\n    }\n\n```\n\n咋一瞅，不就是newFixedThreadPool(1)吗？定眼一看，这里多了一层FinalizableDelegatedExecutorService包装，这一层有什么用呢，写个dome来解释一下：\n\n```\n    public static void main(String[] args) {\n        ExecutorService fixedExecutorService = Executors.newFixedThreadPool(1);\n        ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) fixedExecutorService;\n        System.out.println(threadPoolExecutor.getMaximumPoolSize());\n        threadPoolExecutor.setCorePoolSize(8);\n\n        ExecutorService singleExecutorService = Executors.newSingleThreadExecutor();\n//      运行时异常 java.lang.ClassCastException\n//      ThreadPoolExecutor threadPoolExecutor2 = (ThreadPoolExecutor) singleExecutorService;\n    }\n\n```\n\n对比可以看出，FixedThreadPool可以向下转型为ThreadPoolExecutor，并对其线程池进行配置，而SingleThreadExecutor被包装后，无法成功向下转型。**因此，SingleThreadExecutor被定以后，无法修改，做到了真正的Single。**\n\n4.  **ScheduledThreadPool**\n\n```\n    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {\n        return new ScheduledThreadPoolExecutor(corePoolSize);\n    }\n\n```\n\nnewScheduledThreadPool调用的是ScheduledThreadPoolExecutor的构造方法，而ScheduledThreadPoolExecutor继承了ThreadPoolExecutor，构造是还是调用了其父类的构造方法。\n\n```\n    public ScheduledThreadPoolExecutor(int corePoolSize) {\n        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,\n              new DelayedWorkQueue());\n    }\n\n```\n\n\n\n\n##### 二、自定义线程池\n\n以下是自定义线程池，使用了有界队列，自定义ThreadFactory和拒绝策略的demo：\n\n```\npublic class ThreadTest {\n\n    public static void main(String[] args) throws InterruptedException, IOException {\n        int corePoolSize = 2;\n        int maximumPoolSize = 4;\n        long keepAliveTime = 10;\n        TimeUnit unit = TimeUnit.SECONDS;\n        BlockingQueue<Runnable> workQueue = new ArrayBlockingQueue<>(2);\n        ThreadFactory threadFactory = new NameTreadFactory();\n        RejectedExecutionHandler handler = new MyIgnorePolicy();\n        ThreadPoolExecutor executor = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit,\n                workQueue, threadFactory, handler);\n        executor.prestartAllCoreThreads(); // 预启动所有核心线程\n\n        for (int i = 1; i <= 10; i++) {\n            MyTask task = new MyTask(String.valueOf(i));\n            executor.execute(task);\n        }\n\n        System.in.read(); //阻塞主线程\n    }\n\n    static class NameTreadFactory implements ThreadFactory {\n\n        private final AtomicInteger mThreadNum = new AtomicInteger(1);\n\n        @Override\n        public Thread newThread(Runnable r) {\n            Thread t = new Thread(r, \"my-thread-\" + mThreadNum.getAndIncrement());\n            System.out.println(t.getName() + \" has been created\");\n            return t;\n        }\n    }\n\n    public static class MyIgnorePolicy implements RejectedExecutionHandler {\n\n        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n            doLog(r, e);\n        }\n\n        private void doLog(Runnable r, ThreadPoolExecutor e) {\n            // 可做日志记录等\n            System.err.println( r.toString() + \" rejected\");\n//          System.out.println(\"completedTaskCount: \" + e.getCompletedTaskCount());\n        }\n    }\n\n    static class MyTask implements Runnable {\n        private String name;\n\n        public MyTask(String name) {\n            this.name = name;\n        }\n\n        @Override\n        public void run() {\n            try {\n                System.out.println(this.toString() + \" is running!\");\n                Thread.sleep(3000); //让任务执行慢点\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        @Override\n        public String toString() {\n            return \"MyTask [name=\" + name + \"]\";\n        }\n    }\n}\n\n```\n\n输出结果如下：\n\n![](//upload-images.jianshu.io/upload_images/11183270-ef3cb072affbec03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/398/format/webp)\n\nimage.png\n\n其中线程线程1-4先占满了核心线程和最大线程数量，然后4、5线程进入等待队列，7-10线程被直接忽略拒绝执行，等1-4线程中有线程执行完后通知4、5线程继续执行。\n\n#### 总结，通过自定义线程池，我们可以更好的让线程池为我们所用，更加适应我的实际场景。\n\n\n\n",[[1574739032644,["david@DESKTOP-9844NL4",[[-1,33,"使用"]],[35,35],[33,33]]],[1574739034527,["david@DESKTOP-9844NL4",[[1,33,"详解"]],[33,33],[35,35]]],[1574739037844,["david@DESKTOP-9844NL4",[[-1,14,"之"]],[15,15],[14,14]]],[1574739038554,["david@DESKTOP-9844NL4",[[1,14,"-"]],[14,14],[15,15]]],[1574739039741,["david@DESKTOP-9844NL4",[[1,15,"\n"]],[15,15],[16,16]]],[1574739041202,["david@DESKTOP-9844NL4",[[-1,15,"\n"]],[16,16],[15,15]]],[1574739107770,["david@DESKTOP-9844NL4",[[1,1580,"\n"]],[1579,1579],[1580,1580]]],[1574739110073,["david@DESKTOP-9844NL4",[[-1,1580,"\n"]],[1580,1580],[1579,1579]]],[1574739110616,["david@DESKTOP-9844NL4",[[1,1580,"\n"]],[1579,1579],[1580,1580]]],[1574739126573,["david@DESKTOP-9844NL4",[[1,1479,"（"]],[1479,1479],[1480,1480]]],[1574739127611,["david@DESKTOP-9844NL4",[[-1,1479,"（"]],[1480,1480],[1479,1479]]],[1574739140426,["david@DESKTOP-9844NL4",[[1,1479,"(用来暂时保存任务的工作队列)"]],[1479,1479],[1494,1494]]],[1574739165663,["david@DESKTOP-9844NL4",[[1,1591,"(：当ThreadPoolExecutor已经关闭或ThreadPoolExecutor已经饱和\n时（达到了最大线程池大小且工作队列已满），execute()方法将要调用的Handler。)"]],[1591,1591],[1686,1686]]],[1574739171281,["david@DESKTOP-9844NL4",[[-1,1639,"\n"]],[1640,1640],[1639,1639]]],[1574739181897,["david@DESKTOP-9844NL4",[[-1,1592,"："]],[1593,1593],[1592,1592]]],[1574739397989,["david@DESKTOP-9844NL4",[[1,2659,"x"]],[2659,2659],[2660,2660]]],[1574739398679,["david@DESKTOP-9844NL4",[[-1,2659,"x"]],[2660,2660],[2659,2659]]],[1574739400101,["david@DESKTOP-9844NL4",[[1,2659,"详解"]],[2659,2659],[2661,2661]]],[1574739493637,["david@DESKTOP-9844NL4",[[1,2664,"2. \n"]],[2663,2663],[2667,2667]]],[1574739494863,["david@DESKTOP-9844NL4",[[-1,2664,"2. "]],[2667,2667],[2664,2664]]],[1574739495337,["david@DESKTOP-9844NL4",[[1,2664,"被称为可重用固定线程数的线程池"]],[2664,2664],[2679,2679]]],[1574739503783,["david@DESKTOP-9844NL4",[[1,2664,"FixedThreadPool "]],[2664,2664],[2680,2680]]],[1574739650106,["david@DESKTOP-9844NL4",[[-1,3041,"是其优势"]],[3041,3045],[3041,3041]]],[1574739667516,["david@DESKTOP-9844NL4",[[1,3018,"都被指定为创建时"]],[3018,3018],[3026,3026]]],[1574739679551,["david@DESKTOP-9844NL4",[[-1,3020,"指定为创建时"]],[3026,3026],[3020,3020]]],[1574739699867,["david@DESKTOP-9844NL4",[[1,3020,"设置为创建FixedThredPool时指定的参数N"]],[3020,3020],[3046,3046]]],[1574739700282,["david@DESKTOP-9844NL4",[[-1,3045,"N"]],[3046,3046],[3045,3045]]],[1574739705086,["david@DESKTOP-9844NL4",[[1,3045,"nThreads("]],[3045,3045],[3054,3054]]],[1574739709261,["david@DESKTOP-9844NL4",[[-1,3076,"，"]],[3077,3077],[3076,3076]]],[1574739711209,["david@DESKTOP-9844NL4",[[1,3076,")"]],[3076,3076],[3077,3077]]],[1574739716179,["david@DESKTOP-9844NL4",[[-1,3017,"，"]],[3018,3018],[3017,3017]]],[1574739716827,["david@DESKTOP-9844NL4",[[1,3017,"，"]],[3017,3017],[3018,3018]]],[1574739717625,["david@DESKTOP-9844NL4",[[-1,3017,"，"]],[3018,3018],[3017,3017]]],[1574739718047,["david@DESKTOP-9844NL4",[[1,3017,","]],[3017,3017],[3018,3018]]],[1574739764596,["david@DESKTOP-9844NL4",[[1,3079,"\n"]],[3078,3078],[3079,3079]]],[1574739767856,["david@DESKTOP-9844NL4",[[1,3079,"> * 当线程池中的线程数大于corePoolSize时，keepAliveTime为多余的空闲线程等待新任务的\n最长时间，超过这个时间后多余的线程将被终止。这里把keepAliveTime设置为0L，意味着多余\n的空闲线程会被立即终止"]],[3079,3079],[3197,3197]]],[1574739771244,["david@DESKTOP-9844NL4",[[-1,3135,"\n"]],[3136,3136],[3135,3135]]],[1574739774759,["david@DESKTOP-9844NL4",[[-1,3184,"\n"]],[3185,3185],[3184,3184]]],[1574739778152,["david@DESKTOP-9844NL4",[[1,3196,"\n"]],[3195,3195],[3196,3196]]],[1574739786503,["david@DESKTOP-9844NL4",[[1,3079,"\n"]],[3078,3078],[3079,3079]]],[1574739801425,["david@DESKTOP-9844NL4",[[-1,3204,"keepAliveTime = 0 该参数默认对核心线程无效，而FixedThreadPool全部为核心线程；\n> *   "]],[3197,3259],[3197,3197]]],[1574739805191,["david@DESKTOP-9844NL4",[[1,3204,"keepAliveTime = 0 该参数默认对核心线程无效，而FixedThreadPool全部为核心线程；\n> *   "]],[3197,3197],[3197,3259]]],[1574739812437,["david@DESKTOP-9844NL4",[[-1,3122,"为"]],[3123,3123],[3122,3122]]],[1574739813315,["david@DESKTOP-9844NL4",[[1,3122,":"]],[3122,3122],[3123,3123]]],[1574739814029,["david@DESKTOP-9844NL4",[[-1,3122,":"]],[3123,3123],[3122,3122]]],[1574739817789,["david@DESKTOP-9844NL4",[[1,3122,"表示的就是："]],[3122,3122],[3128,3128]]],[1574739845664,["david@DESKTOP-9844NL4",[[-1,3202,"\n"]],[3202,3202],[3201,3201]]],[1574739847579,["david@DESKTOP-9844NL4",[[1,3202,"\n"]],[3201,3201],[3202,3202]]],[1574739848166,["david@DESKTOP-9844NL4",[[-1,3202,"\n"]],[3202,3202],[3201,3201]]],[1574747726492,["david@DESKTOP-9844NL4",[[-1,5710,"\n"]],[5709,5709],[5708,5708]]],[1574747726959,["david@DESKTOP-9844NL4",[[-1,5709,"\n"]],[5708,5708],[5707,5707]]],[1574747804759,["david@DESKTOP-9844NL4",[[1,4078,"SingleThreadExecutor是使用单个worker线程的Executor"]],[4078,4078],[4120,4120]]],[1574747807637,["david@DESKTOP-9844NL4",[[1,4121,"\n"]],[4120,4120],[4121,4121]]],[1574747807974,["david@DESKTOP-9844NL4",[[1,4121,"、"]],[4121,4121],[4122,4122]]],[1574747808863,["david@DESKTOP-9844NL4",[[-1,4121,"、"]],[4122,4122],[4121,4121]]],[1574747809171,["david@DESKTOP-9844NL4",[[-1,4121,"\n"]],[4121,4121],[4120,4120]]],[1574747809815,["david@DESKTOP-9844NL4",[[1,4121,"\n"]],[4120,4120],[4121,4121]]],[1574747860191,["david@DESKTOP-9844NL4",[[1,4435,"\n"]],[4434,4434],[4435,4435]]],[1574747862094,["david@DESKTOP-9844NL4",[[1,4434,"》"]],[4434,4434],[4435,4435]]],[1574747862761,["david@DESKTOP-9844NL4",[[-1,4434,"》"]],[4435,4435],[4434,4434]]],[1574747863387,["david@DESKTOP-9844NL4",[[1,4434,">"]],[4434,4434],[4435,4435]]],[1574747864151,["david@DESKTOP-9844NL4",[[1,4435,"SingleThreadExecutor的corePoolSize和maximumPoolSize被设置为1。其他参数与\nFixedThreadPool相同"]],[4435,4435],[4513,4513]]],[1574747866996,["david@DESKTOP-9844NL4",[[1,4434,"\n"]],[4434,4434],[4435,4435]]],[1574747868022,["david@DESKTOP-9844NL4",[[1,4436," "]],[4436,4436],[4437,4437]]],[1574747870849,["david@DESKTOP-9844NL4",[[-1,4497,"\n"]],[4498,4498],[4497,4497]]],[1574747878540,["david@DESKTOP-9844NL4",[[1,4437,"* "]],[4437,4437],[4439,4439]]],[1574747882901,["david@DESKTOP-9844NL4",[[1,4518,"\n"]],[4516,4516],[4517,4517]]],[1574747896130,["david@DESKTOP-9844NL4",[[1,4517,"> * 。SingleThreadExecutor使"]],[4517,4517],[4543,4543]]],[1574747899055,["david@DESKTOP-9844NL4",[[-1,4521,"。"]],[4522,4522],[4521,4521]]],[1574747910116,["david@DESKTOP-9844NL4",[[1,4542,"用无界队列LinkedBlockingQueue作为线程池的工\n作队列（队列的容量为Integer.MAX_VALUE）"]],[4542,4542],[4602,4602]]],[1574747913098,["david@DESKTOP-9844NL4",[[-1,4573,"\n"]],[4574,4574],[4573,4573]]],[1574747918128,["david@DESKTOP-9844NL4",[[1,4603,"\n"]],[4601,4601],[4602,4602]]],[1574747919350,["david@DESKTOP-9844NL4",[[1,4602,"》"]],[4602,4602],[4603,4603]]],[1574747919991,["david@DESKTOP-9844NL4",[[-1,4602,"》"]],[4603,4603],[4602,4602]]],[1574747921823,["david@DESKTOP-9844NL4",[[1,4602,"> *"]],[4602,4602],[4605,4605]]],[1574747922676,["david@DESKTOP-9844NL4",[[-1,4604,"*"]],[4605,4605],[4604,4604]]],[1574747924393,["david@DESKTOP-9844NL4",[[1,4604,"* "]],[4604,4604],[4606,4606]]],[1574747933262,["david@DESKTOP-9844NL4",[[-1,4582,"为"]],[4583,4583],[4582,4582]]],[1574747934870,["david@DESKTOP-9844NL4",[[1,4582,"为"]],[4582,4582],[4583,4583]]],[1574748017196,["david@DESKTOP-9844NL4",[[1,4517,"\n"]],[4516,4516],[4517,4517]]],[1574748017879,["david@DESKTOP-9844NL4",[[-1,4517,"\n"]],[4517,4517],[4516,4516]]],[1574748018837,["david@DESKTOP-9844NL4",[[1,4517,"\n"]],[4516,4516],[4517,4517]]],[1574748021605,["david@DESKTOP-9844NL4",[[-1,4601,"）"]],[4602,4602],[4601,4601]]],[1574748023340,["david@DESKTOP-9844NL4",[[1,4601,")"]],[4601,4601],[4602,4602]]],[1574748024069,["david@DESKTOP-9844NL4",[[1,4603,"\n"]],[4602,4602],[4603,4603]]],[1574748253881,["david@DESKTOP-9844NL4",[[1,3490,"3. \n"]],[3489,3489],[3493,3493]]],[1574748255343,["david@DESKTOP-9844NL4",[[-1,3490,"3. "]],[3493,3493],[3490,3490]]],[1574748255810,["david@DESKTOP-9844NL4",[[1,3490,"l是一个会根据需要创建新线程的线程池"]],[3490,3490],[3508,3508]]],[1574748260441,["david@DESKTOP-9844NL4",[[-1,3490,"l"]],[3491,3491],[3490,3490]]],[1574748261848,["david@DESKTOP-9844NL4",[[1,3490,"CachedThreadPool "]],[3490,3490],[3507,3507]]],[1574748455934,["david@DESKTOP-9844NL4",[[1,4027,"\n"]],[4025,4025],[4026,4026]]],[1574748457767,["david@DESKTOP-9844NL4",[[1,4026,"* "]],[4026,4026],[4028,4028]]],[1574748489132,["david@DESKTOP-9844NL4",[[1,4028,"。CachedThreadPool使用没有容量的SynchronousQueue作为线程池的工作队列，但\nCachedThreadPool的maximumPool是无界的。这意味着，如果主线程提交任务的速度高于\nmaximumPool中线程处理任务的速度时，CachedThreadPool会不断创建新线程。极端情况下，\nCachedThreadPool会因为创建过多线程而耗尽CPU和内存资源"]],[4028,4028],[4225,4225]]],[1574748491676,["david@DESKTOP-9844NL4",[[-1,4027," 。"]],[4029,4029],[4027,4027]]],[1574748492488,["david@DESKTOP-9844NL4",[[1,4027," "]],[4027,4027],[4028,4028]]],[1574748494796,["david@DESKTOP-9844NL4",[[-1,4027," "]],[4028,4028],[4027,4027]]],[1574748496802,["david@DESKTOP-9844NL4",[[1,4026,"> "]],[4026,4026],[4028,4028]]],[1574748499513,["david@DESKTOP-9844NL4",[[-1,4080,"\n"]],[4081,4081],[4080,4080]]],[1574748502076,["david@DESKTOP-9844NL4",[[-1,4079,"但"]],[4080,4080],[4079,4079]]],[1574748502775,["david@DESKTOP-9844NL4",[[1,4079,"\n"]],[4079,4079],[4080,4080]]],[1574748505517,["david@DESKTOP-9844NL4",[[1,4080,">* "]],[4080,4080],[4083,4083]]],[1574748506616,["david@DESKTOP-9844NL4",[[1,4081," "]],[4081,4081],[4082,4082]]],[1574748510873,["david@DESKTOP-9844NL4",[[1,4029," "]],[4029,4029],[4030,4030]]],[1574748516075,["david@DESKTOP-9844NL4",[[-1,4137,"\n"]],[4138,4138],[4137,4137]]],[1574748520498,["david@DESKTOP-9844NL4",[[-1,4191,"\n"]],[4192,4192],[4191,4191]]],[1574748521337,["david@DESKTOP-9844NL4",[[-1,4190,"，"]],[4191,4191],[4190,4190]]],[1574748522433,["david@DESKTOP-9844NL4",[[1,4190,"，"]],[4190,4190],[4191,4191]]],[1574748523698,["david@DESKTOP-9844NL4",[[-1,4190,"，"]],[4191,4191],[4190,4190]]],[1574748524368,["david@DESKTOP-9844NL4",[[1,4190,","]],[4190,4190],[4191,4191]]],[1574748553674,["david@DESKTOP-9844NL4",[[-1,3971,"为"]],[3972,3972],[3971,3971]]],[1574748555078,["david@DESKTOP-9844NL4",[[1,3971,"为"]],[3971,3971],[3972,3972]]],[1574748558377,["david@DESKTOP-9844NL4",[[1,4026,"\n"]],[4025,4025],[4026,4026]]],[1574748564139,["david@DESKTOP-9844NL4",[[-1,4755,"\n"]],[4755,4755],[4754,4754]]],[1574748738368,["david@DESKTOP-9844NL4",[[-1,5858,"newScheduledThreadPool"],[1,5880,"x"]],[5858,5880],[5859,5859]]],[1574748741224,["david@DESKTOP-9844NL4",[[1,5858,"newScheduledThreadPool"],[-1,5858,"x"]],[5859,5859],[5858,5880]]],[1574748869619,["david@DESKTOP-9844NL4",[[-1,5671,"Scheduled"],[1,5690,"Executor "]],[5671,5690],[5690,5690]]],[1574748880552,["david@DESKTOP-9844NL4",[[1,3487,"x"]],[3487,3487],[3488,3488]]],[1574748881465,["david@DESKTOP-9844NL4",[[-1,3487,"x"]],[3488,3488],[3487,3487]]],[1574748883955,["david@DESKTOP-9844NL4",[[1,3487,"详细"]],[3487,3487],[3489,3489]]],[1574748884215,["david@DESKTOP-9844NL4",[[-1,3488,"细"]],[3489,3489],[3488,3488]]],[1574748885207,["david@DESKTOP-9844NL4",[[1,3488,"解"]],[3488,3488],[3489,3489]]],[1574748890340,["david@DESKTOP-9844NL4",[[1,4315,"详解"]],[4315,4315],[4317,4317]]],[1574748896981,["david@DESKTOP-9844NL4",[[1,5694,"详解"]],[5694,5694],[5696,5696]]],[1574748898764,["david@DESKTOP-9844NL4",[[1,5699,"5. \n"]],[5698,5698],[5702,5702]]],[1574748899793,["david@DESKTOP-9844NL4",[[-1,5699,"5. "]],[5702,5702],[5699,5699]]],[1574748908151,["david@DESKTOP-9844NL4",[[1,5675,"\nScheduled"],[-1,5693," "],[1,5694,"继"]],[5675,5694],[5704,5704]]],[1574748911240,["david@DESKTOP-9844NL4",[[-1,5675,"\n"]],[5676,5676],[5675,5675]]],[1574748951366,["david@DESKTOP-9844NL4",[[-1,4296,"ing"],[1,4299,"chedu"],[1,4301,"d"],[-1,4307,"Executor"],[1,4315,"Pool"]],[4295,4315],[4314,4314]]],[1574748953859,["david@DESKTOP-9844NL4",[[-1,4314,"详解"]],[4316,4316],[4314,4314]]],[1574748956568,["david@DESKTOP-9844NL4",[[-1,4317,"SingleThreadExecutor是使用单个worker线程的Executor"]],[4317,4359],[4317,4317]]],[1574748957196,["david@DESKTOP-9844NL4",[[-1,4318,"\n"]],[4317,4317],[4316,4316]]],[1574749016777,["david@DESKTOP-9844NL4",[[-1,4296,"chedu"],[1,4301,"ing"],[-1,4303,"d"],[-1,4310,"Pool"],[1,4314,"Executor"]],[4295,4314],[4315,4315]]],[1574749038483,["david@DESKTOP-9844NL4",[[-1,5649,"Executor继"]],[5630,5657],[5649,5649]]],[1574749052666,["david@DESKTOP-9844NL4",[[1,5654,"ScheduledThreadPoolExecutor继承自ThreadPoolExecutor。它主要用来在给定的延迟之后运\n行任务，或者定期执行任务。ScheduledThreadPoolExecutor的功能与Timer类似，但\nScheduledThreadPoolExecutor功能更强大、更灵活。Timer对应的是单个后台线程，而\nScheduledThreadPoolExecutor可以在构造函数中指定多个对应的后台线程数。"]],[5654,5654],[5875,5875]]],[1574749054297,["david@DESKTOP-9844NL4",[[1,5654,"5. \n"]],[5653,5653],[5657,5657]]],[1574749055704,["david@DESKTOP-9844NL4",[[-1,5654,"5. "]],[5657,5657],[5654,5654]]],[1574749055926,["david@DESKTOP-9844NL4",[[-1,5654,"\n"]],[5654,5654],[5653,5653]]],[1574749074443,["david@DESKTOP-9844NL4",[[-1,5654,"ScheduledThreadPoolExecutor继承自ThreadPoolExecutor。它主要用来在给定的延迟之后运\n行任务，或者定期执行任务。ScheduledThreadPoolExecutor的功能与Timer类似，但\nScheduledThreadPoolExecutor功能更强大、更灵活。Timer对应的是单个后台线程，而\nScheduledThreadPoolExecutor可以在构造函数中指定多个对应的后台线程数。\n"]],[5654,5876],[5654,5654]]],[1574749082981,["david@DESKTOP-9844NL4",[[1,5947,"\n"]],[5945,5945],[5946,5946]]],[1574749083198,["david@DESKTOP-9844NL4",[[1,5948,"\n"]],[5946,5946],[5947,5947]]],[1574749084376,["david@DESKTOP-9844NL4",[[1,5947,"ScheduledThreadPoolExecutor继承自ThreadPoolExecutor。它主要用来在给定的延迟之后运\n行任务，或者定期执行任务。ScheduledThreadPoolExecutor的功能与Timer类似，但\nScheduledThreadPoolExecutor功能更强大、更灵活。Timer对应的是单个后台线程，而\nScheduledThreadPoolExecutor可以在构造函数中指定多个对应的后台线程数。\n"]],[5947,5947],[6169,6169]]],[1574749099820,["david@DESKTOP-9844NL4",[[-1,5877,"，而ScheduledThreadPoolExecutor继承了ThreadPoolExecutor，构造是还是调用了其父类的构造方法。"]],[5878,5945],[5877,5877]]],[1574749105480,["david@DESKTOP-9844NL4",[[1,5819,"》"]],[5819,5819],[5820,5820]]],[1574749106253,["david@DESKTOP-9844NL4",[[-1,5819,"》"]],[5820,5820],[5819,5819]]],[1574749107269,["david@DESKTOP-9844NL4",[[1,5819,"》 "]],[5819,5819],[5821,5821]]],[1574749107925,["david@DESKTOP-9844NL4",[[-1,5819,"》 "]],[5821,5821],[5819,5819]]],[1574749110495,["david@DESKTOP-9844NL4",[[1,5819,"> * "]],[5819,5819],[5823,5823]]],[1574749114795,["david@DESKTOP-9844NL4",[[1,5883,">* "]],[5883,5883],[5886,5886]]],[1574749116564,["david@DESKTOP-9844NL4",[[1,5884," "]],[5884,5884],[5885,5885]]],[1574749119360,["david@DESKTOP-9844NL4",[[-1,5950,"\n"]],[5951,5951],[5950,5950]]],[1574749125091,["david@DESKTOP-9844NL4",[[-1,6003,"\n"]],[6004,6004],[6003,6003]]],[1574749128526,["david@DESKTOP-9844NL4",[[-1,6057,"\n"]],[6058,6058],[6057,6057]]],[1574749135832,["david@DESKTOP-9844NL4",[[-1,6104,"。"]],[6105,6105],[6104,6104]]],[1574749138627,["david@DESKTOP-9844NL4",[[1,6104,". "]],[6104,6104],[6106,6106]]],[1574749153290,["david@DESKTOP-9844NL4",[[-1,5576,"，"]],[5577,5577],[5576,5576]]]],null,"david@DESKTOP-9844NL4"]]}