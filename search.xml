<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/2019/12/24/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95-%E5%90%8D%E8%AF%8D/</url>
    <content><![CDATA[<h2 id="英语语法-名词"><a href="#英语语法-名词" class="headerlink" title="英语语法-名词"></a>英语语法-名词</h2><h3 id="1-名词复数规则变化"><a href="#1-名词复数规则变化" class="headerlink" title="1.名词复数规则变化"></a>1.名词复数规则变化</h3><table>
<thead>
<tr>
<th>情况</th>
<th>构成方法</th>
<th style="text-align:right">读音</th>
<th style="text-align:right">例词</th>
</tr>
</thead>
<tbody>
<tr>
<td>一般情况</td>
<td>加-s</td>
<td style="text-align:right">/s/</td>
<td style="text-align:right">map-maps</td>
</tr>
<tr>
<td>以s,x,ch,sh结尾</td>
<td>加-es</td>
<td style="text-align:right">/iz/</td>
<td style="text-align:right">bus-buses</td>
</tr>
<tr>
<td>以ce,se,ze,(d)ge结尾</td>
<td>加-s</td>
<td style="text-align:right">/iz/</td>
<td style="text-align:right">license-licenses</td>
</tr>
<tr>
<td>以辅音字母+y结尾的词</td>
<td>变y为i,再加-es</td>
<td style="text-align:right">/z/</td>
<td style="text-align:right">baby-babies</td>
</tr>
</tbody>
</table>
<h3 id="2-其他名词复数规则变化"><a href="#2-其他名词复数规则变化" class="headerlink" title="2.其他名词复数规则变化"></a>2.其他名词复数规则变化</h3><table>
<thead>
<tr>
<th>情况</th>
<th>构成方法</th>
<th style="text-align:right">例词</th>
</tr>
</thead>
<tbody>
<tr>
<td>以y结尾的专有名词或元音字母+y结尾的名词</td>
<td>加-s</td>
<td style="text-align:right">two marrys,monkey-monkeys,holiday-holidays</td>
</tr>
<tr>
<td>以o结尾的名词</td>
<td>加-s</td>
<td style="text-align:right">photo-photos,radio-radios,zoo-zoos</td>
</tr>
<tr>
<td>以o结尾的名词</td>
<td>加-es</td>
<td style="text-align:right">potato-potatoes,tomato-tomatoes</td>
</tr>
<tr>
<td>以o结尾的名词</td>
<td>均s,es均可</td>
<td style="text-align:right">zero-zeros/zeroes</td>
</tr>
<tr>
<td>以f或fe结尾的</td>
<td>加-s</td>
<td style="text-align:right">roof-roofs</td>
</tr>
<tr>
<td>以f或fe结尾的</td>
<td>去f,fe加-ves</td>
<td style="text-align:right">knife-knives,leaf-leaves,wolf-wolves,wife-wives</td>
</tr>
<tr>
<td>以f或fe结尾的</td>
<td>均可</td>
<td style="text-align:right">handkerchief-handkerchies/handkerchieves</td>
</tr>
</tbody>
</table>
<h3 id="3-名词复数的不规则变化"><a href="#3-名词复数的不规则变化" class="headerlink" title="3.名词复数的不规则变化"></a>3.名词复数的不规则变化</h3><p>1) child–children  foot—feet  tooth–teeth mouse–mice  man–men  woman–women<br>注意: 与man和woman构成的合成词,其复数形式也是-men 和-women 如：an englishwoman，two englishwomen</p>
<p>2) 单复同形<br>3) </p>
<h3 id="4-不可数名词量的表示"><a href="#4-不可数名词量的表示" class="headerlink" title="4.不可数名词量的表示"></a>4.不可数名词量的表示</h3><h3 id="5-定语名词的复数"><a href="#5-定语名词的复数" class="headerlink" title="5.定语名词的复数"></a>5.定语名词的复数</h3><h3 id="6-不同国家的人的单复数"><a href="#6-不同国家的人的单复数" class="headerlink" title="6.不同国家的人的单复数"></a>6.不同国家的人的单复数</h3><h3 id="7-名词的格"><a href="#7-名词的格" class="headerlink" title="7.名词的格"></a>7.名词的格</h3>]]></content>
  </entry>
  <entry>
    <title>微信小程序生成分享码</title>
    <url>/2019/12/24/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%94%9F%E6%88%90%E5%88%86%E4%BA%AB%E7%A0%81%E5%8F%8A%E8%B7%B3%E8%BD%AC%E9%A1%B5%E9%9D%A2/</url>
    <content><![CDATA[<h3 id="1-小程序码介绍"><a href="#1-小程序码介绍" class="headerlink" title="1.小程序码介绍"></a>1.小程序码介绍</h3><p>小程序开发文档:<a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html</a></p>
<p>微信小程序 允许开发者生成跳转到某个页面的小程序码, 在用户扫码后跳转到指定页面时，也可以附加参数,附加的参数在小程序端可以获取到</p>
<p>从微信小程序开发文档上我们可以了解到，目前微信支持两种二维码（左），小程序码和小程序二维码（右）。官方推荐使用小程序码，因为小程序码具有更好的辨识度。</p>
<p><img src="http://blog.sjjtcloud.com/blog/20191101/VrrAc4pUi9ik.png?imageslim" alt="mark"></p>
<p>官方提供生成小程序码的两种方式 </p>
<p>方式一： 适用于 <strong>需要的码的数量相对较少的业务场景,通过该接口生成的小程序码，有数量限制,永久有效</strong>，(这种方式不能附带额外的自定义参数) </p>
<p><img src="http://blog.sjjtcloud.com/blog/20191101/ImDmWeP34i1f.png?imageslim" alt="mark"></p>
<ul>
<li><p>接口地址: <a href="https://api.weixin.qq.com/wxa/getwxacode?access_token=ACCESS_TOKEN" target="_blank" rel="noopener">https://api.weixin.qq.com/wxa/getwxacode?access_token=ACCESS_TOKEN</a></p>
</li>
<li><p>具体参数参考微信官方文档:<br>[<a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.get.html]" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.get.html]</a></p>
</li>
</ul>
<p>方式二: 适用于使用数量极多的场景（可以附带额外的自定义参数）。<br><img src="http://blog.sjjtcloud.com/blog/20191101/vShaY0JQCeGi.png?imageslim" alt="mark"></p>
<ul>
<li><p>接口地址：<a href="https://api.weixin.qq.com/wxa/getwxacodeunlimit?access_token=ACCESS_TOKEN" target="_blank" rel="noopener">https://api.weixin.qq.com/wxa/getwxacodeunlimit?access_token=ACCESS_TOKEN</a></p>
</li>
<li><p>具体参数参考微信官方文档：<a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html</a></p>
</li>
</ul>
<p>注意:<br> 两种方式均需要获取 ACCESS_TOEKN，微信提供的开发者工具中也 可以在线获取，<a href="https://mp.weixin.qq.com/debug/" target="_blank" rel="noopener">https://mp.weixin.qq.com/debug/</a></p>
<h3 id="2-后台获取小程序码DEMO（演示第一种获取方式-生成的二维码扫码后直接跳转到指定页面）"><a href="#2-后台获取小程序码DEMO（演示第一种获取方式-生成的二维码扫码后直接跳转到指定页面）" class="headerlink" title="2. 后台获取小程序码DEMO（演示第一种获取方式,生成的二维码扫码后直接跳转到指定页面）"></a>2. 后台获取小程序码DEMO（演示第一种获取方式,生成的二维码扫码后直接跳转到指定页面）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpUtilTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String token = <span class="string">"27_b7dbAFkuHIrKjeiYA05TOYoMlgD723P_lfMZwfhofQA_FcpXXZ3thuLOUmyFy9OZH9nXMvgMjm683SzVJa0w2MshxZ2TGT90aY7H2IxEdwtdLQoY4srLv3vbMZgZOVgAIATIP"</span>;</span><br><span class="line">        <span class="comment">//使用第一种 获取方式获取小程序码</span></span><br><span class="line">  String url = <span class="string">"https://api.weixin.qq.com/wxa/getwxacode?access_token="</span>+token;</span><br><span class="line">        Map&lt;String,Object&gt; data = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">        Map&lt;String,Object&gt; color = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        data.put(<span class="string">"path"</span>,<span class="string">"pages/quickly/quickly"</span>);</span><br><span class="line">        data.put(<span class="string">"auto_color"</span>,<span class="keyword">false</span>);</span><br><span class="line">        data.put(<span class="string">"width"</span>,<span class="number">450</span>);</span><br><span class="line">        color.put(<span class="string">"r"</span>,<span class="number">0</span>);</span><br><span class="line">        color.put(<span class="string">"g"</span>,<span class="number">0</span>);</span><br><span class="line">        color.put(<span class="string">"b"</span>,<span class="number">0</span>);</span><br><span class="line">        data.put(<span class="string">"line_color"</span>,color);</span><br><span class="line">        HttpRequest request = HttpUtil.createPost(url);</span><br><span class="line">        request.body(JSONUtil.toJsonStr(data));</span><br><span class="line">        HttpResponse response = request.execute();</span><br><span class="line">        <span class="comment">//请求接口返回的图片的字节码，直接写入本地文件就可以</span></span><br><span class="line">        <span class="keyword">byte</span>[] imgBytes = response.bodyBytes();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            OutputStream outputStream = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"h:/jumpToQuick.jpg"</span>));</span><br><span class="line">            IoUtil.write(outputStream,<span class="keyword">true</span>,imgBytes);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-前端请求获取小程序码"><a href="#3-前端请求获取小程序码" class="headerlink" title="3.前端请求获取小程序码"></a>3.前端请求获取小程序码</h3><p>因为第二中方法可生成的小程序码极多，所以我们一般会使用这种方法来获取小程序码。  今天主要像大家介绍一下第二种方法。</p>
<p>一般我们主要常用的参数是：scene（如果需要页面参数）、page和width。  page是页面地址，例如：’pages/index’。<strong>pages前面不能有斜杠</strong>  scene是参数，为字符串。比如要传入一个用户id=1234，要根据这个用户id来给当前页面返回不同的内容，那么scene参数就可以写成”1234”，多个参数按一定规则分开，如&amp;符号，第二个参数是recommendId=123则可以这样写”1234&amp;123”。我们来开一下代码：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line"> data:&#123;&#125;,</span><br><span class="line"> getQrcode()&#123;</span><br><span class="line"> wx.request(&#123;</span><br><span class="line"> url: <span class="string">"https://www....com/weixin/get-qrcode"</span>,<span class="comment">//域名省略</span></span><br><span class="line"> data: &#123;</span><br><span class="line"> page:<span class="string">"pages/index"</span>,</span><br><span class="line"> scene:<span class="string">"1234&amp;123"</span>,</span><br><span class="line"> width:<span class="number">300</span></span><br><span class="line"> &#125;,</span><br><span class="line"> header: &#123;</span><br><span class="line"> <span class="string">'content-type'</span>: <span class="string">'application/x-www-form-urlencoded'</span></span><br><span class="line"> &#125;,</span><br><span class="line"> method:  <span class="string">'POST'</span>,</span><br><span class="line"> dataType: <span class="string">'json'</span>,</span><br><span class="line"> success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">let</span> qrcodeUrl=res.data;<span class="comment">//服务器小程序码地址</span></span><br><span class="line"> &#125;,</span><br><span class="line"> fail: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line"> complete: options.complete || <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"> &#125;)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>解析：get-qrcode接口是自己小程序后端的接口，前端调用此接口，传入相应参数，后台通过参数请求小程序接口获取到小程序码存到自己服务上，返回小程序码服务器地址。</p>
<h3 id="3-用户扫码进入后的逻辑"><a href="#3-用户扫码进入后的逻辑" class="headerlink" title="3.用户扫码进入后的逻辑"></a>3.用户扫码进入后的逻辑</h3><p>我们可以在onload生命周期中处理参数</p>
<p>onLoad:function(options){<br> if(options.scene){<br> let scene=decodeURIComponent(options.scene);<br> //&amp;是我们定义的参数链接方式<br> let userId=scene.split(“&amp;”)[0];<br> let recommendId=scene.split(‘&amp;’)[1];<br> //其他逻辑处理。。。。。<br> }<br>}</p>
]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理名词解释</title>
    <url>/2019/12/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/</url>
    <content><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><ol>
<li><strong>中央处理器</strong>: CPU是计算机的核心部件,主要用于指令的执行,主要包含数据通路和控制器</li>
<li><strong>算术逻辑单元(ALU)</strong>: 用来进行基本的算术运算和逻辑运算</li>
<li><strong>数据通路</strong>: 就是指令执行过程中,数据所流经的部件</li>
<li><strong>控制器</strong>: 对指令进行译码，生成相应的控制信号，以控制数据通路进行相应的操作</li>
<li><strong>主存(内存)</strong>: 指主存储器,插在计算机主板内存插槽上的内存条是主存储器的一部分 </li>
<li><strong>辅助存储器(辅存)</strong> : 系统运行时直接和主存交换信息的存储器</li>
<li><strong>外设(I/O设备)</strong> ：外部设备简称外设,主要用于和计算机交互信息</li>
<li><strong>设备控制器(I/O模块)</strong>： 控制外部设备工作的控制逻辑</li>
<li><strong>系统软件</strong> ：就是为了安全,有效的使用和管理计算机,以及为开发和运行 应用软件而提供的各种软件</li>
<li><strong>应用软件</strong>： 就是专门为数据处理,科学计算,事务管理,多媒体处理,工程设计及过程控制等开发的软件</li>
<li><strong>高级语言</strong>：和计算机底层结构关联不大,是机器无关的语言</li>
<li><strong>汇编语言</strong>：就是一种用简短的<strong>英文符号和二进制代码建立对应关系</strong>,方便程序员编写和阅读机器语言的语言</li>
<li><strong>机器语言</strong>：就是用二进制进行编码的机器指令,每条指令都是0/1序列</li>
<li><strong>机器级语言</strong>：和计算机底层结构密切相关的语言</li>
<li><strong>源程序</strong>：被翻译程序翻译的程序</li>
<li><strong>目标程序</strong>：翻译程序翻译后生成的程序</li>
<li><strong>翻译程序</strong>：就是把一种编程语言表示的程序转换为等价的另一种语言表示的程序</li>
<li><strong>编译程序</strong>: 也称为编译器,用来将高级语言翻译成汇编程序或者机器语言目标程序</li>
<li><strong>解释程序</strong>：也称为解释器,用来将源程序中的语句,按照执行顺序,逐条用子程序进行解释,并最终转换为机器指令执行</li>
<li><strong>汇编程序</strong>: 用来将汇编语言源程序翻译成机器语言目标程序</li>
<li><strong>操作系统</strong>：主要用来管理整个计算机的系统的资源,包括对他们进行调度、管理、监视和服务等</li>
<li><strong>语言处理系统</strong>: 主要用于提供一个用高级语言编程的环境,包括源程序编辑,翻译,调试,链接和装入运行等功能</li>
<li><strong>最终用户</strong>：使用应用程序完成特定任务的计算机用户</li>
<li><strong>系统管理员</strong>：指利用操作系统等软件提供的功能对系统进行配置管理和维护,以建立高效合理的系统环境供计算机用户使用的操作人员</li>
<li><strong>应用程序员</strong>：指使用高级语言编写应用软件的程序员</li>
<li><strong>系统程序员</strong>：指设计和开发系统软件的程序员</li>
<li><strong>指令</strong>：就是用0,1表示的一串0/1序列,用来指示CPU完成一个特定的基本操作</li>
<li><strong>ISA</strong>：指令集体系结构,它是软件和硬件之间接口的一个完整定义</li>
<li><strong>透明</strong>: 一个存在的事物或概念从某个角度看似乎不存在,也就是对实际存在的事物或概念感觉不到,则成为透明</li>
<li><strong>响应时间</strong> ：也称执行时间或等待时间,是指从作业提交开始到作业完成所用的时间</li>
<li><strong>吞吐率</strong>：表示在单位时间内完成的工作量</li>
<li><strong>CPU执行时间</strong>：指CPU用于程序执行的时间</li>
<li><strong>时钟周期</strong>: 时钟信号的宽度,称为时钟周期</li>
<li><strong>时钟频率</strong>：CPU的主频就是时钟信号的时钟频率,是CPU时钟周期的倒数</li>
<li><strong>CPI</strong>：表示执行一条指令需要的时钟周期数</li>
<li><strong>基准程序</strong>：是进行计算机性能评测的一种重要工具,能够很好的反应机器在运行实际负载时的性能</li>
<li><strong>MIPS</strong>：它是指令速度的计量单位,表示平均每秒钟执行多少百万条指令</li>
<li><strong>峰值MIPS</strong>：选取一组指令组合,使得得到的平均CPI最小,由此得到的MIPS就是峰值MIPS</li>
<li><strong>MFLOPS</strong>: 用来表示浮点操作的指标,表示每秒所执行的浮点运算有多少百万条</li>
<li><strong>PFLOPS</strong>：用来衡量浮点运算的一个指标 ，表示每秒执行的浮点运算的数量（10的15次/s）</li>
</ol>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><ol>
<li><strong>真值</strong>：机器数真正的值,称为机器数的真值</li>
<li><strong>机器数</strong>: 将数值数据在计算机内部编码表示的数称为机器数（一定是0/1序列）</li>
<li><strong>数值数据</strong>: 数值数据用来表示数量的多少,可比较大小</li>
<li><strong>非数值数据</strong>：没有大小之分,不表示数量多少,包括字符数据和逻辑数据</li>
<li><strong>无符号整数</strong>：当一个编码的所有二进制位都用来表示数值而没有符号位时,该编码表示的就是无符号整数,就是正整数或非负整数</li>
<li><strong>带符号整数</strong>：也称为有符号整数,它必须用一个二进制位来表示符号</li>
<li><strong>定点数</strong>：整数的小数点隐含在数的最右边,故无需表示小数点，因而也称为定点数</li>
<li><strong>阶和阶码</strong>：阶码就是在浮点数据编码中，表示小数点的位置的代码</li>
<li><strong>ASCII码</strong>：西文字符的内码就是ASCII码</li>
<li><strong>汉字输入码</strong>：对每个汉字用相应的按键进行编码的表示就称为汉字的输入码,又称为外码</li>
<li><strong>汉字内码</strong>：汉字输入到计算机内部后,就按照内码的编码形式在计算机中查找传送等处理</li>
<li><strong>字长</strong>：通常是指CPU内部用于整数运算的数据通路的宽度</li>
</ol>
<h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><ol>
<li><strong>操作码</strong>: 指出操作类型如:加减乘除等</li>
<li><strong>地址码</strong>：地址码指出操作数的地址,可以是存储单元的地址,寄存器编号等</li>
<li><strong>程序计数器PC</strong>：用来存放当前要执行指令的地址,且具有自加1的功能,既可以形成下一条指令的地址</li>
<li><strong>寻址方式</strong>：指令给出操作数或操作数地址的方式称为寻址方式</li>
<li><strong>有效地址</strong>：把指令中给出的操作数所在存储单元的地址称为有效地址</li>
<li><strong>立即寻址</strong>：指令中直接给出操作数本身的寻址方式</li>
<li><strong>间接寻址</strong>：指令中给出的地址码是存放操作数有效地址的存储单元地址</li>
<li><strong>寄存器直接寻址</strong>：指令中给出的是==操作数==所在的寄存器编号,操作数在寄存器中</li>
<li><strong>寄存器间接寻址</strong> 指令中给出的==地址码==是一个寄存器编号（该寄存器中存放的是操作数的有效地址)</li>
<li><strong>变址寻址</strong> :指令中的地址码字段给出一个基准地址,一般用于对线性表之类的数组元素进行访问</li>
<li><strong>相对寻址</strong>：指令的操作数的有效地址或转移目标地址位于该指令所在位置的前后某个固定位置上，</li>
<li><strong>基址寻址</strong>：指令中的地址码字段A给出一个偏移量,基准地址可以明显或隐含的由基址寄存器B给出</li>
<li><strong>CISC</strong>：复杂指令集计算机</li>
<li><strong>RISC</strong>：精简指令计算机</li>
</ol>
]]></content>
      <categories>
        <category>考试</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Executor框架简介</title>
    <url>/2019/11/22/Executor%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<blockquote>
<p>Java的线程既是工作单元，也是执行机制。从JDK 5开始，把工作单元与执行机制分离开来。工作单元包括Runnable和Callable，而执行机制由Executor框架提供。</p>
</blockquote>
<p><img src="http://blog.sjjtcloud.com/blog/20191126/7lUJFkBwikeL.png?imageslim" alt="Executor框架的成员及其关系"></p>
<h3 id="Executor框架包括3大部分："><a href="#Executor框架包括3大部分：" class="headerlink" title="Executor框架包括3大部分："></a>Executor框架包括3大部分：</h3><p>（1）任务。也就是工作单元，包括被执行任务需要实现的接口：Runnable接口或者Callable接口；</p>
<p>（2）任务的执行。也就是把任务分派给多个线程的执行机制，包括Executor接口及继承自Executor接口的ExecutorService接口, Executor框架有两个关键类实现了ExecutorService接口（ThreadPoolExecutor和ScheduledThreadPoolExecutor）</p>
<p>（3）异步计算的结果。包括Future接口及实现了Future接口的FutureTask类。</p>
<h3 id="Executor各个类和接口简介"><a href="#Executor各个类和接口简介" class="headerlink" title="Executor各个类和接口简介"></a>Executor各个类和接口简介</h3><p> Executor 它是框架基础, 将任务的提交 和任务的执行分离开来</p>
<h4 id="（1）ThreadPoolExecutor"><a href="#（1）ThreadPoolExecutor" class="headerlink" title="（1）ThreadPoolExecutor"></a>（1）ThreadPoolExecutor</h4><p>它是线程池的核心实现类,用来执行被提交的任务<br>创建方式：ThreadPoolExecutor通常使用Executors来创建,Executors可以创建3种类型的ThreadPoolExecutor<br>应用场景：适用于需要保证顺序地执行各个任务；并且在任意时间点，不会有多个线程是活动的应用场景</p>
<ol>
<li><p>SingleThreadExecutor 创建使用单个线程的SingleThreadExecutor的API</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>FixedThreadPool  用于创建使用固定线程数的FixedThreadPool的API</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads,ThreadFactory threadFactory)</span></span></span><br></pre></td></tr></table></figure>
<p>应用场景：适用于为了满足资源管理的需求，而需要限制当前线程数量的应用场景，它适用于负载比较重的服务器</p>
<ol start="3">
<li>CachedThreadPool  下面是Executors提供的，创建一个会根据需要创建新线程的CachedThreadPool的API。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>应用场景: CachedThreadPool是大小无界的线程池，适用于执行很多的短期异步任务的小程序，或者<br>是负载较轻的服务器</p>
<h4 id="2-ScheduledThreadPoolExecutor"><a href="#2-ScheduledThreadPoolExecutor" class="headerlink" title="(2)ScheduledThreadPoolExecutor"></a>(2)ScheduledThreadPoolExecutor</h4><p>它是一个实现类，可以在给定的延迟后运行命令，或者定期执行命令。ScheduledThreadPoolExecutor比Timer更灵活,功能更强大</p>
<p>创建方式<br>ScheduledThreadPoolExecutor通常使用工厂类Executors来创建。Executors可以创建2种类型的ScheduledThreadPoolExecutor，如下<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">·ScheduledThreadPoolExecutor。包含若干个线程的ScheduledThreadPoolExecutor。</span><br><span class="line">·SingleThreadScheduledExecutor。只包含一个线程的ScheduledThreadPoolExecutor。</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>方式一: 创建固定个数线程ScheduledThreadPoolExecutor的API<br>应用场景: 适用于需要多个后台线程执行周期任务，同时为了满足资源管理的需求而需要限制后台线程的数量的应用场景</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                              ThreadFactory threadFactory)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>方式二: 创建只包含一个线程的ScheduledThreadPoolExecutor<br>应用场景:适用于需要单个后台线程执行周期任务，同时需要保证顺序地执行各个任务的应用场景</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">(ThreadFactory threadFactory)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>(3)Future接口<br>Futrue接口和实现Futrue接口的FutrueTask类用来表示<strong>异步计算的结果</strong>当我们把Runnable接口或者Callable接口的实现类提交(submit)给ThreadPoolExecutor或ScheduledThreadPoolExecutor时,ThreadPoolExecutor或ScheduledThreadPoolExecutor会向我们返回一个FutrueTask对象,下面是对应API<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span></span><br><span class="line"><span class="function">&lt;T&gt; Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span></span><br><span class="line"><span class="function">Future&lt;&gt; <span class="title">submit</span><span class="params">(Runnable task)</span></span></span><br></pre></td></tr></table></figure></p>
<p>(4)Runnable接口和Callable接口<br>Runnable接口和Callable接口的实现类，都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行。它们之间的区别是Runnable不会返回结果，而Callable可以返回结果。</p>
<p>除了可以自己创建实现Callable接口的对象外，还可以使用工厂类Executors来把一个Runnable包装成一个Callable。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Callable&lt;Object&gt; <span class="title">callable</span><span class="params">(Runnable task)</span></span></span><br></pre></td></tr></table></figure>
<p>下面是Executors提供的，把一个Runnable和一个待返回的结果包装成一个Callable的API<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span></span></span><br></pre></td></tr></table></figure></p>
<p><img src="http://blog.sjjtcloud.com/blog/20191122/jh9FyfKXLM3U.png?imageslim" alt="Executor框架的使用示意图"></p>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下nohup文件过大问题解决方案</title>
    <url>/2019/11/11/Linux%E4%B8%8Bnohup%E6%96%87%E4%BB%B6%E8%BF%87%E5%A4%A7%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h3 id="文件过大可能对系统造成的影响"><a href="#文件过大可能对系统造成的影响" class="headerlink" title="文件过大可能对系统造成的影响"></a>文件过大可能对系统造成的影响</h3><ol>
<li>文件打开非常慢</li>
<li>系统线程被阻塞 无法正常运行（采集系统曾经碰到过）</li>
</ol>
<h3 id="解决方法1-直接指定到黑洞目录-在本地也不会保留-项目中一般都配置的有日志文件-所以这个文件其实是冗余的"><a href="#解决方法1-直接指定到黑洞目录-在本地也不会保留-项目中一般都配置的有日志文件-所以这个文件其实是冗余的" class="headerlink" title="解决方法1 直接指定到黑洞目录,在本地也不会保留,项目中一般都配置的有日志文件,所以这个文件其实是冗余的"></a>解决方法1 直接指定到黑洞目录,在本地也不会保留,项目中一般都配置的有日志文件,所以这个文件其实是冗余的</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#nohup java -Dfile.encoding=utf-8 -jar $JAVA_OPTS  admin.jar &gt; admin.log &amp;</span></span><br><span class="line">nohup java -Dfile.encoding=utf-8 -jar <span class="variable">$JAVA_OPTS</span> admin.jar &gt; /dev/null &amp;</span><br></pre></td></tr></table></figure>
<h3 id="解决方法2-切割日志文件"><a href="#解决方法2-切割日志文件" class="headerlink" title="解决方法2 切割日志文件"></a>解决方法2 切割日志文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">#################启动日志切割服务#################</span></span><br><span class="line">this_path=$(<span class="built_in">cd</span> `dirname <span class="variable">$0</span>`;<span class="built_in">pwd</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$this_path</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$this_path</span></span><br><span class="line">current_date=`date -d <span class="string">"-1 day"</span> <span class="string">"+%Y%m%d"</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$current_date</span></span><br><span class="line">split -b 65535000 -d -a 4 /home/.../nohup.out   /home/.../<span class="built_in">log</span>/log_<span class="variable">$&#123;current_date&#125;</span>_  </span><br><span class="line"></span><br><span class="line">cat /dev/null &gt; nohup.out</span><br></pre></td></tr></table></figure>
<h4 id="split命令"><a href="#split命令" class="headerlink" title="split命令"></a>split命令</h4><p> <code>split  -b 65535000 -d -a 4  nohup.out  ./log/log_${current_date}_</code> 这里使用split命令,将nouhup文件按指定大小切分(65535000b 大概60多M吧，可以自定义大小 )，并分成指定格式（-d -a 4以4位数字形式为后缀以从0000开始,具体可以百度split命令用法）,最终输出格式为log_20160610_0001</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>nohup</tag>
      </tags>
  </entry>
  <entry>
    <title>No space left on device问题解决</title>
    <url>/2019/10/25/No%20space%20left%20on%20device/</url>
    <content><![CDATA[<h3 id="最近采集器可以正常采集数据-但是数据一直未入库-后来试着停止数据库后启动时-mysql报错No-space-left-on-device"><a href="#最近采集器可以正常采集数据-但是数据一直未入库-后来试着停止数据库后启动时-mysql报错No-space-left-on-device" class="headerlink" title="最近采集器可以正常采集数据,但是数据一直未入库,后来试着停止数据库后启动时,mysql报错No space left on device"></a>最近采集器可以正常采集数据,但是数据一直未入库,后来试着停止数据库后启动时,mysql报错No space left on device</h3><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ol>
<li>使用 <strong>df -h</strong> 命令查看磁盘使用情况如下：</li>
</ol>
<p><img src="http://blog.sjjtcloud.com/blog/20191025/Nh43xnANffMH.png?imageslim" alt="mark"><br>问题发生时/dev/vda1磁盘使用了100%被完全占满,这个是删除数据后截的图</p>
<ol start="2">
<li><p>接着，使用 <strong>du -sh *  </strong>命令 在根目录查看每个文件使用情况<br><img src="http://blog.sjjtcloud.com/blog/20191025/M6LphdXthEkt.png?imageslim" alt="mark"></p>
</li>
<li><p>最后发现是myql占用了100多G,逐层使用du -sh *最后发现是业务数据库其中一个表,数据占了将近100G</p>
</li>
<li>删除该表数据后 问题解决</li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot整合ActiveMq入门</title>
    <url>/2019/10/21/springboot%E6%95%B4%E5%90%88ActiveMq/</url>
    <content><![CDATA[<p><img src="http://blog.sjjtcloud.com/blog/20191021/FKqfRpofuTfa.png?imageslim" alt="mark"></p>
<h3 id="1-下载activeMq并启动-版本apache-activemq-5-15-4解压运行"><a href="#1-下载activeMq并启动-版本apache-activemq-5-15-4解压运行" class="headerlink" title="1.下载activeMq并启动(版本apache-activemq-5.15.4解压运行)"></a>1.下载activeMq并启动(版本apache-activemq-5.15.4解压运行)</h3><p>启动成功后管理路径是<a href="http://127.0.0.1:8161" target="_blank" rel="noopener">http://127.0.0.1:8161</a><br>用户名密码admin/admin</p>
<h3 id="2-springboot项目中加入activeMq依赖"><a href="#2-springboot项目中加入activeMq依赖" class="headerlink" title="2.springboot项目中加入activeMq依赖"></a>2.springboot项目中加入activeMq依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入ActiveMq依赖--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-activemq<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  启用JMS 的池化, 就一定要加上这个 jar--&gt;</span> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.activemq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq-pool<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-application-yml配置activeMq服务器的配置"><a href="#3-application-yml配置activeMq服务器的配置" class="headerlink" title="3. application.yml配置activeMq服务器的配置"></a>3. application.yml配置activeMq服务器的配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># MQ所在的服务器的地址</span></span><br><span class="line"><span class="string">spring.activemq.broker-url:</span> <span class="attr">tcp://127.0.0.1:61616</span></span><br><span class="line"><span class="comment"># 是否使用内置的MQ， true  使用； fale  不使用</span></span><br><span class="line"><span class="string">spring.activemq.in-memory:</span> <span class="literal">false</span> </span><br><span class="line"><span class="comment"># 是否在回滚回滚消息之前停止消息传递。这意味着当启用此命令时，消息顺序不会被保留。</span></span><br><span class="line"><span class="string">spring.activemq.non-blocking-redelivery:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># 用户名</span></span><br><span class="line"><span class="string">spring.activemq.password:</span> <span class="string">admin</span></span><br><span class="line"><span class="comment"># 密码</span></span><br><span class="line"><span class="string">spring.activemq.user:</span> <span class="string">admin</span></span><br></pre></td></tr></table></figure>
<p>具体的配置信息解析<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.activemq.broker-url=tcp://127.0.0.1:61616</span><br><span class="line"># 在考虑结束之前等待的时间</span><br><span class="line">#spring.activemq.close-timeout=15s </span><br><span class="line"># 默认代理URL是否应该在内存中。如果指定了显式代理，则忽略此值。</span><br><span class="line">spring.activemq.in-memory=true </span><br><span class="line"># 是否在回滚回滚消息之前停止消息传递。这意味着当启用此命令时，消息顺序不会被保留。</span><br><span class="line">spring.activemq.non-blocking-redelivery=false</span><br><span class="line"># 密码</span><br><span class="line">spring.activemq.password=admin</span><br><span class="line"># 等待消息发送响应的时间。设置为0等待永远。</span><br><span class="line">spring.activemq.user=admin</span><br><span class="line"># 是否信任所有包</span><br><span class="line">#spring.activemq.packages.trust-all=</span><br><span class="line"># 要信任的特定包的逗号分隔列表（当不信任所有包时）</span><br><span class="line">#spring.activemq.packages.trusted=</span><br><span class="line"># 当连接请求和池满时是否阻塞。设置false会抛“JMSException异常”。</span><br><span class="line">#spring.activemq.pool.block-if-full=true</span><br><span class="line"># 如果池仍然满，则在抛出异常前阻塞时间。</span><br><span class="line">#spring.activemq.pool.block-if-full-timeout=-1ms</span><br><span class="line"># 是否在启动时创建连接。可以在启动时用于加热池。</span><br><span class="line">#spring.activemq.pool.create-connection-on-startup=true</span><br><span class="line"># 是否用Pooledconnectionfactory代替普通的ConnectionFactory。</span><br><span class="line">#spring.activemq.pool.enabled=false </span><br><span class="line"># 连接过期超时。</span><br><span class="line">#spring.activemq.pool.expiry-timeout=0ms</span><br><span class="line"># 连接空闲超时</span><br><span class="line">#spring.activemq.pool.idle-timeout=30s</span><br><span class="line"># 连接池最大连接数</span><br><span class="line">#spring.activemq.pool.max-connections=1</span><br><span class="line"># 每个连接的有效会话的最大数目。</span><br><span class="line">#spring.activemq.pool.maximum-active-session-per-connection=500</span><br><span class="line"># 当有&quot;JMSException&quot;时尝试重新连接</span><br><span class="line">#spring.activemq.pool.reconnect-on-exception=true</span><br><span class="line"># 在空闲连接清除线程之间运行的时间。当为负数时，没有空闲连接驱逐线程运行。</span><br><span class="line">#spring.activemq.pool.time-between-expiration-check=-1ms</span><br><span class="line"># 是否只使用一个MessageProducer</span><br><span class="line">#spring.activemq.pool.use-anonymous-producers=true</span><br></pre></td></tr></table></figure></p>
<h3 id="4-创建ActiveMqConfig"><a href="#4-创建ActiveMqConfig" class="headerlink" title="4.创建ActiveMqConfig"></a>4.创建ActiveMqConfig</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivemqConfig</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span>(name = <span class="string">"topic-myqueue"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Queue <span class="title">queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ActiveMQQueue(<span class="string">"yw-advice-worker"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span>(name = <span class="string">"topic-company"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Topic <span class="title">topicCompany</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ActiveMQTopic(<span class="string">"topic-company"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span>(name = <span class="string">"topic-worker"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Topic <span class="title">topicWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ActiveMQTopic(<span class="string">"topic-company"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// topic模式的ListenerContainer </span></span><br><span class="line">  <span class="meta">@Bean</span> </span><br><span class="line">  <span class="keyword">public</span> JmsListenerContainerFactory&lt;?&gt; jmsListenerContainerTopic(ConnectionFactory  activeMQConnectionFactory) &#123;</span><br><span class="line">     DefaultJmsListenerContainerFactory bean = <span class="keyword">new</span> DefaultJmsListenerContainerFactory();</span><br><span class="line">     bean.setPubSubDomain(<span class="keyword">true</span>);</span><br><span class="line">     bean.setConnectionFactory(activeMQConnectionFactory);</span><br><span class="line">     <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// queue模式的ListenerContainer </span></span><br><span class="line">  <span class="meta">@Bean</span> </span><br><span class="line">  <span class="keyword">public</span> JmsListenerContainerFactory&lt;?&gt; jmsListenerContainerQueue(</span><br><span class="line">    ConnectionFactory activeMQConnectionFactory) &#123;</span><br><span class="line">     DefaultJmsListenerContainerFactory bean = <span class="keyword">new</span> DefaultJmsListenerContainerFactory();</span><br><span class="line">     bean.setConnectionFactory(activeMQConnectionFactory);</span><br><span class="line">     <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-编写生产者测试"><a href="#5-编写生产者测试" class="headerlink" title="5.编写生产者测试"></a>5.编写生产者测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span>(classes = ApiApplication.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveMqProducterTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> JmsMessagingTemplate jmsTemplate;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Resource</span>(name = <span class="string">"topic-company"</span>)</span><br><span class="line">  <span class="keyword">private</span> Topic adviceCompany;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Resource</span>(name = <span class="string">"queue-yw"</span>)</span><br><span class="line">  <span class="keyword">private</span> Queue queueAdvice;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testProducter</span><span class="params">()</span></span>&#123;</span><br><span class="line">       jmsTemplate.convertAndSend(adviceCompany, <span class="string">"您有新的外卖订单,已为您自动接单"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Test</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">  jmsTemplate.convertAndSend(queueAdvice,<span class="string">"你好,我来自队列"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-编写消费者测试"><a href="#6-编写消费者测试" class="headerlink" title="6.编写消费者测试"></a>6.编写消费者测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveMqConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(ActiveMqConsumer.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JmsListener</span>(destination = <span class="string">"topic-company"</span>,containerFactory = <span class="string">"jmsListenerContainerTopic"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveTopic</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"接收到topic消息：&#123;&#125;"</span>,msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JmsListener</span>(destination = <span class="string">"queue-yw"</span>,containerFactory = <span class="string">"jmsListenerContainerQueue"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveQueue</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"接收到queue-yw消息：&#123;&#125;"</span>,msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考资料</p>
<ul>
<li>(<a href="https://blog.csdn.net/qq_43652509/article/details/83926758" target="_blank" rel="noopener">https://blog.csdn.net/qq_43652509/article/details/83926758</a>)</li>
<li>(<a href="https://blog.csdn.net/cs_hnu_scw/article/details/81040834" target="_blank" rel="noopener">https://blog.csdn.net/cs_hnu_scw/article/details/81040834</a>)</li>
</ul>
]]></content>
      <categories>
        <category>ActiveMq</category>
      </categories>
      <tags>
        <tag>ActiveMq</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/IP三次握手四次挥手</title>
    <url>/2019/10/08/TCP%20IP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    <content><![CDATA[<p><strong>一、TCP报文格式</strong></p>
<p>  TCP报文格式图：</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0108/8317/ef70c29e-651b-33a4-b188-d4e8e0ff9915.png" alt> </p>
<p>  上图中有几个字段需要重点介绍下：</p>
<p>  （1）序号：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。</p>
<p>  （2）确认序号：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。</p>
<p>  （3）标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：</p>
<p>  （A）URG：紧急指针（urgent pointer）有效。</p>
<p>  （B）ACK：确认序号有效。</p>
<p>  （C）PSH：接收方应该尽快将这个报文交给应用层。</p>
<p>  （D）RST：重置连接。</p>
<p>  （E）SYN：发起一个新连接。</p>
<p>  （F）FIN：释放一个连接。</p>
<p>三次握手用wireshark抓包分析<br><img src="http://blog.sjjtcloud.com/blog/20191008/XjQC8Jd9LHcm.png?imageslim" alt="mark"></p>
<p>第一次握手 SYN<br><img src="http://blog.sjjtcloud.com/blog/20191008/4gfW0vbr3WOE.png?imageslim" alt="mark"></p>
<p>第二次握手 SYN,ACK<br><img src="http://blog.sjjtcloud.com/blog/20191008/d5nltEXPMxL5.png?imageslim" alt="mark"></p>
<p>第三次握手<br><img src="http://blog.sjjtcloud.com/blog/20191008/ppSYnlie7IQE.png?imageslim" alt="mark"></p>
<h1 id="TCP-三次握手-示意图"><a href="#TCP-三次握手-示意图" class="headerlink" title="TCP 三次握手 示意图"></a>TCP 三次握手 示意图</h1><p><img src="https://images2018.cnblogs.com/blog/701983/201803/701983-20180314102251716-1929749101.png" alt></p>
<h2 id="Wireshark-抓包注意事项"><a href="#Wireshark-抓包注意事项" class="headerlink" title="Wireshark 抓包注意事项"></a>Wireshark 抓包注意事项</h2><p>为了演示一个TCP三次握手建立连接的过程，我们通过 Chrome 访问一个网页。<br>已知 HTTP 协议就是建立在TCP链接上的</p>
<p>比如访问以下的网址：<br><a href="http://toutiao.newmedia139.net/" target="_blank" rel="noopener">http://toutiao.newmedia139.net/</a></p>
<p>通过 Cmd 的 ping 命令获取 这个网站对应的 IP地址 <strong>183.136.236.13</strong><br><img src="https://images2018.cnblogs.com/blog/701983/201803/701983-20180314102251934-555170248.png" alt></p>
<p>确定 这个IP 有一个非常重要的好处，就是我们只需要</p>
<p>电脑 -&gt; 网站 的数据包</p>
<p>网站-&gt;电脑 的数据包</p>
<p>所以，可以使用Wireshark的显示过滤规则，只显示我们需要的数据，不然你一定看着满屏幕的数据抓狂的。</p>
<h3 id="过滤规则如下："><a href="#过滤规则如下：" class="headerlink" title="过滤规则如下："></a>过滤规则如下：</h3><p>ip.src==183.136.236.13 or ip.dst==183.136.236.13</p>
<h3 id="截图："><a href="#截图：" class="headerlink" title="截图："></a>截图：</h3><p><img src="https://images2018.cnblogs.com/blog/701983/201803/701983-20180314102252371-1979969603.png" alt></p>
<h2 id="分析TCP握手包"><a href="#分析TCP握手包" class="headerlink" title="分析TCP握手包"></a>分析TCP握手包</h2><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><img src="https://images2018.cnblogs.com/blog/701983/201803/701983-20180314102252636-937376226.png" alt></p>
<p>通过图片，可以看到 先 进行了 TCP 三次传输 然后才 开始 HTTP 传输</p>
<h2 id="第一次-客户端发送-SYN-报文-到服务器"><a href="#第一次-客户端发送-SYN-报文-到服务器" class="headerlink" title="第一次 客户端发送 SYN 报文 到服务器"></a>第一次 客户端发送 SYN 报文 到服务器</h2><p><img src="https://images2018.cnblogs.com/blog/701983/201803/701983-20180314102253092-1365683710.png" alt></p>
<h2 id="第二次-，服务器接收到-客户端的SYN-报文，回复-SYN-ACK-报文"><a href="#第二次-，服务器接收到-客户端的SYN-报文，回复-SYN-ACK-报文" class="headerlink" title="第二次 ，服务器接收到 客户端的SYN 报文，回复 SYN + ACK 报文"></a>第二次 ，服务器接收到 客户端的SYN 报文，回复 SYN + ACK 报文</h2><p><img src="https://images2018.cnblogs.com/blog/701983/201803/701983-20180314102253605-1241059132.png" alt></p>
<h2 id="第三次-，客户端接收到服务端的-SYN-ACK-报文后，回复-ACK报文"><a href="#第三次-，客户端接收到服务端的-SYN-ACK-报文后，回复-ACK报文" class="headerlink" title="第三次 ，客户端接收到服务端的 SYN+ACK 报文后，回复 ACK报文"></a>第三次 ，客户端接收到服务端的 SYN+ACK 报文后，回复 ACK报文</h2><p><img src="https://images2018.cnblogs.com/blog/701983/201803/701983-20180314102254051-694072128.png" alt></p>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>这里有个坑：Wireshark 显示的 Syn Ack的数目是不准确的</p>
<p><img src="https://images2018.cnblogs.com/blog/701983/201803/701983-20180314102254264-644298919.png" alt></p>
<p>理论上，Syn 应该初始值是个随机数的，后面的要根据初始值增加<br><img src="https://images2018.cnblogs.com/blog/701983/201803/701983-20180314102254468-1577667548.png" alt></p>
<h2 id="TCP-三次握手总结"><a href="#TCP-三次握手总结" class="headerlink" title="TCP 三次握手总结"></a>TCP 三次握手总结</h2><p>建立一个稳定的 双向 连接，最少需要 几次 通信呢？<br>以打电话为例<br>小明 给小红 打电话<br>小明 ： 喂，小红 听得到么？<br>小红： 嗯，我听到你说话了，你能听到我么？<br>小明：我能听到你。</p>
<p>只有这三个传输都正确了，才能保障双方是 连通的</p>
<h1 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h1><p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p>
<p>CP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。</p>
<p>（1）客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。</p>
<p>（2）服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。</p>
<p>（3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A。</p>
<p>（4）客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。</p>
<p>TCP采用四次挥手关闭连接如图2所示。</p>
<p><img src="https://images2018.cnblogs.com/blog/701983/201803/701983-20180314102255109-43618668.png" alt></p>
<h1 id="抓包截图"><a href="#抓包截图" class="headerlink" title="抓包截图"></a>抓包截图</h1><p><img src="https://images2018.cnblogs.com/blog/701983/201803/701983-20180314102255513-104940885.png" alt></p>
<p>其中 183.136.236.13 是服务器的ip<br>可以看到 这一次挥手是由 服务器 发起的</p>
<h2 id="第一次挥手-FIN-ACK"><a href="#第一次挥手-FIN-ACK" class="headerlink" title="第一次挥手 FIN +ACK"></a>第一次挥手 FIN +ACK</h2><p><img src="https://images2018.cnblogs.com/blog/701983/201803/701983-20180314102255745-1296704292.png" alt></p>
<h2 id="第二次挥手-ACK"><a href="#第二次挥手-ACK" class="headerlink" title="第二次挥手 ACK"></a>第二次挥手 ACK</h2><p><img src="https://images2018.cnblogs.com/blog/701983/201803/701983-20180314102255981-1871970231.png" alt></p>
<h2 id="第三次挥手-FIN-ACK"><a href="#第三次挥手-FIN-ACK" class="headerlink" title="第三次挥手 FIN +ACK"></a>第三次挥手 FIN +ACK</h2><p><img src="https://images2018.cnblogs.com/blog/701983/201803/701983-20180314102256594-1733317431.png" alt></p>
<h2 id="第四次挥手-ACK"><a href="#第四次挥手-ACK" class="headerlink" title="第四次挥手 ACK"></a>第四次挥手 ACK</h2><p><img src="https://images2018.cnblogs.com/blog/701983/201803/701983-20180314102257013-202026294.png" alt></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>TCP 由于是全双工的，断开链接需要四次挥手</p>
]]></content>
      <categories>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx配置</title>
    <url>/2019/09/30/nginx%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>windows下nginx配置文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#user  nobody;</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">#error_log  logs/error.log;</span><br><span class="line">#error_log  logs/error.log  notice;</span><br><span class="line">#error_log  logs/error.log  info;</span><br><span class="line"></span><br><span class="line">#pid        logs/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    #log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">    #                  &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">    #                  &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line"></span><br><span class="line">    #access_log  logs/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">	server &#123;</span><br><span class="line">		listen 443;</span><br><span class="line">		server_name www.sjjtcloud.com;</span><br><span class="line">		client_max_body_size 15M;</span><br><span class="line">		ssl on;</span><br><span class="line">		ssl_certificate  	cert/2195340_www.sjjtcloud.com.pem;</span><br><span class="line">		ssl_certificate_key 	cert/2195340_www.sjjtcloud.com.key;</span><br><span class="line">		ssl_session_timeout 5m;</span><br><span class="line">		ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">		ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">		ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">		proxy_set_header Host $host;</span><br><span class="line">		proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">		</span><br><span class="line">		location / &#123;</span><br><span class="line">			proxy_set_header Host $host;</span><br><span class="line">			proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">			root   D:/nginx-1.12.2/html;</span><br><span class="line">			index  index.html index.htm;</span><br><span class="line">			try_files $uri $uri/ @router;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">		location /ylzhy-api/api/ &#123;</span><br><span class="line">			proxy_set_header Host $host;</span><br><span class="line">			proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">			proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">			proxy_pass http://127.0.0.1:8081;</span><br><span class="line">			</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		location /yw-api/api/ &#123;</span><br><span class="line">			proxy_set_header Host $host;</span><br><span class="line">			proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">			proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">			proxy_pass http://127.0.0.1:8089;</span><br><span class="line">			</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		location /admin &#123;</span><br><span class="line">			proxy_set_header Host $host;</span><br><span class="line">			proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">			proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">			proxy_pass http://127.0.0.1:8090/yw-admin;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	 server &#123;</span><br><span class="line">    	listen   80;</span><br><span class="line">		server_name www.sjjtcloud.com sjjtcloud.com;  </span><br><span class="line">		proxy_set_header Host $host;</span><br><span class="line">		proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">		#rewrite ^(.*)$  https://$&#123;server_name&#125;$1 permanent; </span><br><span class="line">		#rewrite ^(.*)$  https://$host$1 permanent;</span><br><span class="line">		return 307 https://$server_name$request_uri;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	server &#123;</span><br><span class="line">        listen       8082;</span><br><span class="line">        server_name  fileServer;</span><br><span class="line">        charset utf-8;</span><br><span class="line">        location ~ .*\.(gif|jpg|jpeg|png|mp4|pdf)$ &#123;</span><br><span class="line">            expires 24h;</span><br><span class="line">            root D://fileweb/;</span><br><span class="line">            proxy_store on;</span><br><span class="line">            proxy_store_access user:rw group:rw all:rw;</span><br><span class="line">            proxy_temp_path         d://fileweb/;#图片访问路径</span><br><span class="line">            proxy_redirect          off;</span><br><span class="line">            proxy_set_header        Host $host:8082;</span><br><span class="line">            client_max_body_size    10m;</span><br><span class="line">            client_body_buffer_size 1280k;</span><br><span class="line">            proxy_connect_timeout   900;</span><br><span class="line">            proxy_send_timeout      900;</span><br><span class="line">            proxy_read_timeout      900;</span><br><span class="line">            proxy_buffer_size       40k;</span><br><span class="line">            proxy_buffers           40 320k;</span><br><span class="line">            proxy_busy_buffers_size 640k;</span><br><span class="line">            proxy_temp_file_write_size 640k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2019/09/19/%E9%87%87%E9%9B%86%E5%99%A8%E5%AE%A3%E4%BC%A0%E5%86%8C/</url>
    <content><![CDATA[<h1 id="采集器宣传册"><a href="#采集器宣传册" class="headerlink" title="采集器宣传册"></a>采集器宣传册</h1><p><img src="http://blog.sjjtcloud.com/blog/20190919/7AIMqyrtUt4p.jpg?imageslim" alt="mark"></p>
<p><img src="http://blog.sjjtcloud.com/blog/20190919/0cu1cDrUynR7.jpg?imageslim" alt="mark"></p>
]]></content>
  </entry>
  <entry>
    <title>微信小程序获取openid</title>
    <url>/2019/08/28/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%8E%B7%E5%8F%96openid/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 登录</span><br><span class="line">wx.login(&#123;</span><br><span class="line">  success: res =&gt; &#123;</span><br><span class="line">    // 发送 res.code 到后台换取 openId, sessionKey, unionId</span><br><span class="line">    console.log(&quot;res: &quot;+JSON.stringify(res))</span><br><span class="line">    var code = res.code;</span><br><span class="line">    wx.request(&#123;</span><br><span class="line">      url: &apos;https://nilaile.easy.echosite.cn/yw-api/api/common/wechat/getOpenId&apos;,</span><br><span class="line">      method:&apos;post&apos;,</span><br><span class="line">      data:&#123;</span><br><span class="line">        &apos;code&apos;: code,</span><br><span class="line">        &apos;clientFlag&apos;:&apos;client_company&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">      success:function(result)&#123;</span><br><span class="line">        console.log(&quot;请求结果: &quot; + JSON.stringify(result.data))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7不能ping通主机,主机可以ping通虚拟机</title>
    <url>/2019/08/27/Centos7%E4%B8%8D%E8%83%BDping%E9%80%9A%E4%B8%BB%E6%9C%BA,%E4%B8%BB%E6%9C%BA%E5%8F%AF%E4%BB%A5ping%E9%80%9A%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="在VM中安装了一个-CentOS-7-4-系统-，使用的是桥接模式，宿主机可以ping通虚拟机，虚拟机却ping不能宿主机。但是可以ping通外网域名，例如：www-baidu-com"><a href="#在VM中安装了一个-CentOS-7-4-系统-，使用的是桥接模式，宿主机可以ping通虚拟机，虚拟机却ping不能宿主机。但是可以ping通外网域名，例如：www-baidu-com" class="headerlink" title="在VM中安装了一个 CentOS 7.4 系统 ，使用的是桥接模式，宿主机可以ping通虚拟机，虚拟机却ping不能宿主机。但是可以ping通外网域名，例如：www.baidu.com"></a>在VM中安装了一个 CentOS 7.4 系统 ，使用的是桥接模式，宿主机可以ping通虚拟机，虚拟机却ping不能宿主机。但是可以ping通外网域名，例如：<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></h2><h2 id="解决办法：更改windows防火墙设置"><a href="#解决办法：更改windows防火墙设置" class="headerlink" title="解决办法：更改windows防火墙设置"></a>解决办法：更改windows防火墙设置</h2><p>打开windows防火墙–高级设置–入站规则： </p>
<p><img src="https://img-blog.csdn.net/20171206131218142?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI3ODY4NzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>vmware虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池的优雅关闭实践(转载)</title>
    <url>/2019/08/20/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BC%98%E9%9B%85%E5%85%B3%E9%97%AD%E5%AE%9E%E8%B7%B5(%E8%BD%AC%E8%BD%BD)/</url>
    <content><![CDATA[<p><strong>平时开发中，大家更多的关注的是线程池的创建、任务的提交和执行。往往会忽略线程池的关闭，甚至忘记调用<code>shutdown()</code>方法，导致内存溢出。大多知道需要调用shutdown()关闭线程池，也少研究其真正的关闭过程。</strong></p>
<p>首先看源码中的一句注释：</p>
<blockquote>
<p>A pool that is no longer referenced in a program and has no remaining threads will be shutdown automatically.<br>如果程序中不再持有线程池的引用，并且线程池中没有线程时，线程池将会自动关闭。</p>
</blockquote>
<p><strong>线程池自动关闭的两个条件：1、线程池的引用不可达；2、线程池中没有线程；</strong><br><a id="more"></a></p>
<p>这里对于条件2解释一下，线程池中没有线程是指线程池中的所有线程都已运行完自动消亡。然而我们常用的FixedThreadPool的核心线程没有超时策略，所以并不会自动关闭。</p>
<p>展示两种不同线程池 <strong>不关闭</strong> 的情况：</p>
<p>1、FixedThreadPool 示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    while(true) &#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(8);</span><br><span class="line">        executorService.execute(() -&gt; System.out.println(&quot;running&quot;));</span><br><span class="line">        executorService = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">running</span><br><span class="line">......</span><br><span class="line">running</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to create new native thread</span><br><span class="line">    at java.lang.Thread.start0(Native Method)</span><br><span class="line">    at java.lang.Thread.start(Thread.java:714)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor.addWorker(ThreadPoolExecutor.java:950)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1357)</span><br><span class="line">    at test.PoolTest.main(PoolTest.java:29)</span><br></pre></td></tr></table></figure>
<p>因为FixedThreadPool的核心线程不会自动超时关闭，使用时必须在适当的时候调用shutdown()方法。</p>
<p>2、 CachedThreadPool 示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    while(true) &#123;</span><br><span class="line">        // 默认keepAliveTime为 60s</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool(); </span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) executorService;</span><br><span class="line">        // 为了更好的模拟，动态修改为1纳秒</span><br><span class="line">        threadPoolExecutor.setKeepAliveTime(1, TimeUnit.NANOSECONDS);</span><br><span class="line">        threadPoolExecutor.execute(() -&gt; System.out.println(&quot;running&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">running</span><br><span class="line">running</span><br><span class="line">running</span><br><span class="line">running</span><br><span class="line">running</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>CachedThreadPool 的线程 keepAliveTime 默认为 60s ，核心线程数量为 0 ，所以不会有核心线程存活阻止线程池自动关闭。 详见 <a href="https://www.jianshu.com/p/f030aa5d7a28" target="_blank" rel="noopener">线程池之ThreadPoolExecutor构造</a> ，为了更快的模拟，构造后将 keepAliveTime 修改为1纳秒，相当于线程执行完马上会消亡，所以线程池可以被回收。实际开发中，如果CachedThreadPool 确实忘记关闭，在一定时间后是可以被回收的。但仍然建议显示关闭。</p>
<p><strong>然而，线程池关闭的意义不仅仅在于结束线程执行，避免内存溢出，因为大多使用的场景并非上述示例那样 朝生夕死。线程池一般是持续工作的全局场景，如数据库连接池。</strong></p>
<p>本文更多要讨论的是当线程池调用shutdown方法后，会经历些什么？思考一下几个问题：</p>
<blockquote>
<ol>
<li>是否可以继续接受新任务？继续提交新任务会怎样？</li>
<li>等待队列里的任务是否还会执行？</li>
<li>正在执行的任务是否会立即中断？</li>
</ol>
</blockquote>
<p><strong>问题1：是否可以继续接受新任务？继续提交新任务会怎样？</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ThreadPoolExecutor executor = new ThreadPoolExecutor(4, 4, 10, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;());</span><br><span class="line">    executor.execute(() -&gt; System.out.println(&quot;before shutdown&quot;));</span><br><span class="line">    executor.shutdown();</span><br><span class="line">    executor.execute(() -&gt; System.out.println(&quot;after shutdown&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">before shutdown</span><br><span class="line">Exception in thread &quot;main&quot; java.util.concurrent.RejectedExecutionException: Task PoolTest$$Lambda$2/142257191@3e3abc88 rejected from java.util.concurrent.ThreadPoolExecutor@6ce253f1[Terminated, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 1]</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2047)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:823)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1369)</span><br><span class="line">    at PoolTest.main(PoolTest.java:12)</span><br></pre></td></tr></table></figure>
<p>当线程池关闭后，继续提交新任务会抛出异常。这句话也不够准确，不一定是抛出异常，而是执行拒绝策略，默认的拒绝策略是抛出异常。可参见 <a href="https://www.jianshu.com/p/f030aa5d7a28" target="_blank" rel="noopener">线程池之ThreadPoolExecutor构造</a> 里面自定义线程池的例子，自定义了忽略策略，但被拒绝时并没有抛出异常。</p>
<p><strong>问题2：等待队列里的任务是否还会执行？</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class WaitqueueTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workQueue = new LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">        for(int i = 1; i &lt;= 100 ; i++)&#123;</span><br><span class="line">            workQueue.add(new Task(String.valueOf(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        ThreadPoolExecutor executor = new ThreadPoolExecutor(1, 1, 10, TimeUnit.SECONDS, workQueue);</span><br><span class="line">        executor.execute(new Task(&quot;0&quot;));</span><br><span class="line">        executor.shutdown();</span><br><span class="line">        System.out.println(&quot;workQueue size = &quot; + workQueue.size() + &quot; after shutdown&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Task implements Runnable&#123;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        public Task(String name) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for(int i = 1; i &lt;= 10; i++)&#123;</span><br><span class="line">                System.out.println(&quot;task &quot; + name + &quot; is running&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;task &quot; + name + &quot; is over&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个demo解释一下，我们用LinkedBlockingQueue构造了一个线程池，在线程池启动前，我们先将工作队列填充100个任务，然后执行<code>task 0</code> 后立即<code>shutdown()</code>线程池，来验证线程池关闭队列的任务运行状态。<br>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">task 0 is running</span><br><span class="line">task 0 is over</span><br><span class="line">workQueue size = 100 after shutdown //表示线程池关闭后，队列任然有100个任务</span><br><span class="line">task 1 is running</span><br><span class="line">......</span><br><span class="line">task 100 is running</span><br><span class="line">task 100 is over</span><br></pre></td></tr></table></figure>
<p>从结果中我们可以看到，线程池虽然关闭，但是队列中的任务任然继续执行，<strong>所以用 <code>shutdown()</code>方式关闭线程池时需要考虑是否是你想要的效果。</strong></p>
<p>如果你希望线程池中的等待队列中的任务不继续执行，可以使用<code>shutdownNow()</code>方法，将上述代码进行调整，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class WaitqueueTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workQueue = new LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">        for(int i = 1; i &lt;= 100 ; i++)&#123;</span><br><span class="line">            workQueue.add(new Task(String.valueOf(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        ThreadPoolExecutor executor = new ThreadPoolExecutor(1, 1, 10, TimeUnit.SECONDS, workQueue);</span><br><span class="line">        executor.execute(new Task(&quot;0&quot;));</span><br><span class="line">        // shutdownNow有返回值，返回被抛弃的任务list</span><br><span class="line">        List&lt;Runnable&gt; dropList = executor.shutdownNow();</span><br><span class="line">        System.out.println(&quot;workQueue size = &quot; + workQueue.size() + &quot; after shutdown&quot;);</span><br><span class="line">        System.out.println(&quot;dropList size = &quot; + dropList.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Task implements Runnable&#123;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        public Task(String name) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for(int i = 1; i &lt;= 10; i++)&#123;</span><br><span class="line">                System.out.println(&quot;task &quot; + name + &quot; is running&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;task &quot; + name + &quot; is over&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">task 0 is running</span><br><span class="line">workQueue size = 0 after shutdown</span><br><span class="line">task 0 is running</span><br><span class="line">task 0 is running</span><br><span class="line">task 0 is running</span><br><span class="line">task 0 is running</span><br><span class="line">task 0 is running</span><br><span class="line">task 0 is running</span><br><span class="line">task 0 is running</span><br><span class="line">task 0 is running</span><br><span class="line">task 0 is running</span><br><span class="line">dropList size = 100</span><br><span class="line">task 0 is over</span><br></pre></td></tr></table></figure>
<p>从上述输出可以看到，只有任务0执行完毕，其他任务都被drop掉了，dropList的size为100。通过dropList我们可以对未处理的任务进行进一步的处理，如log记录，转发等；</p>
<p><strong>问题3：正在执行的任务是否会立即中断？</strong></p>
<p>要验证这个问题，需要对线程的 interrupt 方法有一定了解。</p>
<hr>
<p>推荐阅读 <a href="https://www.jianshu.com/p/e0ff2e420ab6" target="_blank" rel="noopener">——线程中断机制</a><br>关于 interrupt 方法：<br>首先，一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止。<br>所以，Thread.stop, Thread.suspend, Thread.resume 都已经被废弃了。<br>而 Thread.interrupt 的作用其实也不是中断线程，而是「通知线程应该中断了」，具体到底中断还是继续运行，应该由被通知的线程自己处理。<br>具体来说，当对一个线程，调用 interrupt() 时，<br>① 如果线程处于被阻塞状态（例如处于sleep, wait, join 等状态），那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常。仅此而已。<br>② 如果线程处于正常活动状态，那么会将该线程的中断标志设置为 true，仅此而已。被设置中断标志的线程将继续正常运行，不受影响。<br>interrupt() 并不能真正的中断线程，需要被调用的线程自己进行配合才行。也就是说，一个线程如果有被中断的需求，那么就可以这样做。<br>① 在正常运行任务时，经常检查本线程的中断标志位，如果被设置了中断标志就自行停止线程。<br>② 在调用阻塞方法时正确处理InterruptedException异常。（例如，catch异常后就结束线程。）</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class InteruptTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        ThreadPoolExecutor executor = new ThreadPoolExecutor(1, 1, 10, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;());</span><br><span class="line">        executor.execute(new Task(&quot;0&quot;));</span><br><span class="line">        Thread.sleep(1);</span><br><span class="line">        executor.shutdown();</span><br><span class="line">        System.out.println(&quot;executor has been shutdown&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Task implements Runnable &#123;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        public Task(String name) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line"></span><br><span class="line">            for (int i = 1; i &lt;= 100 &amp;&amp; !Thread.interrupted(); i++) &#123;</span><br><span class="line">                Thread.yield();</span><br><span class="line">                System.out.println(&quot;task &quot; + name + &quot; is running, round &quot; + i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">task 0 is running, round 1</span><br><span class="line">task 0 is running, round 2</span><br><span class="line">task 0 is running, round 3</span><br><span class="line">......</span><br><span class="line">task 0 is running, round 28</span><br><span class="line">executor has been shutdown</span><br><span class="line">......</span><br><span class="line">task 0 is running, round 99</span><br><span class="line">task 0 is running, round 100</span><br></pre></td></tr></table></figure>
<p>为了体现在任务执行中打断，在主线程进行短暂 sleep ， task 中 调用 Thread.yield() ，出让时间片。从结果中可以看到，线程池被关闭后，正则运行的任务没有被 interrupt。说明<code>shutdown()</code>方法不会 interrupt 运行中线程。再将其改修改为<code>shutdownNow()</code> 后输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">task 0 is running, round 1</span><br><span class="line">task 0 is running, round 2</span><br><span class="line">......</span><br><span class="line">task 0 is running, round 56</span><br><span class="line">task 0 is running, round 57</span><br><span class="line">task 0 is running, round 58</span><br><span class="line">task 0 is running, round 59</span><br><span class="line">executor has been shutdown</span><br></pre></td></tr></table></figure>
<p>修改为<code>shutdownNow()</code> 后，task任务没有执行完，执行到中间的时候就被 interrupt 后没有继续执行了。</p>
<h5 id="总结，想要正确的关闭线程池，并不是简单的调用shutdown方法那么简单，要考虑到应用场景的需求，如何拒绝新来的请求任务？如何处理等待队列中的任务？如何处理正在执行的任务？想好这几个问题，在确定如何优雅而正确的关闭线程池。"><a href="#总结，想要正确的关闭线程池，并不是简单的调用shutdown方法那么简单，要考虑到应用场景的需求，如何拒绝新来的请求任务？如何处理等待队列中的任务？如何处理正在执行的任务？想好这几个问题，在确定如何优雅而正确的关闭线程池。" class="headerlink" title="总结，想要正确的关闭线程池，并不是简单的调用shutdown方法那么简单，要考虑到应用场景的需求，如何拒绝新来的请求任务？如何处理等待队列中的任务？如何处理正在执行的任务？想好这几个问题，在确定如何优雅而正确的关闭线程池。"></a>总结，想要正确的关闭线程池，并不是简单的调用shutdown方法那么简单，要考虑到应用场景的需求，如何拒绝新来的请求任务？如何处理等待队列中的任务？如何处理正在执行的任务？想好这几个问题，在确定如何优雅而正确的关闭线程池。</h5><p>PS：线程被 interrupt 后，需要再run方法中单独处理 interrupted 状态，interrupt 更类似一个标志位，不会直接打断线程的执行。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows运维脚本</title>
    <url>/2019/08/20/windows%E6%A0%B9%E6%8D%AE%E7%AB%AF%E5%8F%A3%E5%8F%B7%E6%9D%80%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="windows根据端口号-查杀进程"><a href="#windows根据端口号-查杀进程" class="headerlink" title="windows根据端口号,查杀进程"></a>windows根据端口号,查杀进程</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@echo off</span><br><span class="line">for /f &quot;tokens=5&quot; %%i in (&apos;netstat -aon ^| findstr &quot;:8086&quot;&apos;) do (</span><br><span class="line">    set n=%%i</span><br><span class="line">)</span><br><span class="line">taskkill /f /pid %n%</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>运维脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>NUC启动U盘制作</title>
    <url>/2019/08/19/NUC%E5%90%AF%E5%8A%A8%E7%9B%98%E5%88%B6%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="U盘制作步骤及镜像复制"><a href="#U盘制作步骤及镜像复制" class="headerlink" title="U盘制作步骤及镜像复制"></a>U盘制作步骤及镜像复制</h3><ol>
<li>CMD-&gt;diskpart</li>
<li><p>DISKPART&gt; list disk</p>
<p>磁盘 ###  状态           大小     可用     Dyn  Gpt</p>
<hr>
<p>磁盘 0    联机              931 GB  1024 KB        <em><br>磁盘 1    联机              119 GB      0 B        </em><br>磁盘 2    联机               14 GB      0 B</p>
</li>
</ol>
<a id="more"></a>
<ol start="3">
<li>DISKPART&gt; select disk 2</li>
</ol>
<p>磁盘 2 现在是所选磁盘。</p>
<ol start="4">
<li><p>DISKPART&gt; clean<br>DiskPart 成功地清除了磁盘。</p>
</li>
<li><p>DISKPART&gt; create partition primary<br>DiskPart 成功地创建了指定分区。</p>
</li>
<li><p>DISKPART&gt; select partition 1</p>
</li>
</ol>
<p>分区 1 现在是所选分区。</p>
<ol start="7">
<li>DISKPART&gt; active</li>
</ol>
<p>DiskPart 将当前分区标为活动。</p>
<ol start="8">
<li><p>DISKPART&gt; format fs=ntfs quick</p>
<p>100 百分比已完成</p>
</li>
</ol>
<p>DiskPart 成功格式化该卷。</p>
<ol start="9">
<li>将ISO镜像文件打开,然后将其中的8个文件,复制到刚刚做好的U盘中</li>
<li>开启BIOS按F12 选择UEFI即可</li>
</ol>
]]></content>
      <categories>
        <category>启动U盘</category>
      </categories>
      <tags>
        <tag>NUC</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池-ThreadPoolExecutor详解</title>
    <url>/2019/08/19/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h3 id="ThreadPoolExecutor构造方法"><a href="#ThreadPoolExecutor构造方法" class="headerlink" title="ThreadPoolExecutor构造方法"></a>ThreadPoolExecutor构造方法</h3><p><img src="http://blog.sjjtcloud.com/blog/20190819/voP4iKK3jVUw.png?imageslim" alt="mark"></p>
<p>我们以最后一个构造方法（参数最多的那个），对其参数进行解释：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize, // 1</span><br><span class="line">                             int maximumPoolSize,  // 2</span><br><span class="line">                             long keepAliveTime,  // 3</span><br><span class="line">                             TimeUnit unit,  // 4</span><br><span class="line">                             BlockingQueue&lt;Runnable&gt; workQueue, // 5</span><br><span class="line">                             ThreadFactory threadFactory,  // 6</span><br><span class="line">                             RejectedExecutionHandler handler ) &#123; //7</span><br><span class="line">       if (corePoolSize &lt; 0 ||</span><br><span class="line">           maximumPoolSize &lt;= 0 ||</span><br><span class="line">           maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">           keepAliveTime &lt; 0)</span><br><span class="line">           throw new IllegalArgumentException();</span><br><span class="line">       if (workQueue == null || threadFactory == null || handler == null)</span><br><span class="line">           throw new NullPointerException();</span><br><span class="line">       this.corePoolSize = corePoolSize;</span><br><span class="line">       this.maximumPoolSize = maximumPoolSize;</span><br><span class="line">       this.workQueue = workQueue;</span><br><span class="line">       this.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">       this.threadFactory = threadFactory;</span><br><span class="line">       this.handler = handler;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<table>
<thead>
<tr>
<th>序号</th>
<th>名称</th>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>corePoolSize</td>
<td>int</td>
<td>核心线程池大小</td>
</tr>
<tr>
<td>2</td>
<td>maximumPoolSize</td>
<td>int</td>
<td>最大线程池大小</td>
</tr>
<tr>
<td>3</td>
<td>keepAliveTime</td>
<td>long</td>
<td>线程最大空闲时间</td>
</tr>
<tr>
<td>4</td>
<td>unit</td>
<td>TimeUnit</td>
<td>时间单位</td>
</tr>
<tr>
<td>5</td>
<td>workQueue</td>
<td>BlockingQueue<runnable></runnable></td>
<td>线程等待队列(用来暂时保存任务的工作队列)</td>
</tr>
<tr>
<td>6</td>
<td>threadFactory</td>
<td>ThreadFactory</td>
<td>线程创建工厂</td>
</tr>
<tr>
<td>7</td>
<td>handler</td>
<td>RejectedExecutionHandler</td>
<td>拒绝策略(当ThreadPoolExecutor已经关闭或ThreadPoolExecutor已经饱和时（达到了最大线程池大小且工作队列已满），execute()方法将要调用的Handler。)</td>
</tr>
</tbody>
</table>
<p>如果对这些参数作用有疑惑的请看 <a href="https://www.jianshu.com/p/c41e942bcd64" target="_blank" rel="noopener">ThreadPoolExecutor概述</a>。<br>知道了各个参数的作用后，我们开始构造符合我们期待的线程池。首先看JDK给我们预定义的几种线程池：</p>
<h3 id="预定义的线程池"><a href="#预定义的线程池" class="headerlink" title="预定义的线程池"></a>预定义的线程池</h3><p>虽然这种创建线程池的方法比较简便，但是阿里巴巴开发规范中,明确指出禁止使用Executors来创建线程,因为这样创建线程池,有可能会导致OOM,  创建线程池应该使用ThreadPoolExecutor的方式, 其实这些创建线程池的方法,背后原理也是使用TreadPoolExecutor来创建的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">【强制】</span><br><span class="line">线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样</span><br><span class="line">的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</span><br><span class="line">说明：Executors 返回的线程池对象的弊端如下：</span><br><span class="line"></span><br><span class="line">1）FixedThreadPool 和 SingleThreadPool:</span><br><span class="line">允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。</span><br><span class="line"></span><br><span class="line">2）CachedThreadPool 和 ScheduledThreadPool:</span><br><span class="line">允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</span><br></pre></td></tr></table></figure>
<h3 id="Executors创建线程池"><a href="#Executors创建线程池" class="headerlink" title="Executors创建线程池"></a>Executors创建线程池</h3><p><code>Executors</code>创建线程池方法列表：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>newFixedThreadPool(int nThreads)</td>
<td>创建固定大小的线程池（请求队列不受限制）</td>
</tr>
<tr>
<td>newSingleThreadExecutor()</td>
<td>创建只有一个线程的线程池（请求队列不受限制）</td>
</tr>
<tr>
<td>newCachedThreadPool()</td>
<td>创建一个不限线程数上限的线程池，任何提交的任务都将立即执行（线程数不受限制）</td>
</tr>
<tr>
<td>newScheduledThreadPool(int corePoolSize)</td>
<td>此线程池支持定时以及周期性执行任务的需求（线程数不受限制）</td>
</tr>
</tbody>
</table>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><ol>
<li><strong>FixedThreadPool详解</strong><br>FixedThreadPool 被称为可重用固定线程数的线程池</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>corePoolSize与maximumPoolSize相等,都被设置为创建FixedThredPool时指定的参数nThreads(即其线程全为核心线程，是一个固定大小的线程池)；</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>当线程池中的线程数大于corePoolSize时，keepAliveTime表示的就是：多余的空闲线程等待新任务的最长时间，超过这个时间后多余的线程将被终止。这里把keepAliveTime设置为0L，意味着多余的空闲线程会被立即终止</li>
<li>keepAliveTime = 0 该参数默认对核心线程无效，而FixedThreadPool全部为核心线程；</li>
<li>workQueue 为LinkedBlockingQueue（无界阻塞队列），队列最大值为Integer.MAX_VALUE。如果任务提交速度持续大余任务处理速度，会造成队列大量阻塞。因为队列很大，很有可能在拒绝策略前，内存溢出。是其劣势；</li>
<li>FixedThreadPool的任务执行是无序的；</li>
</ul>
</blockquote>
<p>适用场景：可用于Web服务瞬时削峰，但需注意长时间持续高峰情况造成的队列阻塞。</p>
<ol start="2">
<li><strong>CachedThreadPool详解</strong><br>CachedThreadPool 是一个会根据需要创建新线程的线程池</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>corePoolSize = 0，maximumPoolSize = Integer.MAX_VALUE，即线程数量几乎无限制；</li>
<li>keepAliveTime = 60s，线程空闲60s后自动结束。</li>
<li>workQueue 为 SynchronousQueue 同步队列，这个队列类似于一个接力棒，入队出队必须同时传递，因为CachedThreadPool线程创建无限制，不会有队列等待，所以使用SynchronousQueue；</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>CachedThreadPool使用没有容量的SynchronousQueue作为线程池的工作队列，</li>
<li>CachedThreadPool的maximumPool是无界的。这意味着，如果主线程提交任务的速度高于maximumPool中线程处理任务的速度时，CachedThreadPool会不断创建新线程。极端情况下,CachedThreadPool会因为创建过多线程而耗尽CPU和内存资源</li>
</ul>
</blockquote>
<p>适用场景：快速处理大量耗时较短的任务，如Netty的NIO接受请求时，可使用CachedThreadPool。</p>
<ol start="3">
<li><strong>SingleThreadExecutor</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService</span><br><span class="line">        (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>SingleThreadExecutor的corePoolSize和maximumPoolSize被设置为1。其他参数与FixedThreadPool相同</li>
<li>SingleThreadExecutor使用无界队列LinkedBlockingQueue作为线程池的工作队列（队列的容量为Integer.MAX_VALUE)</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li></li>
</ul>
</blockquote>
<p>咋一瞅，不就是newFixedThreadPool(1)吗？定眼一看，这里多了一层FinalizableDelegatedExecutorService包装，这一层有什么用呢，写个dome来解释一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService fixedExecutorService = Executors.newFixedThreadPool(1);</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) fixedExecutorService;</span><br><span class="line">        System.out.println(threadPoolExecutor.getMaximumPoolSize());</span><br><span class="line">        threadPoolExecutor.setCorePoolSize(8);</span><br><span class="line"></span><br><span class="line">        ExecutorService singleExecutorService = Executors.newSingleThreadExecutor();</span><br><span class="line">//      运行时异常 java.lang.ClassCastException</span><br><span class="line">//      ThreadPoolExecutor threadPoolExecutor2 = (ThreadPoolExecutor) singleExecutorService;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>对比可以看出，FixedThreadPool可以向下转型为ThreadPoolExecutor，并对其线程池进行配置，而SingleThreadExecutor被包装后，无法成功向下转型。<strong>因此SingleThreadExecutor被定以后，无法修改，做到了真正的Single。</strong></p>
<ol start="4">
<li><strong>ScheduledThreadPool详解</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;</span><br><span class="line">    return new ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>newScheduledThreadPool调用的是ScheduledThreadPoolExecutor的构造方法</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>ScheduledThreadPoolExecutor继承自ThreadPoolExecutor。它主要用来在给定的延迟之后运行任务，或者定期执行任务。ScheduledThreadPoolExecutor的功能与Timer类似，但ScheduledThreadPoolExecutor功能更强大、更灵活。Timer对应的是单个后台线程，而ScheduledThreadPoolExecutor可以在构造函数中指定多个对应的后台线程数. </li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ScheduledThreadPoolExecutor(int corePoolSize) &#123;</span><br><span class="line">    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,</span><br><span class="line">          new DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="二、自定义线程池"><a href="#二、自定义线程池" class="headerlink" title="二、自定义线程池"></a>二、自定义线程池</h5><p>以下是自定义线程池，使用了有界队列，自定义ThreadFactory和拒绝策略的demo：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ThreadTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException, IOException &#123;</span><br><span class="line">        int corePoolSize = 2;</span><br><span class="line">        int maximumPoolSize = 4;</span><br><span class="line">        long keepAliveTime = 10;</span><br><span class="line">        TimeUnit unit = TimeUnit.SECONDS;</span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workQueue = new ArrayBlockingQueue&lt;&gt;(2);</span><br><span class="line">        ThreadFactory threadFactory = new NameTreadFactory();</span><br><span class="line">        RejectedExecutionHandler handler = new MyIgnorePolicy();</span><br><span class="line">        ThreadPoolExecutor executor = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit,</span><br><span class="line">                workQueue, threadFactory, handler);</span><br><span class="line">        executor.prestartAllCoreThreads(); // 预启动所有核心线程</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt;= 10; i++) &#123;</span><br><span class="line">            MyTask task = new MyTask(String.valueOf(i));</span><br><span class="line">            executor.execute(task);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.in.read(); //阻塞主线程</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class NameTreadFactory implements ThreadFactory &#123;</span><br><span class="line"></span><br><span class="line">        private final AtomicInteger mThreadNum = new AtomicInteger(1);</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Thread newThread(Runnable r) &#123;</span><br><span class="line">            Thread t = new Thread(r, &quot;my-thread-&quot; + mThreadNum.getAndIncrement());</span><br><span class="line">            System.out.println(t.getName() + &quot; has been created&quot;);</span><br><span class="line">            return t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class MyIgnorePolicy implements RejectedExecutionHandler &#123;</span><br><span class="line"></span><br><span class="line">        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line">            doLog(r, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void doLog(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line">            // 可做日志记录等</span><br><span class="line">            System.err.println( r.toString() + &quot; rejected&quot;);</span><br><span class="line">//          System.out.println(&quot;completedTaskCount: &quot; + e.getCompletedTaskCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class MyTask implements Runnable &#123;</span><br><span class="line">        private String name;</span><br><span class="line"></span><br><span class="line">        public MyTask(String name) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(this.toString() + &quot; is running!&quot;);</span><br><span class="line">                Thread.sleep(3000); //让任务执行慢点</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String getName() &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return &quot;MyTask [name=&quot; + name + &quot;]&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<p><img src="//upload-images.jianshu.io/upload_images/11183270-ef3cb072affbec03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/398/format/webp" alt></p>
<p>image.png</p>
<p>其中线程线程1-4先占满了核心线程和最大线程数量，然后4、5线程进入等待队列，7-10线程被直接忽略拒绝执行，等1-4线程中有线程执行完后通知4、5线程继续执行。</p>
<h4 id="总结，通过自定义线程池，我们可以更好的让线程池为我们所用，更加适应我的实际场景。"><a href="#总结，通过自定义线程池，我们可以更好的让线程池为我们所用，更加适应我的实际场景。" class="headerlink" title="总结，通过自定义线程池，我们可以更好的让线程池为我们所用，更加适应我的实际场景。"></a>总结，通过自定义线程池，我们可以更好的让线程池为我们所用，更加适应我的实际场景。</h4>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>CenOS7.5使用crontab定时备份数据库脚本</title>
    <url>/2019/08/07/CenOS7.5%E4%BD%BF%E7%94%A8crontab%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BD%E6%95%B0%E6%8D%AE%E5%BA%93%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h3 id="1-编写备份脚本mysqlBackup-sh"><a href="#1-编写备份脚本mysqlBackup-sh" class="headerlink" title="1.编写备份脚本mysqlBackup.sh"></a>1.编写备份脚本mysqlBackup.sh</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">DB_IP=localhost</span><br><span class="line">DB_PORT=3306</span><br><span class="line">DB_USER=root</span><br><span class="line">#密码 #＆这些需要转义加＼</span><br><span class="line">DB_PASSWORD=l\#cxhd3\&amp;0vx</span><br><span class="line">DB_NAME=business</span><br><span class="line">DB_BACKUP_DIR=/home/backup/mysql</span><br><span class="line"></span><br><span class="line">#切换目录</span><br><span class="line">cd $DB_BACKUP_DIR</span><br><span class="line">day=`date +%Y%m%d`</span><br><span class="line"></span><br><span class="line">#删除</span><br><span class="line">rm -rf $day</span><br><span class="line">mkdir $day</span><br><span class="line">cd $day</span><br><span class="line"></span><br><span class="line">echo &quot;================  开始备份..  =================&quot;</span><br><span class="line">tables=(tb_user tb_dept)</span><br><span class="line">for table in $&#123;tables[@]&#125;;</span><br><span class="line">do</span><br><span class="line"> backup_file_name=&quot;$&#123;table&#125;.sql&quot;</span><br><span class="line"> mysqldump -h$&#123;DB_IP&#125; -u$&#123;DB_USER&#125; -p$&#123;DB_PASSWORD&#125; -P$&#123;DB_PORT&#125; $DB_NAME $table&gt;$backup_file_name</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;================  结束备份..  =================&quot;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="2-配置邮件配置-不配置的话-Crontab执行后邮件无法发送"><a href="#2-配置邮件配置-不配置的话-Crontab执行后邮件无法发送" class="headerlink" title="2.配置邮件配置(不配置的话,Crontab执行后邮件无法发送)"></a>2.配置邮件配置(不配置的话,Crontab执行后邮件无法发送)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi  /etc/postfix/main.cf</span><br><span class="line">发现配置为：</span><br><span class="line">inet_interfaces = localhost</span><br><span class="line">inet_protocols = all</span><br><span class="line"></span><br><span class="line">改成：</span><br><span class="line">inet_interfaces = all</span><br><span class="line"></span><br><span class="line">inet_protocols = all</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">重新启动</span><br><span class="line">service postfix start</span><br></pre></td></tr></table></figure>
<h3 id="3-配置Crontab任务"><a href="#3-配置Crontab任务" class="headerlink" title="3.配置Crontab任务"></a>3.配置Crontab任务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ crontab -e</span><br><span class="line"></span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line">MAILTO=root</span><br><span class="line">HOME=/</span><br><span class="line"></span><br><span class="line">*/2 * * * * sh /home/backup/mysqlBackup.sh</span><br></pre></td></tr></table></figure>
<h3 id="4-查看任务执行日志"><a href="#4-查看任务执行日志" class="headerlink" title="4. 查看任务执行日志"></a>4. 查看任务执行日志</h3><p><code>vim /var/log/cron</code></p>
<h3 id="查看任务执行详情可以通过查看LINUX系统邮件-任务执行后Crontab会发送邮件给添加该任务的用户"><a href="#查看任务执行详情可以通过查看LINUX系统邮件-任务执行后Crontab会发送邮件给添加该任务的用户" class="headerlink" title="查看任务执行详情可以通过查看LINUX系统邮件,任务执行后Crontab会发送邮件给添加该任务的用户"></a>查看任务执行详情可以通过查看LINUX系统邮件,任务执行后Crontab会发送邮件给添加该任务的用户</h3><p>mail 常用命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mail 打开邮件列表</span><br><span class="line">mail p 查看邮件详情</span><br><span class="line">mail z 返回邮件列表</span><br><span class="line">mail d 删除邮件</span><br><span class="line">mail q 保存退出</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOs定时任务Crontab的使用</title>
    <url>/2019/08/07/CentOs%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1Crontab%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p> Linux 下通过crontab来执行定时任务,当安装完成操作系统之后，默认便会启动此任务调度命令。crond命令每分锺会定期检查是否有要执行的工作，如果有要执行的工作便会自动执行该工作。</p>
</blockquote>
<h2 id="linux任务调度的工作主要分为以下两类："><a href="#linux任务调度的工作主要分为以下两类：" class="headerlink" title="linux任务调度的工作主要分为以下两类："></a>linux任务调度的工作主要分为以下两类：</h2><ul>
<li>1、系统执行的工作：系统周期性所要执行的工作，如备份系统数据、清理缓存</li>
<li>2、个人执行的工作：某个用户定期要做的工作，例如每隔10分钟检查邮件服务器是否有新信，这些工作可由每个用户自行设置</li>
</ul>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>crontab [ -u user ] file<br>或<br>crontab [ -u user ] { -l | -r | -e }</p>
<h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><ul>
<li><p>-u user：用来设定某个用户的crontab服务,这个前提是你必须要有其权限(比如说是 root)才能够指定他人的时程表。如果不使用 -u user 的话，就是表示设定自己的时程表。</p>
</li>
<li><p>file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab</p>
</li>
<li><p>-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。</p>
</li>
<li><p>-l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。</p>
</li>
<li><p>-r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件.</p>
</li>
</ul>
<h2 id="crontab的文件格式"><a href="#crontab的文件格式" class="headerlink" title="crontab的文件格式"></a>crontab的文件格式</h2><p><img src="http://blog.sjjtcloud.com/blog/20190806/6dVEtGXqD2FO.png?imageslim" alt="mark"></p>
<a id="more"></a>
<p>分 时 日 月 星期 要运行的命令</p>
<p>第1列分钟0～59<br>第2列小时0～23（0表示子夜）<br>第3列日1～31<br>第4列月1～12<br>第5列星期0～7（0和7表示星期天）<br>第6列要运行的命令</p>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>列出crontab文件<br><code>$ crontab -l</code></p>
<p>编辑crontab文件<br><code>$ crontab -e</code><br>可以像使用vi编辑其他任何文件那样修改crontab文件并退出。如果修改了某些条目或添加了新的条目，那么在保存该文件时， cron会对其进行必要的完整性检查。如果其中的某个域出现了超出允许范围的值，它会提示你。 我们在编辑crontab文件时，没准会加入新的条目</p>
<p>删除crontab文件<br><code>$crontab -r</code></p>
<p>注解<br>最好在crontab文件的每一个条目之上加入一条注释，这样就可以知道它的功能、运行时间，更为重要的是，知道这是哪位用户的定时作业。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">实例1：每1分钟执行一次myCommand</span><br><span class="line"> * * * myCommand</span><br><span class="line"></span><br><span class="line">实例2：每小时的第3和第15分钟执行</span><br><span class="line">	3,15 * * * * myCommand</span><br><span class="line">	</span><br><span class="line">实例3：在上午8点到11点的第3和第15分钟执行</span><br><span class="line">	3,15 8-11 * * * myCommand</span><br><span class="line"></span><br><span class="line">实例4：每隔两天的上午8点到11点的第3和第15分钟执行</span><br><span class="line">	3,15 8-11 */2  *  * myCommand</span><br><span class="line"></span><br><span class="line">实例5：每周一上午8点到11点的第3和第15分钟执行</span><br><span class="line">	3,15 8-11 * * 1 myCommand</span><br><span class="line"></span><br><span class="line">实例6：每晚的21:30重启smb</span><br><span class="line">	30 21 * * * /etc/init.d/smb restart</span><br><span class="line"></span><br><span class="line">实例7：每月1、10、22日的4 : 45重启smb</span><br><span class="line">	45 4 1,10,22 * * /etc/init.d/smb restart</span><br><span class="line"></span><br><span class="line">实例8：每周六、周日的1 : 10重启smb</span><br><span class="line">	10 1 * * 6,0 /etc/init.d/smb restart</span><br><span class="line"></span><br><span class="line">实例9：每天18 : 00至23 : 00之间每隔30分钟重启smb</span><br><span class="line">	0,30 18-23 * * * /etc/init.d/smb restart</span><br><span class="line"></span><br><span class="line">实例10：每星期六的晚上11 : 00 pm重启smb</span><br><span class="line">	0 23 * * 6 /etc/init.d/smb restart</span><br><span class="line"></span><br><span class="line">实例11：每一小时重启smb</span><br><span class="line">	* */1 * * * /etc/init.d/smb restart</span><br><span class="line"></span><br><span class="line">实例12：晚上11点到早上7点之间，每隔一小时重启smb</span><br><span class="line">	0 23-7 * * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure>
<h2 id="案例-每2分钟执行一次test-sh中脚本"><a href="#案例-每2分钟执行一次test-sh中脚本" class="headerlink" title="案例(每2分钟执行一次test.sh中脚本)"></a>案例(每2分钟执行一次test.sh中脚本)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHELL=/bin/bash</span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line">MAILTO=root</span><br><span class="line">HOME=/</span><br><span class="line"></span><br><span class="line">*/2 * * * * sh /home/backup/test.sh</span><br></pre></td></tr></table></figure>
<h3 id="查看cron执行的日志"><a href="#查看cron执行的日志" class="headerlink" title="查看cron执行的日志"></a>查看cron执行的日志</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim /var/log/cron 看到如下记录日志,发现linux在执行任务后向管理员发送了邮件,但是这个邮件没有发送成功</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Aug  6 10:44:01 iZ3i4n96yv24gsZ CROND[2868]: (root) CMD (sh /home/backup/test.sh)</span><br><span class="line">Aug  6 10:44:01 iZ3i4n96yv24gsZ CROND[2867]: (root) MAIL (mailed 2802 bytes of output but got status 0x004b#012)</span><br><span class="line">Aug  6 10:45:01 iZ3i4n96yv24gsZ CROND[3976]: (root) CMD (sh /home/backup/test.sh)</span><br><span class="line">Aug  6 10:45:01 iZ3i4n96yv24gsZ CROND[3975]: (root) MAIL (mailed 2802 bytes of output but got status 0x004b#012)</span><br><span class="line">Aug  6 10:46:01 iZ3i4n96yv24gsZ CROND[5031]: (root) CMD (sh /home/backup/test.sh)</span><br><span class="line">Aug  6 10:46:01 iZ3i4n96yv24gsZ CROND[5030]: (root) MAIL (mailed 2802 bytes of output but got status 0x004b#012)</span><br></pre></td></tr></table></figure>
<p>###　问题：如果想要查看详细的任务执行日志,要查看登录用户的邮箱,本地测试时使用的root用户, 查看发现无root用户的任何邮件</p>
<h3 id="解決方式"><a href="#解決方式" class="headerlink" title="解決方式"></a>解決方式</h3><ol>
<li><p>查看mail的发送日志 <code>vim /var/log/maillog</code>  原因是 parameter inet_interfaces: no local interface found for ::1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Aug  6 10:42:01 iZ3i4n96yv24gsZ postfix/sendmail[584]: fatal: parameter inet_interfaces: no local interface found for ::1</span><br><span class="line">Aug  6 10:43:01 iZ3i4n96yv24gsZ postfix/sendmail[1817]: fatal: parameter inet_interfaces: no local interface found for ::1</span><br><span class="line">Aug  6 10:44:01 iZ3i4n96yv24gsZ postfix/sendmail[2870]: fatal: parameter inet_interfaces: no local interface found for ::1</span><br><span class="line">Aug  6 10:45:01 iZ3i4n96yv24gsZ postfix/sendmail[3978]: fatal: parameter inet_interfaces: no local interface found for ::1</span><br><span class="line">Aug  6 10:46:01 iZ3i4n96yv24gsZ postfix/sendmail[5033]: fatal: parameter inet_interfaces: no local interface found for ::1</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过google发现解决方式为</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">vi  /etc/postfix/main.cf</span><br><span class="line">发现配置为：</span><br><span class="line">inet_interfaces = localhost</span><br><span class="line">inet_protocols = all</span><br><span class="line"></span><br><span class="line">改成：</span><br><span class="line">inet_interfaces = all</span><br><span class="line"></span><br><span class="line">inet_protocols = all</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">重新启动</span><br><span class="line">service postfix start</span><br></pre></td></tr></table></figure>
</li>
<li><p>再等待一个周期后,收到了定时任务推送的邮件,查看邮件内容,一切正常</p>
</li>
</ol>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>crontab</tag>
      </tags>
  </entry>
  <entry>
    <title>java面试系列问题(4)</title>
    <url>/2019/08/07/%E9%9D%A2%E8%AF%954/</url>
    <content><![CDATA[<p>一、Java基础</p>
<p>为什么JVM调优经常会将-Xms和-Xmx参数设置成一样；</p>
<p>Java线程池的核心属性以及处理流程；</p>
<p>Java内存模型，方法区存什么；</p>
<p>CMS垃圾回收过程；</p>
<p>Full GC次数太多了，如何优化；</p>
<p>直接内存如何管理的；</p>
<p>Java线程池的几个参数的意义和实现机制；</p>
<p>Java线程池使用无界任务队列和有界任务队列的优劣对比；</p>
<p>CountDownLatch和CyclicBarrier的区别；</p>
<p>Java中有哪些同步方案（重量级锁、显式锁、并发容器、并发同步器、CAS、volatile、AQS等）</p>
<p>如果你的项目出现了内存泄露，怎么监控这个问题呢；</p>
<p>标记清除和标记整理的区别和优缺点，为何标记整理会发生stop the world；</p>
<p>线程池，如何根据CPU的核数来设计线程大小，如果是计算机密集型的呢，如果是IO密集型的呢？</p>
<p>让你设计一个cache如何设计；</p>
<p>String中hashcode是怎么实现的；</p>
<p>JDK中哪些实现了单例模式？</p>
<p>多个线程同时读写，读线程的数量远远⼤于写线程，你认为应该如何解决并发的问题？你会选择加什么样的锁？</p>
<p>线程池内的线程如果全部忙，提交⼀个新的任务，会发⽣什么？队列全部塞满了之后，还是忙，再提交会发⽣什么？</p>
<p>synchronized关键字锁住的是什么东西？在字节码中是怎么表示的？在内存中的对象上表现为什么？</p>
<p>wait/notify/notifyAll⽅法需不需要被包含在synchronized块中？这是为什么？</p>
<p>ExecutorService你一般是怎么⽤的？是每个Service放一个还是个项目放一个？有什么好处？</p>
<p>二、数据库</p>
<p>InnoDB的插入缓冲和两次写的概率和意义；</p>
<p>如果建了⼀个单列索引，查询的时候查出2列，会⽤到这个单列索引吗？（会用到）</p>
<p>如果建了⼀个包含多个列的索引，查询的时候只⽤了第⼀列，能不能⽤上这个索引？查三列呢？</p>
<p>接上题，如果where条件后⾯带有⼀个 i + 5 &lt; 100 会使⽤到这个索引吗？</p>
<p>like %aaa%会使⽤索引吗? like aaa%呢?</p>
<p>drop、truncate、delete的区别？</p>
<p>平时你们是怎么监控数据库的? 慢SQL是怎么排查的？（慢查询日志）</p>
<p>你们数据库是否⽀持emoji表情，如果不⽀持，如何操作?选择什么编码方式？如果支持一个表情占几个字节?(utf8mb4)；</p>
<p>如果查询很慢，你会想到的第⼀个⽅式是什么？（数据库索引）</p>
<p>三、Linux基础</p>
<p>Linux下可以在/proc目录下可以查看CPU的核心数等；cat /proc/下边会有很多系统内核信息可供显示； </p>
<p>说一下栈的内存是怎么分配的；</p>
<p>Linux各个目录有了解过吗？/etc、/bin、/dev、/lib、/sbin这些常见的目录主要作用是什么？</p>
<p>说一下栈帧的内存是怎么分配的；</p>
<p>Linux下排查某个死循环的线程；</p>
<p>动态链接和静态链接的区别；</p>
<p>进程的内存分布；</p>
<p>如何查找一个进程打开所有的文件；</p>
<p>说一下常使用的协议及其对应的端口；</p>
<p>为什么会有内核态，保护模式你知道吗?</p>
<p>文件是怎么在磁盘上存储的？</p>
<p>有了进程为何还要线程呢，不同进程和线程他们之间有什么不同。（进程是资源管理的最小单位，线程是程序执行的最小单位。在操作系统设计上，从进程演化出线程，最主要的目的就是更好的支持SMP以及减小（进程/线程）上下文切换开销。）</p>
<p>InnoDB聚集索引B+树叶子节点和磁盘什么顺序相同;</p>
<p>文件系统，进程管理和调度，内存管理机制、虚地址保护模式；</p>
<p>四、网络基础</p>
<p>HTTP1.0和HTTP1.1的区别；</p>
<p>DHCP如何实现分配IP的； 发现阶段（DHCP客户端在网络中广播发送DHCP DISCOVER请求报文，发现DHCP服务器，请求IP地址租约）、提供阶段（DHCP服务器通过DHCP OFFER报文向DHCP客户端提供IP地址预分配）、选择阶段（DHCP客户端通过DHCP REQUEST报文确认选择第一个DHCP服务器为它提供IP地址自动分配服务）和确认阶段（被选择的DHCP服务器通过DHCP ACK报文把在DHCP OFFER报文中准备的IP地址租约给对应DHCP客户端）。</p>
<p>OSI七层模型，每层都说下自己的理解和知道的，说的越多越好；</p>
<p>五、框架相关</p>
<p>Servlet如何保证单例模式,可不可以编程多例的哪？</p>
<p>Dubbo请求流程以及原理；</p>
<p>Spring框架如何实现事务的；</p>
<p>如果一个接⼝有2个不同的实现, 那么怎么来Autowire一个指定的实现？(可以使用Qualifier注解限定要注入的Bean，也可以使用Qualifier和Autowire注解指定要获取的bean，也可以使用Resource注解的name属性指定要获取的Bean)</p>
<p>Spring框架中需要引用哪些jar包，以及这些jar包的用途；</p>
<p>Spring Boot没有放到web容器⾥为什么能跑HTTP服务？</p>
<p>Spring中循环注入是什么意思，可不可以解决，如何解决；</p>
<p>Spring的声明式事务 @Transaction注解⼀般写在什么位置? 抛出了异常会⾃动回滚吗？有没有办法控制不触发回滚?</p>
<p>MyBatis怎么防止SQL注入；</p>
<p>Tomcat本身的参数你⼀般会怎么调整？</p>
<p>了解哪几种序列化协议？如何选择合适的序列化协议；</p>
<p>Redis渐进式rehash过程？</p>
<p>比如我有个电商平台，做每日订单的异常检测，服务端代码应该写；</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>java面试系列问题(3)</title>
    <url>/2019/08/07/%E9%9D%A2%E8%AF%953/</url>
    <content><![CDATA[<p>一、基础题</p>
<p>怎么解决Hash冲突；（开放地址法、链地址法、再哈希法、建立公共溢出区等）</p>
<p>写出一个必然会产生死锁的伪代码；</p>
<p>Spring IoC涉及到的设计模式；（工厂模式、单利模式。。）</p>
<p>toString()方法什么情况下需要重写；</p>
<p>判断对象相等时，什么情况下只需要重写 equals()，什么情况下需要重写 equals(),hashcode()？</p>
<p>Set内存放的元素为什么不可以重复，内部是如何保证和实现的？</p>
<p>如何保证分布式缓存的一致性(分布式缓存一致性hash算法?)？分布式session实现？</p>
<p>Java 8流式迭代的好处？</p>
<p>项目中用到的JDK的哪些特性？</p>
<p>说一下TreeMap的实现原理？红黑树的性质？红黑树遍历方式有哪些？如果key冲突如何解决？setColor()方法在什么时候用？什么时候会进行旋转和颜色转换？</p>
<p>Spring的bean的创建时机？依赖注入的时机？</p>
<p>ArrayList和LinkList的删除一个元素的时间复杂度；（ArrayList是O(N)，LinkList是O(1)）；</p>
<p>CopyOnWriteArrayList是什么；</p>
<p>序列化和反序列化底层如何实现的（ObjectOutputStream 、ObjectInputStream、 readObject  writeObject）；</p>
<p>如何调试多线程的程序；</p>
<p>一个线程连着调用start两次会出现什么情况？（由于状态只有就绪、阻塞、执行，状态是无法由执行转化为执行的，所以会报不合法的状态！）</p>
<p>HashMap在什么时候时间复杂度是O（1），什么时候是O（n），什么时候又是O（logn）；</p>
<p>wait方法能不能被重写？（wait是final类型的，不可以被重写，不仅如此，notify和notifyall都是final类型的），wait能不能被中断；</p>
<p>一个Controller调用两个Service，这两Service又都分别调用两个Dao，问其中用到了几个数据库连接池的连接？</p>
<p>二、网络基础</p>
<p>HTTP、TCP、UDP的区别和联系；</p>
<p>TCP和UDP各自的优势，知道哪些使用UDP协议的成功案例；</p>
<p>TCP和UDP各用了底层什么协议；</p>
<p>单个UDP报文最大容量；</p>
<p>单个TCP报文最大容量；</p>
<p>TCP报头格式、UDP报头格式；</p>
<p>Server遭遇SYN Flood应当怎么处理；</p>
<p>Web开发中如何防范XSS？</p>
<p>拆包和粘包的问题，如何解决，如果我们的包没有固定长度的话，我们的应用程序应该如何解决；</p>
<p>三、操作系统</p>
<p>为什么要内存对齐；</p>
<p>为什么会有大端小端，htol这一类函数的作用；</p>
<p>top显示出来的系统信息都是什么含义；（重要！）</p>
<p>Linux地址空间，怎么样进行寻址的；</p>
<p>Linux如何查找目录或者文件的；</p>
<p>四、分布式其他</p>
<p>分库与分表带来的分布式困境与应对之策；</p>
<p>Solr如何实现全天24小时索引更新；</p>
<p>五、Redis</p>
<p>Redis插槽的分配（key的有效部分使用CRC16算法计算出哈希值，再将哈希值对16384取余，得到插槽值）;</p>
<p>Redis主从是怎么选取的（一种是主动切换，另一种是使用sentinel自动方式）;</p>
<p>Redis复制的过程;</p>
<p>Redis队列应用场景；</p>
<p>Redis主节点宕机了怎么办，还有没有同步的数据怎么办;</p>
<p>六、系统设计开放性题目</p>
<p>秒杀系统设计，超卖怎么搞;</p>
<p>你们的图片时怎么存储的，对应在数据库中时如何保存图片的信息的？</p>
<p>假如成都没有一座消防站，现在问你要建立几座消防站，每个消防站要配多少名消防官兵，多少辆消防车，请你拿出一个方案；</p>
<p>基于数组实现一个循环阻塞队列；</p>
<p>常见的ipv4地址的展现形式如“168.0.0.1”，请实现ip地址和int类型的相互转换。（使用位移的方式）</p>
<p>现网某个服务部署在多台Liunx服务器上，其中一台突然出现CPU 100%的情况，而其他服务器正常，请列举可能导致这种情况发生的原因？如果您遇到这样的情况，应如何定位？内存？CPU？发布？debug？请求量？</p>
<p>七、大数据量问题（后边会有专题单独讨论）</p>
<p>给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？</p>
<p>海量日志数据，提取出某日访问百度次数最多的那个IP；</p>
<p>一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。</p>
<p>此话题后边会有专门的文章探讨，如果有等不及的小伙伴，可以移步参考：</p>
<p>1、<a href="https://blog.csdn.net/v_july_v/article/details/6279498" target="_blank" rel="noopener">https://blog.csdn.net/v_july_v/article/details/6279498</a></p>
<p>2、<a href="https://blog.csdn.net/v_july_v/article/details/7382693" target="_blank" rel="noopener">https://blog.csdn.net/v_july_v/article/details/7382693</a></p>
<p>八、逻辑思维题</p>
<p>有两根粗细均匀的香（烧香拜佛的香），每一根烧完都花一个小时，怎么样能够得到15min？</p>
<p>假定你有8个撞球，其中有1个球比其他的球稍重,如果只能利用天平来断定哪一个球重,要找到较重的球,要称几次?（2次）；</p>
<p>实验室里有1000个一模一样的瓶子，但是其中的一瓶有毒。可以用实验室的小白鼠来测试哪一瓶是毒药。如果小白鼠喝掉毒药的话，会在一个星期的时候死去，其他瓶子里的药水没有任何副作用。请问最少用多少只小白鼠可以在一个星期以内查出哪瓶是毒药；（答案是10只）</p>
<p>假设有一个池塘，里面有无穷多的水。现有2个空水壶，容积分别为5升和6升。问题是如何只用这2个水壶从池塘里取得3升的水；</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>java面试系列问题(1)</title>
    <url>/2019/08/07/%E9%9D%A2%E8%AF%951/</url>
    <content><![CDATA[<h3 id="1-final-finally-finalize-的区别"><a href="#1-final-finally-finalize-的区别" class="headerlink" title="1. final, finally, finalize 的区别"></a>1. final, finally, finalize 的区别</h3><p> final它是java中的一个关键字和修饰符,用于声明属性,方法，类，分别标书修饰的属性不可变,方法不可覆盖,类不可继承  </p>
<p> finally是异常处理语句结构的一部分，表示总是执行,使用 finally 可以维护对象的内部状态，并可以清理非内存资源 </p>
<p> finallize这个方法是Object类的一个方法，因此所有类都继承了它,当垃圾收集器确定某个对象不再被引用时，会调用该方法做清理工作,如果想要执行自定义的清理工作，可以在子类中覆盖该方法.</p>
<h3 id="2-Exception、Error、运行时异常与一般异常有何异同"><a href="#2-Exception、Error、运行时异常与一般异常有何异同" class="headerlink" title="2. Exception、Error、运行时异常与一般异常有何异同"></a>2. Exception、Error、运行时异常与一般异常有何异同</h3><p><img src="http://pam1kb0ai.bkt.clouddn.com/java%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB.png" alt="Java异常类层次结构图"></p>
<p>Error层次结构描述了java运行时系统的内部错误和资源耗尽错误。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题</p>
<p>Exceprion这个层次结构又分解为连个分支：一个分支派生于RuntimeException；另一个分支包含其他异常。划分两个分支的规则是：由程序错误导致的异常属于RuntimeException；而程序本身没有没有问题，但由于像I/O错误这类异常导致的异常属于其他异常  </p>
<h3 id="3-请写出5种常见到的runtime-exception"><a href="#3-请写出5种常见到的runtime-exception" class="headerlink" title="3. 请写出5种常见到的runtime exception"></a>3. 请写出5种常见到的runtime exception</h3><p>NullpointerExection IndexOutOfBoundsException NumberFormatException FileNotFoundException EofException</p>
<h3 id="4-int-和-Integer-有什么区别，Integer的值缓存范围"><a href="#4-int-和-Integer-有什么区别，Integer的值缓存范围" class="headerlink" title="4. int 和 Integer 有什么区别，Integer的值缓存范围"></a>4. int 和 Integer 有什么区别，Integer的值缓存范围</h3><p>int是java中基本数据类型，Integer是对象类型,它是int的包装类<br>java对于-128到127之间的数，会进行缓存</p>
<h3 id="5-包装类，装箱和拆箱"><a href="#5-包装类，装箱和拆箱" class="headerlink" title="5.包装类，装箱和拆箱"></a>5.包装类，装箱和拆箱</h3><p>Java中的基本类型功能简单，不具备对象的特性，为了使基本类型具备对象的特性，所以出现了包装类，就可以像操作对象一样操作基本类型数据  </p>
<p>装箱就是 自动将基本数据类型转换为包装器类型；拆箱就是  自动将包装器类型转换为基本数据类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java5之前如果要定义一个值为10的Integer对象 必须这样定义 Integer i = new Integer(10)</span><br><span class="line">Integer i = 10;  //装箱</span><br><span class="line">int n = i;   //拆箱</span><br></pre></td></tr></table></figure>
<h3 id="6-String、StringBuilder、StringBuffer"><a href="#6-String、StringBuilder、StringBuffer" class="headerlink" title="6.String、StringBuilder、StringBuffer"></a>6.String、StringBuilder、StringBuffer</h3><p>1.执行速度StringBuilder &gt; StringBuffer &gt; String<br>2.操作少量数据用String, 单线程下操作大量字符串数据用StringBuilder, 多线程下操作大量数据用StringBuffer</p>
<h3 id="7-重载和重写的区别"><a href="#7-重载和重写的区别" class="headerlink" title="7.重载和重写的区别"></a>7.重载和重写的区别</h3><p>重载(Overload):<br>方法名称相同, 参数个数或类型不同，可以有不同的返回类型,可以有不同的访问修饰符,可以抛出不同的异常.  </p>
<p>重写(Override):<br>参数列表与被重写的方法相同，返回类型与被重写的方法一致，访问修饰符要大于被重写方法的修饰符  </p>
<h3 id="8-抽象类和接口有什么区别"><a href="#8-抽象类和接口有什么区别" class="headerlink" title="8.抽象类和接口有什么区别"></a>8.抽象类和接口有什么区别</h3><p>1.抽象类可以有默认的方法实现,接口完全是抽象的不存在方法实现<br>2.抽象类可以有构造器, 接口没有构造器<br>3.抽象类的修饰符可以是public,protected,default; 接口默认都是public,不能使用其他修饰符<br>4.抽象类比接口速度更快，因为接口需要寻找它的实现类<br>5.抽象类可以继承1个类并可以实现多个接口， 接口只能实现接口 不能继承接口</p>
<h3 id="9-说说反射的用途及实现"><a href="#9-说说反射的用途及实现" class="headerlink" title="9.说说反射的用途及实现"></a>9.说说反射的用途及实现</h3><p>反射是java的特征之一, 通过反射我们可以在程序运行时获知程序的每个属性和方法<br>用途:<br>    反射最重要的用途就是开发各种通用框架<br>    很多框架（比如 Spring）都是配置化的（比如通过 XML文件配置 JavaBean，Action之类的），为了保证框架的通用性，他们可能根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。<br>举一个例子，在运用Struts 2框架的开发中我们一般会在struts.xml里去配置Action，比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;action name=&quot;login&quot; class=&quot;org.ScZyhSoft.test.action.SimpleLoginAction&quot;  method=&quot;execute&quot;&gt;  </span><br><span class="line">   &lt;result&gt;/shop/shop-index.jsp&lt;/result&gt;  </span><br><span class="line">   &lt;result name=&quot;error&quot;&gt;login.jsp&lt;/result&gt;  </span><br><span class="line">&lt;/action&gt;</span><br></pre></td></tr></table></figure>
<p>配置文件与Action建立了一种映射关系，当View层发出请求时，请求会被StrutsPrepareAndExecuteFilter拦截，然后StrutsPrepareAndExecuteFilter会去动态地创建Action实例。<br>——比如我们请求login.action，那么StrutsPrepareAndExecuteFilter就会去解析struts.xml文件，检索action中name为login的Action，并根据class属性创建SimpleLoginAction实例，并用invoke方法来调用execute方法，这个过程离不开反射。<br>对与框架开发人员来说，反射虽小但作用非常大，它是各种容器实现的核心。而对于一般的开发者来说，不深入框架开发则用反射用的就会少一点，不过了解一下框架的底层机制有助于丰富自己的编程思想，也是很有益的。</p>
<h3 id="10-说说自定义注解的场景及实现"><a href="#10-说说自定义注解的场景及实现" class="headerlink" title="10.说说自定义注解的场景及实现"></a>10.说说自定义注解的场景及实现</h3><p>场景：日志管理，缓存处理，权限验证等<br>实现：在需要验证的地方增加一个切面，通过反射获取方法所包含的注解，比如包含自定义的注解，就进行相应的功能处理</p>
<h3 id="11-HTTP请求的GET与POST方式的区别"><a href="#11-HTTP请求的GET与POST方式的区别" class="headerlink" title="11.HTTP请求的GET与POST方式的区别"></a>11.HTTP请求的GET与POST方式的区别</h3><p>GET请求：请求参数会被拼接到URL后,可以拼接的长度受限制，而且如果有敏感信息 相对是不安全的<br>POST请求: 为了克服GET请求的限制，post传递参数会被放入请求体中，可以发送的参数数目不受限制，因为外部不可见，因此相对安全</p>
<h3 id="12-Session与Cookie区别"><a href="#12-Session与Cookie区别" class="headerlink" title="12.Session与Cookie区别"></a>12.Session与Cookie区别</h3><p>session是基于服务端的会话管理，用于跟踪用户状态 这个数据可以保存在内存中，数据库中或者集群中<br>cookie是基于客户端的会话管理,数据保存在客户端中</p>
<h3 id="13-列出自己常用的JDK包"><a href="#13-列出自己常用的JDK包" class="headerlink" title="13.列出自己常用的JDK包"></a>13.列出自己常用的JDK包</h3><p>java.util.<em> java.io.</em></p>
<h3 id="14-MVC设计思想"><a href="#14-MVC设计思想" class="headerlink" title="14.MVC设计思想"></a>14.MVC设计思想</h3><p>MODEL模型用来封装业务逻辑，<br>VIEW 视图用来实现表示逻辑，<br>Controller 控制器用来协调模型与视图(视图要通过控制器来调用模型，模型返回的处理结果也要先交给控制器，由控制器来选择合适的视图来显示 处理结果)。<br>这种设计思想 可以使各个层之间相互独立 又能相互协作，可以是业务逻辑与我们表现层视图进行解耦，有利于分工合作及快速开发</p>
<h3 id="15-equals与-的区别"><a href="#15-equals与-的区别" class="headerlink" title="15.equals与==的区别"></a>15.equals与==的区别</h3><p>equals和==的第一个区别就是  他们一个是方法，一个是运算符，它们比较的都是物理地址 而不是值得比较<br>Java 语言里的 equals方法其实是交给开发者去覆写的，让开发者自己去定义满足什么条件的两个Object是equal的</p>
<p>由于String对象中重写了equals方法 当物理地址不同时，会进一步比较值，所以比较字符串时我们是用equals方法<br>如果我们要重写一个对象比如Student的equals方法，必须要同时重写equals() 和hashcode()方法,因为只重写equals方法是无法改变hashcode值的 而比较时首先比较的就是hashcode，所以我们通常是在编辑器中 右键-&gt;source-&gt;generate hashcode() and equals() 来实现。</p>
<h3 id="16-什么是Java序列化和反序列化，如何实现Java序列化？或者请解释Serializable-接口的作用"><a href="#16-什么是Java序列化和反序列化，如何实现Java序列化？或者请解释Serializable-接口的作用" class="headerlink" title="16.什么是Java序列化和反序列化，如何实现Java序列化？或者请解释Serializable 接口的作用"></a>16.什么是Java序列化和反序列化，如何实现Java序列化？或者请解释Serializable 接口的作用</h3><ul>
<li>序列化：把对象转换为字节序列的过程</li>
<li><p>反序列化: 把字节序列转化为对象的过程<br>对象序列化用途：<br>1.将对象字节序列永久保存在硬盘上 通常保存在一个文件中<br>2.在网络上传送对象的字节序列</p>
</li>
<li><p>java.io.ObjectOutputStream代表对象输出流，它的writeObject(Object obj)方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。</p>
</li>
<li>java.io.ObjectInputStream代表对象输入流，它的readObject()方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectOutputStream oo = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"E:/Person.txt"</span>))); </span><br><span class="line">oo.writeObject(person); </span><br><span class="line">System.out.println(<span class="string">"Person对象序列化成功！"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="17-Object类中常见的方法，为什么wait-notify会放在Object里边？"><a href="#17-Object类中常见的方法，为什么wait-notify会放在Object里边？" class="headerlink" title="17.Object类中常见的方法，为什么wait  notify会放在Object里边？"></a>17.Object类中常见的方法，为什么wait  notify会放在Object里边？</h3><p>简单说：因为synchronized中的这把锁可以是任意对象，所以任意对象都可以调用wait()和notify()；所以wait和notify属于Object。</p>
<p>专业说：因为这些方法在操作同步线程时，都必须要标识它们操作线程的锁，只有同一个锁上的被等待线程，可以被同一个锁上的notify唤醒，不可以对不同锁中的线程进行唤醒。<br>也就是说，等待和唤醒必须是同一个锁。而锁可以是任意对象，所以可以被任意对象调用的方法是定义在object类中。</p>
<h3 id="18-Java的平台无关性如何体现出来的"><a href="#18-Java的平台无关性如何体现出来的" class="headerlink" title="18.Java的平台无关性如何体现出来的"></a>18.Java的平台无关性如何体现出来的</h3><ul>
<li>Java程序则编译为字节码。字节码本身不能运行，因为它不是原生代码。字节码只能够在Java虚拟机（JVM）上运行</li>
<li>JVM是一个原生应用程序，它负责解释字节码。通过使用JVM可用在众多的平台上（这也就是Java可以做到平台无关性的原因），Sun公司将Java变成了跨平台的语言。如下图模型，完全相同的字节码可以在已经开发了JVM的任何操作系统上运行<br><img src="http://pam1kb0ai.bkt.clouddn.com/java%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E8%B7%A8%E5%B9%B3%E5%8F%B0.jpg" alt="java跨平台原理"></li>
</ul>
<h3 id="19-JDK和JRE的区别"><a href="#19-JDK和JRE的区别" class="headerlink" title="19.JDK和JRE的区别"></a>19.JDK和JRE的区别</h3><ul>
<li>JDK（Java Development Kit）JDK是整个JAVA的核心，包括了Java运行环境JRE（Java Runtime Envirnment）、一堆Java工具（javac/java/jdb等）和Java基础的类库</li>
<li>Java Runtime Environment（JRE）他就是java运行环境 并不是一个开发环境，所以没有包含任何开发工具</li>
</ul>
<h3 id="20-Java-8有哪些新特性"><a href="#20-Java-8有哪些新特性" class="headerlink" title="20.Java 8有哪些新特性"></a>20.Java 8有哪些新特性</h3><ul>
<li>Lambda表达式和函数式接口,它允许我们将函数当成参数传递给某个方法</li>
<li>接口的默认方法（default修饰)</li>
</ul>
<h3 id="21-Java常见集合"><a href="#21-Java常见集合" class="headerlink" title="21.Java常见集合"></a>21.Java常见集合</h3><p>ArrayList,LinkedList,HashMap,HashTable,Set,HashSet,TreeSet</p>
<h3 id="22-List-和-Set-区别"><a href="#22-List-和-Set-区别" class="headerlink" title="22.List 和 Set 区别"></a>22.List 和 Set 区别</h3><ul>
<li>1.List,Set都实现了Collection接口</li>
<li>2.List它是一个有序的集合输出顺序就是插入顺序，可以允许插入重复对象，可以插入null元素，常用的实现有ArrayList,LinkedList,Vector</li>
<li>3.Set 是一一个无序的容器(存入和取出顺序不一定一致)，不允许插入重复对象,常用实现HashSet,LinkedHashSet,TreeSet</li>
</ul>
<h3 id="23-HashSet如何保证数据唯一性？"><a href="#23-HashSet如何保证数据唯一性？" class="headerlink" title="23.HashSet如何保证数据唯一性？"></a>23.HashSet如何保证数据唯一性？</h3><p>HashSet底层数据接口是哈希表,怎样保证数据唯一性呢？它是通过HashCode和equals来完成的，<br>如果元素的Hashcode值相同,才会判断equals是否为true,如果hashcode值不同，不会调用equals方法</p>
<p>在java的集合中，判断两个对象是否相等的规则是:<br>判断两个对象的hashCode否相等</p>
<ol>
<li>如果相等 就认为两个对象不相等，完毕</li>
<li>如果不相等，调用对象的equals()方法判断是否相等，如果不相等，认为两个对象也不相等</li>
</ol>
<p>为什么要通过hashCode()和equlas()两条规则呢?<br> 因为hashCode()相等时 equlas()也可能不相等，String,Double类都重写了hashCode()方法和equlas()方法，我们自己定义的对象也可以重写hashCode()和equlas()方法</p>
<h3 id="24-List-和-Map-区别"><a href="#24-List-和-Map-区别" class="headerlink" title="24.List 和 Map 区别"></a>24.List 和 Map 区别</h3><p>List是有顺序的集合，Map是通过键值对存取的容器,Key和Value一一对应<br>Set,List都继承自Collection接口,List接口有三个实现类：ArrayList，Vector，LinkedList<br>HashMap,HashTable实现了  Map&lt;E,V&gt;接口</p>
<h3 id="25-Arraylist-与-LinkedList-区别"><a href="#25-Arraylist-与-LinkedList-区别" class="headerlink" title="25.Arraylist 与 LinkedList 区别"></a>25.Arraylist 与 LinkedList 区别</h3><p>ArrayList,LinkedList是List接口的两个实现类，他们都实现了List接口的方法,只是实现的方式不同</p>
<p>ArrayList它是以数组的方式来实现的,数组的特性是可以使用索引的方式来快速定位对象的位置,因此对于快速的随机取得对象的需求,使用ArrayList实现执行效率上会比较好<br>LinkedList是采用链表的方式来实现List接口的,它本身有自己特定的方法，如: addFirst(),addLast(),getFirst(),removeFirst()等. 由于是采用链表实现的,因此在进行insert和remove动作时在效率上要比ArrayList要好得多!适合用来实现Stack(堆栈)与Queue(队列),前者先进后出，后者是先进先出.</p>
<h3 id="26-在删除可插入对象的动作时，为什么ArrayList的效率会比较低呢"><a href="#26-在删除可插入对象的动作时，为什么ArrayList的效率会比较低呢" class="headerlink" title="26.在删除可插入对象的动作时，为什么ArrayList的效率会比较低呢?"></a>26.在删除可插入对象的动作时，为什么ArrayList的效率会比较低呢?</h3><p>ArrayList是使用数组实现的,若要从数组中删除或插入某一个对象，需要移动后段的数组元素，从而会重新调整索引顺序,调整索引顺序会消耗一定的时间，所以速度上就会比LinkedList要慢许多. 相反,LinkedList是使用链表实现的,若要从链表中删除或插入某一个对象,只需要改变前后对象的引用即可</p>
<h3 id="27-ArrayList-与-Vector-区别"><a href="#27-ArrayList-与-Vector-区别" class="headerlink" title="27.ArrayList 与 Vector 区别"></a>27.ArrayList 与 Vector 区别</h3><p>List接口有三个实现类：ArrayList，Vector，LinkedList<br>1） Vector的方法都是同步的(Synchronized),是线程安全的(thread-safe)，而ArrayList的方法不是，由于线程的同步必然要影响性能，因此,ArrayList的性能比Vector好。<br>2） 当Vector或ArrayList中的元素超过它的初始大小时,Vector会将它的容量翻倍,而ArrayList只增加50%的大小，这样,ArrayList就有利于节约内存空间。</p>
<h3 id="28-HashMap-和-Hashtable-的区别"><a href="#28-HashMap-和-Hashtable-的区别" class="headerlink" title="28.HashMap 和 Hashtable 的区别"></a>28.HashMap 和 Hashtable 的区别</h3><p>1)HashMap线程不安全，HashTable线程安全，HashMap性能要好一点儿<br>2)HashMap中key和value可以为null, HashTable中key和value都不能为null</p>
<h3 id="29-HashSet-和-HashMap-区别"><a href="#29-HashSet-和-HashMap-区别" class="headerlink" title="29.HashSet 和 HashMap 区别"></a>29.HashSet 和 HashMap 区别</h3><p>1) HashSet实现了Set接口，它不允许集合中出现重复元素。当我们提到HashSet时，第一件事就是在将对象存储在 HashSet之前，要确保重写hashCode（）方法和equals（）方法，这样才能比较对象的值是否相等，确保集合中没有 储存相同的对象<br>2) HashMap实现了Map接口 Map接口对键值对进行映射。HashMap中根据key来计算hashcode, HashSet中使用成员对象来计算HashCode,对于两个对象来说hashCode值可能相同，因此如果两个对象hashcode相同的情况下会继续调用equals()方法<br>判断对象的相等性，相等返回true,否则返回false.</p>
<h3 id="30-HashMap-和-ConcurrentHashMap-的区别"><a href="#30-HashMap-和-ConcurrentHashMap-的区别" class="headerlink" title="30. HashMap 和 ConcurrentHashMap 的区别"></a>30. HashMap 和 ConcurrentHashMap 的区别</h3><p>1) ConcurrentHashMap是线程安全的 具体是怎么实现线程安全的呢，肯定不可能是每个方法加synchronized，那样就变成了HashTable。它引入了一个“分段锁”的概念，具体可以理解为把一个大的Map拆分成N个小的HashTable，根据key.hashCode()来决定把key放到哪个HashTable中</p>
<p>2）在ConcurrentHashMap中，就是把Map分成了N个Segment，put和get的时候，都是现根据key.hashCode()算出放到哪个Segment中</p>
<h3 id="31-Java中native方法使用场景？"><a href="#31-Java中native方法使用场景？" class="headerlink" title="31.Java中native方法使用场景？"></a>31.Java中native方法使用场景？</h3><p>1）在方法中调用一些不是由java语言写的代码。</p>
<p>2）在方法中用java语言直接操纵计算机硬件。</p>
<hr>
<h3 id="33-JVM运行时内存区域划分"><a href="#33-JVM运行时内存区域划分" class="headerlink" title="33.JVM运行时内存区域划分"></a>33.JVM运行时内存区域划分</h3><p><img src="http://pam1kb0ai.bkt.clouddn.com/jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="jvm内存划分"></p>
<p>1.程序计数器（线程私有）<br>程序计数器 通常占用很小的一块儿内存, 它用于存放当前线程执行的字节码的行号指示器<br>为什么需要程序计数器呢？因为java虚拟机中多线程是通过线程不断切换获得CPU执行时间进行的，为了处理器切换线程时能够回到之前所执行的位置, 每个线程都要有一个程序计数器,记录当前线程执行的字节码位置,所以是线程私有的.</p>
<p>2.java虚拟机栈(线程私有)<br>虚拟机栈描述的是Java 方法执行的内存模型：每个方法被执 行的时候都会同时创建一个栈帧（Stack Frame ①）用于存储局部变量表、操作栈、动态链接、方法出口等信息。<br>每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<ul>
<li>注意：1.局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用</li>
<li>两种异常<br>1.StackOverflowError 如果线程申请的栈深度大于虚拟机允许的栈深度时，抛出这个错误<br>2.OutOfMemoryError 当虚拟机栈扩展时 无法申请到足够的内存 就会抛出这个错误.</li>
</ul>
<p>3.本地方法栈 (Native Method Stacks) 线程私有<br>本地方法栈与虚拟机栈所发挥的作用是非常相似的,区别就是 虚拟机栈为执行的java方法服务，而本地方法栈为虚拟机使用到的Native方法(本地方法)服务</p>
<p>4.java堆（线程共享）<br>Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的 唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存<br>主要用来存放对象实例和数组，它是垃圾收集器管理的主要区域</p>
<p>5.方法区（非堆内存）Non-heap（线程共享）<br>用于存储被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据<br>根据Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError 异常</p>
<p>运行时常量池<br>运行时常量池是方法区的一部分，主要存储编译期生成的各种字面量和符号引用</p>
<h3 id="JVM如何设置参数"><a href="#JVM如何设置参数" class="headerlink" title="JVM如何设置参数"></a>JVM如何设置参数</h3><p>Linux下 在catalina.sh中设置如下参数<br>JAVA_OPTS=”-Xms128m -Xmx512m -XX:PermSize=128m -XX:MaxPermSize=256m”  </p>
<ul>
<li>Xms                jvm初始分配的堆内存大小</li>
<li>Xmx                jvm最大允许分配的堆内存，按需分配</li>
<li>XX:PermSize    jvm初始分配的非堆内存大小</li>
<li>XX:MaxPermSize jvm最大允许分配的非堆内存</li>
</ul>
<h3 id="34-常见的设计模式"><a href="#34-常见的设计模式" class="headerlink" title="34.常见的设计模式"></a>34.常见的设计模式</h3><h3 id="35-设计模式的的六大原则及其含义"><a href="#35-设计模式的的六大原则及其含义" class="headerlink" title="35.设计模式的的六大原则及其含义"></a>35.设计模式的的六大原则及其含义</h3><p>（参考: <a href="https://www.cnblogs.com/dolphin0520/p/3919839.html）" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3919839.html）</a></p>
<ol>
<li><p>单一职责原则<br> 单一职责原则告诉我们：一个类不能太“累”！在软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中  </p>
</li>
<li><p>开闭原则<br> 一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展</p>
</li>
<li><p>里氏替换原则<br> 里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象</p>
</li>
<li><p>依赖倒置原则<br> 抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程</p>
</li>
<li><p>接口隔离原则<br> 使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口</p>
</li>
<li><p>迪米特原则<br> 一个软件实体应当尽可能少地与其他实体发生相互作用<br>  如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。</p>
</li>
</ol>
<h3 id="36-常见的单例模式以及各种实现方式的优缺点，哪一种最好，手写常见的单利模式"><a href="#36-常见的单例模式以及各种实现方式的优缺点，哪一种最好，手写常见的单利模式" class="headerlink" title="36.常见的单例模式以及各种实现方式的优缺点，哪一种最好，手写常见的单利模式"></a>36.常见的单例模式以及各种实现方式的优缺点，哪一种最好，手写常见的单利模式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">   	private static final Singleton singleton = new Singleton();</span><br><span class="line">   	private Singleton()&#123;&#125;</span><br><span class="line">   	public static synchronized Singleton getInstance()&#123;</span><br><span class="line">      	 return singleton;</span><br><span class="line">   	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="37-什么是长连接和短连接"><a href="#37-什么是长连接和短连接" class="headerlink" title="37.什么是长连接和短连接"></a>37.什么是长连接和短连接</h3><ol>
<li><p>HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。 IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠地传递数据包，使得网络上接收端收到发送端所发出的所有包，并且顺序与发送顺序一致。TCP协议是可靠的、面向连接的</p>
</li>
<li><p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。</p>
</li>
<li><p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 38.三次握手和四次挥手、为什么挥手需要四次</span><br><span class="line">参考博文: https://blog.csdn.net/qzcsu/article/details/72861891</span><br><span class="line"></span><br><span class="line">![Tcp三次握手示意图](http://pam1kb0ai.bkt.clouddn.com/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png)</span><br><span class="line"></span><br><span class="line">第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</span><br><span class="line"></span><br><span class="line">第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</span><br><span class="line"></span><br><span class="line">第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</span><br><span class="line"></span><br><span class="line">完成三次握手，客户端与服务器开始传送数据，在上述过程中，还有一些重要的概念：</span><br><span class="line"></span><br><span class="line">未连接队列</span><br><span class="line"></span><br><span class="line">在三次握手协议中，服务器维护一个未连接队列，该队列为每个客户端的SYN包（syn=j）开设一个条目，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在服务器处于SYN_RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; 问题1：为什么TCP客户端最后还要发送一次确认呢？ </span><br><span class="line"></span><br><span class="line">&gt; 一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</span><br><span class="line">&gt; 如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">### TCP四次挥手</span><br><span class="line">![四次挥手](http://pam1kb0ai.bkt.clouddn.com/tcp%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png)</span><br><span class="line">&gt;数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭。</span><br><span class="line"></span><br><span class="line">对于一个已经建立的连接，TCP使用改进的三次握手来释放连接（使用一个带有FIN附加标记的报文段）。TCP关闭连接的步骤如下：</span><br><span class="line"></span><br><span class="line">第一步，当主机A的应用程序通知TCP数据已经发送完毕时，TCP向主机B发送一个带有FIN附加标记的报文段（FIN表示英文finish）。</span><br><span class="line"></span><br><span class="line">第二步，主机B收到这个FIN报文段之后，并不立即用FIN报文段回复主机A，而是先向主机A发送一个确认序号ACK，同时通知自己相应的应用程序：对方要求关闭连接（先发送ACK的目的是为了防止在这段时间内，对方重传FIN报文段）。</span><br><span class="line"></span><br><span class="line">第三步，主机B的应用程序告诉TCP：我要彻底的关闭连接，TCP向主机A送一个FIN报文段。</span><br><span class="line"></span><br><span class="line">第四步，主机A收到这个FIN报文段后，向主机B发送一个ACK表示连接彻底释放。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 为什么连接的时候是三次握手，关闭的时候却是四次握手？</span><br><span class="line"></span><br><span class="line">答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，&quot;你发的FIN报文我收到了&quot;。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">二、数据存储和消息队列</span><br><span class="line"></span><br><span class="line">### 39.MySQL 索引使用的注意事项</span><br><span class="line"> &gt; 索引只是提高效率的一个方式，如果mysql有大数据量的表，就要花时间研究建立最优的索引，或优化查询语句</span><br><span class="line"></span><br><span class="line">1. 索引不会包含有NULL的列  </span><br><span class="line">只要列中包含有NULL值，都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此符合索引就是无效的)</span><br><span class="line"></span><br><span class="line">2. 索引列排序  </span><br><span class="line">mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作，尽量不要包含多个列的排序，如果需要最好给这些列建复合索引</span><br><span class="line"></span><br><span class="line">3. like语句操作  </span><br><span class="line">一般情况下不鼓励使用like操作，如果非使用不可，注意正确的使用方式。like ‘%aaa%’不会使用索引，而like ‘aaa%’可以使用索引。</span><br><span class="line"></span><br><span class="line">4. 不要在列上进行运算</span><br><span class="line"></span><br><span class="line">5. 不使用NOT IN 、&lt;&gt;、！=操作，但&lt;,&lt;=，=，&gt;,&gt;=,BETWEEN,IN是可以用到索引的</span><br><span class="line"></span><br><span class="line">6. 索引要建立在经常进行select操作的字段上</span><br><span class="line"></span><br><span class="line">7. 索引要建立在值比较唯一的字段上</span><br><span class="line"></span><br><span class="line">8. 对于那些定义为text、image和bit数据类型的列不应该增加索引。因为这些列的数据量要么相当大，要么取值很少 </span><br><span class="line"></span><br><span class="line">9. 在where和join中出现的列需要建立索引</span><br><span class="line"></span><br><span class="line">10. where的查询条件里有不等号(where column != …),mysql将无法使用索引</span><br><span class="line"></span><br><span class="line">11. 如果where查询条件里使用了函数(如：where DAY(column)=…),mysql将无法使用索引 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 40.索引类型 及如何创建索引，删除搜索引  </span><br><span class="line"></span><br><span class="line">索引类型:</span><br><span class="line"></span><br><span class="line">	* UNIQUE(唯一索引) 不可出现相同的值,可以有null值</span><br><span class="line">	* INDEX(普通索引) 可以出现相同的值</span><br><span class="line">	* PROMARY KEY(主键索引) 不允许出现相同的值</span><br><span class="line">	* fulltext index(全文索引) 可以针对值中的某个单词，但效率不高</span><br><span class="line">	* 组合索引: 实质上是是将多个字段建到一个索引里，列值的组合必须唯一</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">创建索引:</span><br></pre></td></tr></table></figure>
<ol>
<li><p>创建表时同时创建索引</p>
<p> CREATE INDEX index_name ON table_name(username(length));<br>2.创建表后创建索<br> //唯一索引<br> alter table table_name add unique (column_list);</p>
<p> //主键索引<br> alter table table_name add primary key (column_list);        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">删除索引:</span><br></pre></td></tr></table></figure>
<p> drop index index_name on table_name;<br> alter table table_name drop index index_name;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 40.DDL、DML、DCL分别指什么?</span><br><span class="line">* DDL:数据定义语言 DDL用来创建数据库中的各种对象-----表、视图  </span><br><span class="line">* DML:数据操纵语言 用于insert,update,delete</span><br><span class="line">* DCL:数据库控制语言 用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 41.数据库的几大范式</span><br><span class="line">  第一范式: 每一列属性都是不可再分的属性值，确保每一列的原子性  </span><br><span class="line">   </span><br><span class="line">  第二范式: 每一行的数据只能与其中一列相关，即一行数据只做一件事。只要数据列中出现数据重复，就要把表拆分开来</span><br><span class="line">  </span><br><span class="line">  第三范式: 数据不能存在传递关系，即每个属性都跟主键有直接关系而不是间接关系。像：a--&gt;b--&gt;c  属性之间含有这样的关系，是不符合第三范式的。</span><br><span class="line"> </span><br><span class="line">  总结：三大范式只是一般设计数据库的基本理念，可以建立冗余较小、结构合理的数据库。如果有特殊情况，当然要特殊对待，数据库设计最重要的是看需求跟性能，需求&gt;性能&gt;表结构。所以不能一味的去追求范式建立数据库   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 42.说说分库与分表设计</span><br><span class="line">&gt;分库分表基本思想:Sharding的基本思想就要把一个数据库切分成多个部分放到不同的数据库(server)上，从而缓解单一数据库的性能问题。</span><br><span class="line">不太严格的讲，对于海量数据的数据库，如果是因为表多而数据多，这时候适合使用垂直切分，即把关系紧密（比如同一模块）的表</span><br><span class="line">切分出来放在一个server上。如果表并不多，但每张表的数据非常多，这时候适合水平切分，</span><br><span class="line">即把表的数据按某种规则（比如按ID散列）切分到多个数据库(server)上。当然，现实中更多是这两种情况混杂在一起，</span><br><span class="line">这时候需要根据实际情况做出选择，也可能会综合使用垂直与水平切分，</span><br><span class="line">从而将原有数据库切分成类似矩阵一样可以无限扩充的数据库(server)阵列。</span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">### 43.说说 SQL 优化之道</span><br><span class="line">1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。	</span><br><span class="line">	</span><br><span class="line">2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</span><br><span class="line">    `select id from t where num is null	` </span><br><span class="line">  可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： 	</span><br><span class="line">    `select id from t where num=0	`</span><br><span class="line">	</span><br><span class="line">3.应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。	</span><br><span class="line">	</span><br><span class="line">4.应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：	</span><br><span class="line">    ```select id from t where num=10 or num=20```	</span><br><span class="line">可以这样查询：	</span><br><span class="line">    ```select id from t where num=10```	</span><br><span class="line">union all	</span><br><span class="line">    ```select id from t where num=20```	</span><br><span class="line">	</span><br><span class="line">5.in 和 not in 也要慎用，否则会导致全表扫描，如：	</span><br><span class="line">    ```select id from t where num in(1,2,3)```	</span><br><span class="line">对于连续的数值，能用 between 就不要用 in 了：	</span><br><span class="line">    ```select id from t where num between 1 and 3```	</span><br><span class="line">	</span><br><span class="line">6.下面的查询也将导致全表扫描：	</span><br><span class="line">    ```select id from t where name like &apos;%abc%&apos;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<p>7.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：<br>    <figure class="highlight plain"><figcaption><span>id from t where num/2</span></figcaption><table><tr><td class="code"><pre><span class="line">应改为:	</span><br><span class="line">    ```select id from t where num=100*2</span><br></pre></td></tr></table></figure></p>
<p>8.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：<br>    <code>select id from t where substring(name,1,3)=&#39;abc&#39;</code> –name以abc开头的id<br>应改为:<br>    <code>select id from t where name like &#39;abc%&#39;</code>    </p>
<p>9.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。    </p>
<p>10.在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，<br>否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。    </p>
<p>11.不要写一些没有意义的查询，如需要生成一个空表结构：<br>    <code>select col1,col2 into #t from t where 1=0</code><br>这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：<br>    <code>create table #t(...)</code></p>
<p>12.很多时候用 exists 代替 in 是一个好的选择：<br>    <code>select num from a where num in(select num from b)</code><br>用下面的语句替换：<br>    <code>select num from a where exists(select 1 from b where num=a.num)</code>    </p>
<p>13.并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，<br>如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。    </p>
<p>14.索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，<br>因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。<br>一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。    </p>
<p>15.尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。<br>这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。    </p>
<p>16.尽可能的使用 varchar 代替 char ，因为首先变长字段存储空间小，可以节省存储空间，<br>其次对于查询来说，在一个相对较小的字段内搜索，在一个相对较小的字段内搜索效率显效率显然要高些。    </p>
<p>17.任何地方都不要使用 select <em> from t ，用具体的字段列表代替“</em>”，不要返回用不到的任何字段。    </p>
<p>18.避免频繁创建和删除临时表，以减少系统表资源的消耗。</p>
<p>19.临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。    </p>
<p>20.在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，<br>以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</p>
<p>21.如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。    </p>
<p>22.尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。    </p>
<p>23.使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</p>
<p>24.与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。<br>在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。</p>
<p>25.尽量避免大事务操作，提高系统并发能力。</p>
<p>26.尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</p>
<h3 id="44-MySQL遇到的死锁问题、如何排查与解决"><a href="#44-MySQL遇到的死锁问题、如何排查与解决" class="headerlink" title="44.MySQL遇到的死锁问题、如何排查与解决"></a>44.MySQL遇到的死锁问题、如何排查与解决</h3><p>在数据库中有两种基本的锁类型：排它锁（Exclusive Locks，即X锁）和共享锁（Share Locks，即S锁）。当数据对象被加上排它锁时，其他的事务不能对它读取和修改。<br>加了共享锁的数据对象可以被其他事务读取，但不能修改。数据库利用这两 种基本的锁类型来对数据库的事务进行并发控制。<br>死锁的第一种情况</p>
<p>一个用户A 访问表A(锁住了表A),然后又访问表B；另一个用户B 访问表B(锁住了表B)，然后企图访问表A；这时用户A由于用户B已经锁住表B，它必须等待用户B释放表B才能继续，同样用户B要等用户A释放表A才能继续，这就死锁就产生了。</p>
<p>解决方法：</p>
<p>这种死锁比较常见，是由于程序的BUG产生的，除了调整的程序的逻辑没有其它的办法。仔细分析程序的逻辑，对于数据库的多表操作时，尽量按照相同的顺序进 行处理，尽量避免同时锁定两个资源，如操作A和B两张表时，总是按先A后B的顺序处理， 必须同时锁定两个资源时，要保证在任何时刻都应该按照相同的顺序来锁定资源。</p>
<p>死锁的第二种情况</p>
<p>用户A查询一条纪录，然后修改该条纪录；这时用户B修改该条纪录，这时用户A的事务里锁的性质由查询的共享锁企图上升到独占锁，而用户B里的独占锁由于A 有共享锁存在所以必须等A释放掉共享锁，而A由于B的独占锁而无法上升的独占锁也就不可能释放共享锁，于是出现了死锁。这种死锁比较隐蔽，但在稍大点的项 目中经常发生。如在某项目中，页面上的按钮点击后，没有使按钮立刻失效，使得用户会多次快速点击同一按钮，这样同一段代码对数据库同一条记录进行多次操 作，很容易就出现这种死锁的情况。</p>
<p>解决方法：</p>
<p>1、对于按钮等控件，点击后使其立刻失效，不让用户重复点击，避免对同时对同一条记录操作。<br>2、使用乐观锁进行控制。乐观锁大多是基于数据版本（Version）记录机制实现。即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是 通过为数据库表增加一个“version”字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数 据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。乐观锁机制避免了长事务中的数据 库加锁开销（用户A和用户B操作过程中，都没有对数据库数据加锁），大大提升了大并发量下的系统整体性能表现。Hibernate 在其数据访问引擎中内置了乐观锁实现。需要注意的是，由于乐观锁机制是在我们的系统中实现，来自外部系统的用户更新操作不受我们系统的控制，因此可能会造 成脏数据被更新到数据库中。<br>3、使用悲观锁进行控制。悲观锁大多数情况下依靠数据库的锁机制实现，如Oracle的Select … for update语句，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。如一个金融系统， 当某个操作员读取用户的数据，并在读出的用户数据的基础上进行修改时（如更改用户账户余额），如果采用悲观锁机制，也就意味着整个操作过程中（从操作员读 出数据、开始修改直至提交修改结果的全过程，甚至还包括操作员中途去煮咖啡的时间），数据库记录始终处于加锁状态，可以想见，如果面对成百上千个并发，这 样的情况将导致灾难性的后果。所以，采用悲观锁进行控制时一定要考虑清楚。</p>
<p>死锁的第三种情况</p>
<p>如果在事务中执行了一条不满足条件的update语句，则执行全表扫描，把行级锁上升为表级锁，多个这样的事务执行后，就很容易产生死锁和阻塞。类似的情 况还有当表中的数据量非常庞大而索引建的过少或不合适的时候，使得经常发生全表扫描，最终应用系统会越来越慢，最终发生阻塞或死锁。</p>
<p>解决方法：<br>SQL语句中不要使用太复杂的关联多表的查询；使用“执行计划”对SQL语句进行分析，对于有全表扫描的SQL语句，建立相应的索引进行优化。</p>
<p>5．小结<br>总体上来说，产生内存溢出与锁表都是由于代码写的不好造成的，因此提高代码的质量是最根本的解决办法。有的人认为先把功能实现，<br>有BUG时再在测试阶段进 行修正，这种想法是错误的。正如一件产品的质量是在生产制造的过程中决定的，而不是质量检测时决定的，<br>软件的质量在设计与编码阶段就已经决定了，测试只是 对软件质量的一个验证，因为测试不可能找出软件中所有的BUG。</p>
<h3 id="45-存储引擎的-InnoDB与MyISAM区别，优缺点，使用场景"><a href="#45-存储引擎的-InnoDB与MyISAM区别，优缺点，使用场景" class="headerlink" title="45.存储引擎的 InnoDB与MyISAM区别，优缺点，使用场景"></a>45.存储引擎的 InnoDB与MyISAM区别，优缺点，使用场景</h3><p>主要区别:</p>
<pre><code>* 1.MyISAM是非事务安全型的，而InnoDB是事务安全型的。
* 2.MyISAM是表级锁，而InnoDB是行级锁
* 3.MyISAM支持全文类型索引，而InnoDB不支持全文索引
</code></pre><p>MyISAM适合：(1)做很多count 的计算；(2)插入不频繁，查询非常频繁；(3)没有事务。<br>InnoDB适合：(1)可靠性要求比较高，或者要求事务；(2)表更新和查询都相当的频繁，并且行锁定的机会比较大的情况</p>
<h3 id="46-limit-20000-加载很慢怎么解决"><a href="#46-limit-20000-加载很慢怎么解决" class="headerlink" title="46.limit 20000 加载很慢怎么解决"></a>46.limit 20000 加载很慢怎么解决</h3><pre><code>`select * from table limit m,n`
</code></pre><p>其中m是指记录开始的index，表示每次开始的索引。默认从0开始，表示第一条记录<br>n是指从第m+1条开始，取n条。 如：<br><code>select * from tablename limit 2,4</code>即取出第3条至第6条，4条记录</p>
<p>解决方法:<br>当一个数据库表过于庞大，LIMIT offset, length中的offset值过大，则SQL查询语句会非常缓慢，<br>你需增加order by，并且order by字段需要建立索引</p>
<h3 id="47-常见的几种分布式ID的设计方案"><a href="#47-常见的几种分布式ID的设计方案" class="headerlink" title="47.常见的几种分布式ID的设计方案"></a>47.常见的几种分布式ID的设计方案</h3><p>生成ID的方法有很多，适应不同的场景、需求以及性能要求。所以有些比较复杂的系统会有多个ID生成的策略。下面就介绍一些常见的ID生成策略</p>
<h3 id="48-如何选择合适的分布式主键方案"><a href="#48-如何选择合适的分布式主键方案" class="headerlink" title="48.如何选择合适的分布式主键方案"></a>48.如何选择合适的分布式主键方案</h3><ol>
<li>数据库自增ID<br>数据库自增长序列或字段，最常见的方式。由数据库维护，数据库唯一。</li>
</ol>
<p>优点：<br>简单，代码方便，性能可以接受。<br>数字ID天然排序，对分页或者需要排序的结果很有帮助。<br>缺点：<br>不同数据库语法和实现不同，数据库迁移的时候或多数据库版本支持的时候需要处理。<br>在单个数据库或读写分离或一主多从的情况下，只有一个主库可以生成。有单点故障的风险。<br>在性能达不到要求的情况下，比较难于扩展。<br>如果遇见多个系统需要合并或者涉及到数据迁移会相当痛苦。<br>分表分库的时候会有麻烦。<br>优化方案：<br>针对主库单点，如果有多个Master库，则每个Master库设置的起始数字不一样，步长一样，可以是Master的个数。<br>比如：Master1 生成的是 1，4，7，10，Master2生成的是2,5,8,11 Master3生成的是 3,6,9,12。这样就可以有效生成集群中的唯一ID，也可以大大降低ID生成数据库操作的负载。</p>
<ol start="2">
<li>UUID<br>常见的方式,128位。可以利用数据库也可以利用程序生成，一般来说全球唯一。</li>
</ol>
<p>优点：<br>简单，代码方便。<br>全球唯一，在遇见数据迁移，系统数据合并，或者数据库变更等情况下，可以从容应对。<br>缺点：<br>没有排序，无法保证趋势递增。<br>UUID往往是使用字符串存储，查询的效率比较低。<br>存储空间比较大，如果是海量数据库，就需要考虑存储量的问题。<br>传输数据量大 不可读。</p>
<p>优化方案：<br><em>为了解决UUID不可读，可以使用UUID to Int64的方法</em></p>
<ol start="3">
<li>GUID<br>GUID：是微软对UUID这个标准的实现。UUID还有其它各种实现，不止GUID一种。优缺点同UUID。</li>
</ol>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="49-Redis-有哪些数据类型，可参考《Redis常见的5种不同的数据类型详解》"><a href="#49-Redis-有哪些数据类型，可参考《Redis常见的5种不同的数据类型详解》" class="headerlink" title="49.Redis 有哪些数据类型，可参考《Redis常见的5种不同的数据类型详解》"></a>49.Redis 有哪些数据类型，可参考《Redis常见的5种不同的数据类型详解》</h3><h3 id="50-Redis-内部结构"><a href="#50-Redis-内部结构" class="headerlink" title="50.Redis 内部结构"></a>50.Redis 内部结构</h3><h3 id="51-Redis-使用场景"><a href="#51-Redis-使用场景" class="headerlink" title="51.Redis 使用场景"></a>51.Redis 使用场景</h3><h3 id="52-Redis-集群方案与实现"><a href="#52-Redis-集群方案与实现" class="headerlink" title="52.Redis 集群方案与实现"></a>52.Redis 集群方案与实现</h3><h3 id="53-Redis-为什么是单线程的？"><a href="#53-Redis-为什么是单线程的？" class="headerlink" title="53.Redis 为什么是单线程的？"></a>53.Redis 为什么是单线程的？</h3><h3 id="54-缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级"><a href="#54-缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级" class="headerlink" title="54.缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级"></a>54.缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级</h3><h3 id="55-使用缓存的合理性问题"><a href="#55-使用缓存的合理性问题" class="headerlink" title="55.使用缓存的合理性问题"></a>55.使用缓存的合理性问题</h3><h3 id="56-Redis常见的回收策略"><a href="#56-Redis常见的回收策略" class="headerlink" title="56.Redis常见的回收策略"></a>56.Redis常见的回收策略</h3><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><h3 id="56-消息队列的使用场景"><a href="#56-消息队列的使用场景" class="headerlink" title="56.消息队列的使用场景"></a>56.消息队列的使用场景</h3><h3 id="57-消息的重发补偿解决思路"><a href="#57-消息的重发补偿解决思路" class="headerlink" title="57.消息的重发补偿解决思路"></a>57.消息的重发补偿解决思路</h3><h3 id="58-消息的幂等性解决思路"><a href="#58-消息的幂等性解决思路" class="headerlink" title="58.消息的幂等性解决思路"></a>58.消息的幂等性解决思路</h3><h3 id="59-消息的堆积解决思路"><a href="#59-消息的堆积解决思路" class="headerlink" title="59.消息的堆积解决思路"></a>59.消息的堆积解决思路</h3><h3 id="60-自己如何实现消息队列"><a href="#60-自己如何实现消息队列" class="headerlink" title="60.自己如何实现消息队列"></a>60.自己如何实现消息队列</h3><h3 id="61-如何保证消息的有序性"><a href="#61-如何保证消息的有序性" class="headerlink" title="61.如何保证消息的有序性"></a>61.如何保证消息的有序性</h3><h2 id="SSM-Servlet"><a href="#SSM-Servlet" class="headerlink" title="SSM/Servlet"></a>SSM/Servlet</h2><h3 id="62-Servlet的生命周期"><a href="#62-Servlet的生命周期" class="headerlink" title="62.Servlet的生命周期"></a>62.Servlet的生命周期</h3><p>在Servlet产生到消亡的过程中，有三个生命周期函数，初始化方法init(),<br>处理客户请求的方法service(),终止方法destroy()</p>
<ul>
<li><p>init()<br>  在一个Servlet的生命周期中，init方法只会被执行一次，之后无论用户执行多少次请求，都不会在调用该方法。 </p>
<pre><code>关于init方法的执行时机，有两种方式可选，一般的是在服务器启动后第一个用户请求改Servlet是调用，你也可以设置该Servlet在服务器启动后自动执行。 
</code></pre><p>init方法负责简单的创建或者加载一些数据，这些数据将用于该Servlet的整个生命周期中</p>
</li>
<li><p>service方法</p>
<pre><code>当一个客户请求改Servlet时，实际的处理工作全部有service方法来完成，service方法用来处理客户端的请求，并生成格式化数据返回给客户端。 
每一次请求服务器都会开启一个新的线程并执行一次service方法，service根据客户端的请求类型，调用doGet、doPost等方法。 
service是由web容器来调用的，我们无需对service具体内容做任何处理，service会自动的根据客户端的请求类型去调用doGet、doPost等方法，所以我们只需要做好doGet、doPost方法的实现就可以了。
</code></pre></li>
<li><p>destroy方法</p>
<pre><code>该方法在整个生命周期中，也是只会被调用一次，在Servlet对象被销毁是调用，在servlet中，我们可以做一些资源的释放等操作，执行destory方法之后的servlet对象，会等待jvm虚拟机的垃圾回收机制择时回收。
</code></pre></li>
</ul>
<h3 id="63-转发与重定向的区别"><a href="#63-转发与重定向的区别" class="headerlink" title="63.转发与重定向的区别"></a>63.转发与重定向的区别</h3><p>在servlet中转发的语句为：<br>    <code>request.getRequestDispatcher(&quot;xxx.jsp&quot;).forward(request,response);</code></p>
<p>在servlet中重定向的语句为：<br>    <code>request.sendRedirect(&quot;xxx.jsp&quot;);</code></p>
<p>转发的过程：<br>客户端浏览器发送请求，web服务器接收请求再进行在内部跳转，什么意思呢，也就是说，跳转只能在自己所在的web容器下的url，而不能跳转出去其他的url。</p>
<p>重定向的过程：<br>客户端发送请求，web服务器接收该请求后发送302状态码响应并且发送新的一个地址（location）给客户端浏览器，客户端接收到302则自动再发送一个新的请求，而这个请求就是新的location，既然是客户端发送的一个请求，就对web容器的request没关系了，它可以任意跳转到所有location。\<br>其实它们最本质的区别就是，转发只需要一次的请求，仅仅是一次客户端的request，而重定向则需要两次请求，一次是客户端request，服务器响应后返回302给客户端浏览器，再由客户端浏览器再发一次请求。</p>
<h3 id="64-BeanFactory-和-ApplicationContext-有什么区别"><a href="#64-BeanFactory-和-ApplicationContext-有什么区别" class="headerlink" title="64.BeanFactory 和 ApplicationContext 有什么区别"></a>64.BeanFactory 和 ApplicationContext 有什么区别</h3><p>BeanFactory：<br>是spring中比较原始的Factory,是Spring里面最低层的接口，提供了最简单的容器的功能，<br>只提供了实例化对象和拿对象的功能；原始的BeanFactory无法支持spring的许多插件，<br>如AOP功能、Web应用等</p>
<p>ApplicationContext：<br>应用上下文，继承BeanFactory接口，它是Spring的一各更高级的容器，提供了更多的有用的功能；<br><code>ApplicationContext ctx = new 
    ClassPathXmlAppliationContext(&quot;applicationContext.xml&quot;);</code><br>1) 国际化（MessageSource）</p>
<p>2) 访问资源，如URL和文件（ResourceLoader）</p>
<p>3) 载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层  </p>
<p>4) 消息发送、响应机制（ApplicationEventPublisher）</p>
<p>5) AOP（拦截器）</p>
<p>两者区别:<br>BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，<br>才对该Bean进行加载实例化，这样，我们就不能发现一些存在的Spring的配置问题。<br>而ApplicationContext则相反，它是在容器启动时，一次性创建了所有的Bean。<br>这样，在容器启动时，我们就可以发现Spring中存在的配置错误。 </p>
<h3 id="65-Spring-Bean-的生命周期"><a href="#65-Spring-Bean-的生命周期" class="headerlink" title="65.Spring Bean 的生命周期"></a>65.Spring Bean 的生命周期</h3><h3 id="66-Spring-IOC-如何实现"><a href="#66-Spring-IOC-如何实现" class="headerlink" title="66.Spring IOC 如何实现"></a>66.Spring IOC 如何实现</h3><h3 id="Spring中Bean的作用域，默认的是哪一个"><a href="#Spring中Bean的作用域，默认的是哪一个" class="headerlink" title="Spring中Bean的作用域，默认的是哪一个"></a>Spring中Bean的作用域，默认的是哪一个</h3><p>说说 Spring AOP、Spring AOP 实现原理</p>
<p>动态代理（CGLib 与 JDK）、优缺点、性能对比、如何选择</p>
<p>Spring 事务实现方式、事务的传播机制、默认的事务类别</p>
<p>Spring 事务底层原理</p>
<p>Spring事务失效（事务嵌套），JDK动态代理给Spring事务埋下的坑，可参考《JDK动态代理给Spring事务埋下的坑！》</p>
<p>如何自定义注解实现功能</p>
<p>Spring MVC 运行流程</p>
<p>Spring MVC 启动流程</p>
<p>Spring 的单例实现原理</p>
<p>Spring 框架中用到了哪些设计模式</p>
<p>Spring 其他产品（Srping Boot、Spring Cloud、Spring Secuirity、Spring Data、Spring AMQP 等）</p>
<p>有没有用到Spring Boot，Spring Boot的认识、原理</p>
<p>MyBatis的原理</p>
<p>可参考《为什么会有Spring》</p>
<p>可参考《为什么会有Spring AOP》</p>
<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><p>Session 分布式方案</p>
<p>Session 分布式处理</p>
<p>分布式锁的应用场景、分布式锁的产生原因、基本概念</p>
<p>分布是锁的常见解决方案</p>
<p>分布式事务的常见解决方案</p>
<p>集群与负载均衡的算法与实现</p>
<p>说说分库与分表设计，可参考《数据库分库分表策略的具体实现方案》</p>
<p>分库与分表带来的分布式困境与应对之策</p>
<p>4.3、Dubbo</p>
<p>什么是Dubbo，可参考《Dubbo入门》</p>
<p>什么是RPC、如何实现RPC、RPC 的实现原理，可参考《基于HTTP的RPC实现》</p>
<p>Dubbo中的SPI是什么概念</p>
<p>Dubbo的基本原理、执行流程</p>
<p>五、微服务</p>
<p>5.1、微服务</p>
<p>前后端分离是如何做的？</p>
<p>微服务哪些框架</p>
<p>Spring Could的常见组件有哪些？可参考《Spring Cloud概述》</p>
<p>领域驱动有了解吗？什么是领域驱动模型？充血模型、贫血模型</p>
<h3 id="JWT有了解吗，什么是JWT，可参考《前后端分离利器之JWT》"><a href="#JWT有了解吗，什么是JWT，可参考《前后端分离利器之JWT》" class="headerlink" title="JWT有了解吗，什么是JWT，可参考《前后端分离利器之JWT》"></a>JWT有了解吗，什么是JWT，可参考《前后端分离利器之JWT》</h3><p><a href="https://blog.csdn.net/bntx2jsqfehy7/article/details/79224042" target="_blank" rel="noopener">https://blog.csdn.net/bntx2jsqfehy7/article/details/79224042</a></p>
<p>你怎么理解 RESTful</p>
<p>说说如何设计一个良好的 API</p>
<p>如何理解 RESTful API 的幂等性</p>
<p>如何保证接口的幂等性</p>
<p>微服务的优缺点，可参考《微服务批判》</p>
<p>微服务与 SOA 的区别</p>
<p>如何拆分服务、水平分割、垂直分割</p>
<p>如何应对微服务的链式调用异常</p>
<p>如何快速追踪与定位问题</p>
<p>如何保证微服务的安全、认证</p>
<p>5.2、安全问题<br>如何防范常见的Web攻击、如何方式SQL注入</p>
<p>服务端通信安全攻防</p>
<p>HTTPS原理剖析、降级攻击、HTTP与HTTPS的对比</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>java面试系列问题(2)</title>
    <url>/2019/08/07/%E9%9D%A2%E8%AF%952/</url>
    <content><![CDATA[<p>一、Java相关</p>
<p>Arraylist与LinkedList默认空间是多少；</p>
<p>Arraylist与LinkedList区别与各自的优势List 和 Map 区别；</p>
<p>谈谈HashMap，哈希表解决hash冲突的方法；</p>
<p>为什么要重写hashcode()和equals()以及他们之间的区别与关系；</p>
<p>Object的hashcode()是怎么计算的？</p>
<p>若hashcode方法永远返回1或者一个常量会产生什么结果？</p>
<p>Java Collections和Arrays的sort方法默认的排序方法是什么；</p>
<p>引用计数法与GC Root可达性分析法区别；</p>
<p>浅拷贝和深拷贝的区别；</p>
<p>String s=”abc”和String s=new String(“abc”)区别；</p>
<p>HashSet方法里面的hashcode存在哪，如果重写equals不重写hashcode会怎么样？</p>
<p>反射的作用与实现原理；</p>
<p>Java中的回调机制；</p>
<p>模板方法模式；</p>
<p>开闭原则说一下；</p>
<p>发布/订阅使用场景；</p>
<p>KMP算法（一种改进的字符串匹配算法）；</p>
<p>JMM里边的原子性、可见性、有序性是如何体现出来的，JMM中内存屏障是什么意思，</p>
<p>二、多线程</p>
<p>AtomicInteger底层实现原理；</p>
<p>synchronized与ReentraLock哪个是公平锁；</p>
<p>CAS机制会出现什么问题；</p>
<p>用过并发包下边的哪些类；</p>
<p>一个线程连着调用start两次会出现什么情况？</p>
<p>wait方法能不能被重写，wait能不能被中断；</p>
<p>线程池的实现？四种线程池？重要参数及原理？任务拒接策略有哪几种？</p>
<p>线程状态以及API怎么操作会发生这种转换；</p>
<p>常用的避免死锁方法；</p>
<p>三、JVM</p>
<p>Minor GC与Full GC分别在什么时候发生？什么时候触发Full GC;</p>
<p>GC收集器有哪些？CMS收集器与G1收集器的特点。</p>
<p>Java在什么时候会出现内存泄漏；</p>
<p>Java中的大对象如何进行存储；</p>
<p>rt.jar被什么类加载器加载，什么时间加载；</p>
<p>自己写的类被什么加载，什么时间加载；</p>
<p>自己写的两个不同的类是被同一个类加载器加载的吗？为什么？</p>
<p>为什么新生代内存需要有两个Survivor区？</p>
<p>几种常用的内存调试工具：jmap、jstack、jconsole；</p>
<p>类加载的五个过程：加载、验证、准备、解析、初始化；</p>
<p>G1停顿吗，CMS回收步骤，CMS为什么会停顿，停顿时间；</p>
<p>栈主要存的数据是什么，堆呢？</p>
<p>堆分为哪几块，比如说新生代老生代，那么新生代又分为什么？</p>
<p>软引用和弱引用的使用场景（软引用可以实现缓存，弱引用可以用来在回调函数中防止内存泄露）；</p>
<p>四、数据库</p>
<p>数据库索引，什么是全文索引，全文索引中的倒排索引是什么原理；</p>
<p>数据库最佳左前缀原则是什么？</p>
<p>数据库的三大范式；</p>
<p>悲观锁和乐观锁的原理和应用场景；</p>
<p>左连接、右连接、内连接、外连接、交叉连接、笛卡儿积等；</p>
<p>一般情况下数据库宕机了如何进行恢复（什么是Write Ahead Log机制，什么是Double Write机制，什么是Check Point）；</p>
<p>什么是redo日志、什么是undo日志；</p>
<p>数据库中的隔离性是怎样实现的；原子性、一致性、持久性又是如何实现的；</p>
<p>什么是组合索引，组合索引什么时候会失效；</p>
<p>关系型数据库和非关系型数据库区别；</p>
<p>数据库死锁如何解决；</p>
<p>MySQL并发情况下怎么解决（通过事务、隔离级别、锁）；</p>
<p>MySQL中的MVCC机制是什么意思，根据具体场景，MVCC是否有问题；</p>
<p>MySQL数据库的隔离级别，以及如何解决幻读；</p>
<p>五、缓存服务器</p>
<p>Redis中zSet跳跃表问题；</p>
<p>Redis的set的应用场合？</p>
<p>Redis高级特性了解吗？</p>
<p>Redis的pipeline有什么用处？</p>
<p>Redis集群宕机如何处理，怎么样进行数据的迁移；</p>
<p>Redis的集群方案；</p>
<p>Redis原子操作怎么用比较好；</p>
<p>Redis过期策略是怎么实现的呢？</p>
<p>六、SSM相关</p>
<p>Spring中@Autowired和@Resource注解的区别？</p>
<p>Spring声明一个 bean 如何对其进行个性化定制；</p>
<p>MyBatis有什么优势；</p>
<p>MyBatis如何做事务管理；</p>
<p>七、操作系统</p>
<p>Linux静态链接和动态链接；</p>
<p>什么是IO多路复用模型（select、poll、epoll）；</p>
<p>Linux中的grep管道用处？Linux的常用命令？</p>
<p>操作系统中虚拟地址、逻辑地址、线性地址、物理地址的概念及区别；</p>
<p>内存的页面置换算法；</p>
<p>内存的页面置换算法；</p>
<p>进程调度算法，操作系统是如何调度进程的；</p>
<p>父子进程、孤儿进程、僵死进程等概念；</p>
<p>fork进程时的操作；</p>
<p>kill用法，某个进程杀不掉的原因（僵死进程；进入内核态，忽略kill信号）；</p>
<p>系统管理命令（如查看内存使用、网络情况）；</p>
<p>find命令、awk使用；</p>
<p>Linux下排查某个死循环的线程；</p>
<p>八、网络相关</p>
<p>数据链路层是做什么的?</p>
<p>数据链路层的流量控制？</p>
<p>网络模型的分层、IP和Mac地址在那个层、TCP和HTTP分别在那个层；</p>
<p>TCP滑动窗口；</p>
<p>TCP为什么可靠；</p>
<p>TCP的同传，拆包与组装包是什么意思；</p>
<p>Https和Http有什么区别；</p>
<p>Http 为什么是无状态的；</p>
<p>TCP三次握手，为什么不是三次，为什么不是四次；</p>
<p>TCP的拥塞控制、流量控制详细说明？</p>
<p>Http1.0和Http2.0的区别；</p>
<p>两个不同ip地址的计算机之间如何通信；</p>
<p>地址解析协议ARP；</p>
<p>OSI七层模型分别对应着五层模型的哪一部分；</p>
<p>TCP三次握手数据丢失了怎么办？那如果后面又找到了呢？</p>
<p>九、分布式相关</p>
<p>消息队列使用的场景介绍和作用（应用耦合、异步消息、流量削锋等）；</p>
<p>如何解决消息队列丢失消息和重复消费问题；</p>
<p>Kafka使用过吗，什么是幂等性？怎么保证一致性，持久化怎么做，分区partition的理解，LEO是什么意思，如何保证多个partition之间数据一致性的（ISR机制），为什么Kafka可以这么快（基于磁盘的顺序读写）；</p>
<p>异步队列怎么实现；</p>
<p>你项目的并发是多少？怎么解决高并发问题？单机情况下Tomcat的并发大概是多少，MySQL的并发大致是多少？</p>
<p>什么是C10K问题；</p>
<p>高并发情况下怎么办；</p>
<p>分布式理论，什么是CAP理论，什么是Base理论，什么是Paxos理论；</p>
<p>分布式协议的选举算法；</p>
<p>说一下你对微服务的理解，与SOA的区别；</p>
<p>Dubbo的基本原理，RPC，支持哪些通信方式，服务的调用过程；</p>
<p>Dubbo如果有一个服务挂掉了怎么办；</p>
<p>分布式事务，操作两个表不在一个库，如何保证一致性。</p>
<p>分布式系统中，每台机器如何产生一个唯一的随机值；</p>
<p>系统的量级、pv、uv等；</p>
<p>什么是Hash一致性算法？分布式缓存的一致性，服务器如何扩容（哈希环）；</p>
<p>正向代理、反向代理；</p>
<p>什么是客户端负载均衡策略、什么是服务器端负载均衡策略；</p>
<p>如何优化Tomcat，常见的优化方式有哪些；</p>
<p>Nginx的Master和Worker，Nginx是如何处理请求的；</p>
<p>十、系统设计相关</p>
<p>如何防止表单重复提交（Token令牌环等方式）；</p>
<p>有一个url白名单，需要使用正则表达式进行过滤，但是url量级很大，大概亿级，那么如何优化正则表达式？如何优化亿级的url匹配呢？</p>
<p>常见的Nginx负载均衡策略；已有两台Nginx服务器了，倘若这时候再增加一台服务器，采用什么负载均衡算法比较好？</p>
<p>扫描二维码登录的过程解析；</p>
<p>如何设计一个生成唯一UUID的算法？</p>
<p>实现一个负载均衡的算法，服务器资源分配为70%、20%、10%；</p>
<p>有三个线程T1 T2 T3，如何保证他们按顺序执行；</p>
<p>三个线程循环输出ABCABCABC….</p>
<p>十一、安全相关</p>
<p>什么是XSS攻击，XSS攻击的一般表现形式有哪些？如何防止XSS攻击；</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云常用文档</title>
    <url>/2019/08/07/%E9%98%BF%E9%87%8C%E4%BA%91%E5%B8%B8%E7%94%A8%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<p><img src="$appres/images/night.jpg" alt="Nulla euismod, vitae aliquet orci eleifend."></p>
<h1 id="阿里云常用文档"><a href="#阿里云常用文档" class="headerlink" title="阿里云常用文档"></a>阿里云常用文档</h1><h4 id="升级云盘后扩展分区"><a href="#升级云盘后扩展分区" class="headerlink" title="升级云盘后扩展分区"></a>升级云盘后扩展分区</h4><p>阿里云升级云盘后,升级云盘后，默认是没有挂载的,需要进行一些配置才能够生效,针对windows和linux有不同的操作方式<br>文档地址(<a href="https://help.aliyun.com/document_detail/111738.html?spm=a2c4g.11186623.6.768.64ba216c45ccBV" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/111738.html?spm=a2c4g.11186623.6.768.64ba216c45ccBV</a>)</p>
]]></content>
      <categories>
        <category>阿里云</category>
      </categories>
      <tags>
        <tag>阿里云文档</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么要使用spring?</title>
    <url>/2019/08/07/%E7%AC%AC%E4%B8%80%E7%AB%A0spring%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<blockquote>
<p>spring是一个开源的应用框架,目的是帮我们简化企业级应用程序的开发,spring帮助我们创建对象，管理对象之间的依赖,spring还有框架粘合剂的作用，帮我们整合各种我们需要的框架如hibernate,mybatis，struts2等. </p>
</blockquote>
<h2 id="Spring能帮我们做什么？"><a href="#Spring能帮我们做什么？" class="headerlink" title="Spring能帮我们做什么？"></a>Spring能帮我们做什么？</h2><ul>
<li>sping帮助我们通过配置文件或者注解创建对象，管理对象之间的依赖关系.</li>
<li>spring的AOP（面向切面编程）帮我们无耦合的实现日志记录，权限控制，性能统计等功能</li>
<li>spring帮助我们管理数据库事物，获取连接，关闭连接的工作交由spring来完成</li>
<li>spring提供了第三方数据访问框架的无缝集成(hibernate,mybatis,JPA)SPRING-JDBCB本身还提供了一套jdbc访问模板</li>
<li>spring提供了第三方web框架的无缝集成(struts2,JSF),spring本身也提供了一套spring-mvc框架方便web层搭建</li>
<li>spring能够帮我们更好的与JAVA EE整合(JAVA MAIL,任务调度,缓存)等</li>
</ul>
<h2 id="如何学好"><a href="#如何学好" class="headerlink" title="如何学好"></a>如何学好</h2><p>要学好Spring，首先要明确Spring是个什么东西，能帮我们做些什么事情，知道了这些然后做个简单的例子，这样就基本知道怎么使用Spring了。Spring核心是IoC容器，所以一定要透彻理解什么是IoC容器，以及如何配置及使用容器，其他所有技术都是基于容器实现的；理解好IoC后，接下来是面向切面编程，首先还是明确概念，基本配置，最后是实现原理，接下来就是数据库事务管理，其实Spring管理事务是通过面向切面编程实现的，所以基础很重要，IoC容器和面向切面编程搞定后，其余都是基于这俩东西的实现，学起来就更加轻松了。要学好Spring不能急，一定要把基础打牢，基础牢固了，这就是磨刀不误砍柴工。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>windows/mac下图床神器</title>
    <url>/2019/08/07/%E5%9B%BE%E5%BA%8A%E7%A5%9E%E5%99%A8/</url>
    <content><![CDATA[<h2 id="windows下图床神器"><a href="#windows下图床神器" class="headerlink" title="windows下图床神器"></a>windows下图床神器</h2><p>价格: <code>免费</code><br>平台: <code>WINDOW</code><br>官网: <a href="http://mpic.lzhaofu.cn/" target="_blank" rel="noopener">图床神器MPIC</a></p>
<h2 id="MAC下图床神器"><a href="#MAC下图床神器" class="headerlink" title="MAC下图床神器"></a>MAC下图床神器</h2><p>价格: <code>免费</code>(自定义图床需要购买高级版，RMB 58/年)<br>平台: <code>Mac</code><br>官网: <a href="https://link.jianshu.com/?t=https://toolinbox.net/iPic/" target="_blank" rel="noopener">图床神器 iPic | Toolinbox</a><br>下载: <a href="https://link.jianshu.com/?t=https://itunes.apple.com/cn/app/id1101244278?mt=12" target="_blank" rel="noopener">AppStore</a></p>
<h2 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h2><p>官网写得很详细了，<a href="https://link.jianshu.com/?t=https://toolinbox.net/iPic/" target="_blank" rel="noopener">点击这里</a> 去官网看吧~</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>图床神器</tag>
      </tags>
  </entry>
  <entry>
    <title>内网穿透端口映射网站</title>
    <url>/2019/08/07/%E5%87%A0%E4%B8%AA%E5%86%85%E7%BD%91%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E6%9C%8D%E5%8A%A1%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<ul>
<li>目前在使用的 <a href="http://ngrok.io/" target="_blank" rel="noopener">http://ngrok.io</a> == <a href="http://ngrok.com/" target="_blank" rel="noopener">http://ngrok.com</a></li>
<li><a href="http://natapp.cn/" target="_blank" rel="noopener">http://natapp.cn/</a></li>
<li><a href="http://ngrok.2bdata.com/" target="_blank" rel="noopener">http://ngrok.2bdata.com/</a></li>
<li><a href="http://www.ngrok.cc/" target="_blank" rel="noopener">http://www.ngrok.cc/</a></li>
<li><a href="http://www.nat123.com/" target="_blank" rel="noopener">http://www.nat123.com/</a></li>
<li>路由侠 <a href="http://www.luyouxia.com/" target="_blank" rel="noopener">http://www.luyouxia.com/</a></li>
<li>WeNAT <a href="https://www.wezoz.com/" target="_blank" rel="noopener">https://www.wezoz.com/</a></li>
</ul>
<h2 id="目前使用的ngrok的穿透工具-（http-ngrok-io）"><a href="#目前使用的ngrok的穿透工具-（http-ngrok-io）" class="headerlink" title="目前使用的ngrok的穿透工具 （http://ngrok.io）"></a>目前使用的ngrok的穿透工具 （<a href="http://ngrok.io）" target="_blank" rel="noopener">http://ngrok.io）</a></h2><p>登录账户: <a href="mailto:blog.nilaile.cn@gmail.com" target="_blank" rel="noopener">blog.nilaile.cn@gmail.com</a></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装:"></a>安装:</h3><ol>
<li>解压ngrok安装程序</li>
<li>命令行进入ngrok目录,执行 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ngrok authtoken 你的token(注册账号成功后再access)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="http://blog.nilaile.cn/blog/20190620/X8hi37QWJdYb.png" alt="mark"></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol>
<li>命令行进入ngrok目录,执行以下命令即可<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ngrok http 8086(你要绑定的本地端口号)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="http://blog.nilaile.cn/blog/20190620/AVYDzWYdp4Da.png" alt="mark">   </p>
<ol start="2">
<li>ngrok还提供了了一个web统计页面访问 <code>http://127.0.0.1:4041</code><br><img src="http://blog.nilaile.cn/blog/20190620/O8SdOI5aOtDh.png" alt="mark"></li>
</ol>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>内网映射</tag>
      </tags>
  </entry>
  <entry>
    <title>前后端工程师的目标</title>
    <url>/2019/08/07/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E7%9B%AE%E6%A0%87/</url>
    <content><![CDATA[<h2 id="术业有专攻，前后端的发展都越来越高深，你想什么都会，那你毕竟什么都不精"><a href="#术业有专攻，前后端的发展都越来越高深，你想什么都会，那你毕竟什么都不精" class="headerlink" title="术业有专攻，前后端的发展都越来越高深，你想什么都会，那你毕竟什么都不精."></a>术业有专攻，前后端的发展都越来越高深，你想什么都会，那你毕竟什么都不精.</h2><hr>
<h3 id="JAVA后端工程师"><a href="#JAVA后端工程师" class="headerlink" title="JAVA后端工程师"></a>JAVA后端工程师</h3><ul>
<li><p>把精力放在java基础，设计模式，jvm原理，spring+springmvc原理及源码，linux，mysql事务隔离与锁机制，mongodb，http/tcp，多线程，分布式架构（dubbo，dubbox，spring cloud），弹性计算架构，微服务架构（springboot+zookeeper+docker+jenkins），java性能优化，以及相关的项目管理</p>
</li>
<li><p>后端追求的是：三高（高并发，高可用，高性能），安全，存储，业务等等 *</p>
</li>
</ul>
<h3 id="前端工程师"><a href="#前端工程师" class="headerlink" title="前端工程师"></a>前端工程师</h3><ul>
<li><p>把精力放在html5，css3，jquery，angularjs，bootstrap，reactjs，vuejs，webpack，less/sass，gulp，nodejs，Google V8引擎，javascript多线程，模块化，面向切面编程，设计模式，浏览器兼容性，性能优化等等。</p>
</li>
<li><p>前端追求的是：页面表现，速度流畅，兼容性，用户体验等等。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>全栈</category>
      </categories>
      <tags>
        <tag>计划</tag>
        <tag>目标</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里FastJson如何处理返回值中nulll值问题</title>
    <url>/2019/08/07/%E4%BD%BF%E7%94%A8FastJson%E5%85%A8%E5%B1%80%E5%A4%84%E7%90%86%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%ADnulll%E5%80%BC%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<ol>
<li>springBoot项目,全局处理策略</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class HttpMessageConverterConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public HttpMessageConverters fastJsonHttpMessageConverters() &#123;</span><br><span class="line">        //1、定义一个convert转换消息的对象</span><br><span class="line">        FastJsonHttpMessageConverter fastConverter = new FastJsonHttpMessageConverter();</span><br><span class="line"></span><br><span class="line">        //2、添加fastjson的配置信息</span><br><span class="line">        FastJsonConfig fastJsonConfig = new FastJsonConfig();</span><br><span class="line"></span><br><span class="line">        SerializerFeature[] serializerFeatures = new SerializerFeature[]&#123;</span><br><span class="line">                //    输出key是包含双引号</span><br><span class="line">				// SerializerFeature.QuoteFieldNames,</span><br><span class="line">                //    是否输出为null的字段,若为null 则显示该字段</span><br><span class="line">				// SerializerFeature.WriteMapNullValue,</span><br><span class="line">                //    数值字段如果为null，则输出为0</span><br><span class="line">                SerializerFeature.WriteNullNumberAsZero,</span><br><span class="line">                //     List字段如果为null,输出为[],而非null</span><br><span class="line">                SerializerFeature.WriteNullListAsEmpty,</span><br><span class="line">                //    字符类型字段如果为null,输出为&quot;&quot;,而非null</span><br><span class="line">                SerializerFeature.WriteNullStringAsEmpty,</span><br><span class="line">                //    Boolean字段如果为null,输出为false,而非null</span><br><span class="line">                SerializerFeature.WriteNullBooleanAsFalse,</span><br><span class="line">                //    Date的日期转换器</span><br><span class="line">                SerializerFeature.WriteDateUseDateFormat,</span><br><span class="line">                //    循环引用</span><br><span class="line">                SerializerFeature.DisableCircularReferenceDetect,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        fastJsonConfig.setSerializerFeatures(serializerFeatures);</span><br><span class="line">        fastJsonConfig.setCharset(Charset.forName(&quot;UTF-8&quot;));</span><br><span class="line"></span><br><span class="line">        //3、在convert中添加配置信息</span><br><span class="line">        fastConverter.setFastJsonConfig(fastJsonConfig);</span><br><span class="line"></span><br><span class="line">        //4、将convert添加到converters中</span><br><span class="line">        HttpMessageConverter&lt;?&gt; converter = fastConverter;</span><br><span class="line"></span><br><span class="line">        return new HttpMessageConverters(converter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>作为工具方法 单独使用JSON.toJsonString转换对象为json字符串时用法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SerializerFeature[] serializerFeatures = new SerializerFeature[]&#123;</span><br><span class="line">						//    输出key是包含双引号</span><br><span class="line">						//SerializerFeature.QuoteFieldNames,</span><br><span class="line">						//    是否输出为null的字段,若为null 则显示该字段</span><br><span class="line">						//SerializerFeature.WriteMapNullValue,</span><br><span class="line">						//    数值字段如果为null，则输出为0</span><br><span class="line">						SerializerFeature.WriteNullNumberAsZero,</span><br><span class="line">						//     List字段如果为null,输出为[],而非null</span><br><span class="line">						SerializerFeature.WriteNullListAsEmpty,</span><br><span class="line">						//    字符类型字段如果为null,输出为&quot;&quot;,而非null</span><br><span class="line">						SerializerFeature.WriteNullStringAsEmpty,</span><br><span class="line">						//    Boolean字段如果为null,输出为false,而非null</span><br><span class="line">						SerializerFeature.WriteNullBooleanAsFalse,</span><br><span class="line">						//    Date的日期转换器</span><br><span class="line">						SerializerFeature.WriteDateUseDateFormat,</span><br><span class="line">						//    循环引用</span><br><span class="line">					SerializerFeature.DisableCircularReferenceDetect&#125;;</span><br><span class="line"></span><br><span class="line">					//重点在这里,这种设计真的挺灵活的</span><br><span class="line">String content = JSON.toJSONString(body,serializerFeatures);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>fastJson</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>乡愁</title>
    <url>/2019/08/07/%E4%B9%A1%E6%84%81/</url>
    <content><![CDATA[<p>有家的地方没有工作，有工作的地方没有家，他乡容不了灵魂，故乡安置不了肉身。从此便有了漂泊，有了远方,有了乡愁,有了无尽的牵挂</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>乡愁</tag>
      </tags>
  </entry>
  <entry>
    <title>使用nginx做反代时遇到413 Request Entity Too Large的解决方法</title>
    <url>/2019/08/07/%E4%BD%BF%E7%94%A8nginx%E5%81%9A%E5%8F%8D%E4%BB%A3%E6%97%B6%E9%81%87%E5%88%B0413-Request-Entity-Too-Large%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p><strong><a href="https://www.cnblogs.com/jiaoyiping/p/5638096.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiaoyiping/p/5638096.html</a></strong></p>
<p><a href="https://blog.csdn.net/qq_36949907/article/details/79182363" target="_blank" rel="noopener">https://blog.csdn.net/qq_36949907/article/details/79182363</a></p>
<p><a href="https://www.cnblogs.com/wanghx-0713/p/8080571.html" target="_blank" rel="noopener">https://www.cnblogs.com/wanghx-0713/p/8080571.html</a><br>Mysql时间差函数<br>SELECT TIMESTAMPDIFF(MONTH,’2009-10-01’,’2009-09-01’);<br>interval可是：<br>SECOND 秒 SECONDS<br>MINUTE 分钟 MINUTES<br>HOUR 时间 HOURS<br>DAY 天 DAYS<br>MONTH 月 MONTHS<br>YEAR 年 YEARS</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Javaweb项目为什么要前后端分离？为什么要解耦（转载）</title>
    <url>/2019/08/07/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
</blockquote>
<p>前后端分离已成为互联网项目开发的业界标准使用方式，通过nginx+tomcat的方式（也可以中间加一个nodejs）有效的进行解耦，<br>并且前后端分离会为以后的大型分布式架构、弹性计算架构、微服务架构、多端化服务（多种客户端，例如：浏览器，车载终端，安卓，IOS等等）打下坚实的基础。<br>这个步骤是系统架构从猿进化成人的必经之路。</p>
<ul>
<li>核心思想是前端html页面通过ajax调用后端的restuful api接口并使用json数据进行交互。</li>
</ul>
<p>（<br>名词解释：<br>在互联网架构中，<br>web服务器：一般指像nginx，apache这类的服务器，他们一般只能解析静态资源。<br>应用服务器：一般指像tomcat，jetty，resin这类的服务器可以解析动态资源也可以解析静态资源，但解析静态资源的能力没有web服务器好。</p>
<p>一般都是只有web服务器才能被外网访问，应用服务器只能内网访问。<br>）<br>术业有专攻（开发人员分离）</p>
<p>以前的JavaWeb项目大多数都是java程序员又当爹又当妈，又搞前端（ajax/jquery/js/html/css等等），又搞后端（java/mysql/oracle等等）。</p>
<p>随着时代的发展，渐渐的许多大中小公司开始把前后端的界限分的越来越明确，前端工程师只管前端的事情，后端工程师只管后端的事情。<br>正所谓术业有专攻，一个人如果什么都会，那么他毕竟什么都不精。</p>
<p>大中型公司需要专业人才，小公司需要全才，但是对于个人职业发展来说，我建议是分开。</p>
<p>对于后端java工程师：<br>把精力放在java基础，设计模式，jvm原理，spring+springmvc原理及源码，linux，mysql事务隔离与锁机制，mongodb，http/tcp，多线程，分布式架构（dubbo，dubbox，spring cloud），弹性计算架构，微服务架构（springboot+zookeeper+docker+jenkins），java性能优化，以及相关的项目管理等等。<br>后端追求的是：三高（高并发，高可用，高性能），安全，存储，业务等等。</p>
<p>对于前端工程师：<br>把精力放在html5，css3，jquery，angularjs，bootstrap，reactjs，vuejs，webpack，less/sass，gulp，nodejs，Google V8引擎，javascript多线程，模块化，面向切面编程，设计模式，浏览器兼容性，性能优化等等。<br>前端追求的是：页面表现，速度流畅，兼容性，用户体验等等。</p>
<p>偏头痛杨原创文章，禁止转载，版权必究。</p>
<p>术业有专攻，这样你的核心竞争力才会越来越高，正所谓你往生活中投入什么，生活就会反馈给你什么。<br>并且两端的发展都越来越高深，你想什么都会，那你毕竟什么都不精。</p>
<p>通过将team分成前后端team，让两边的工程师更加专注各自的领域，独立治理，然后构建出一个全栈式的精益求精的team。<br>原始人时代（各种耦合）</p>
<p>几曾何时，我们的JavaWeb项目都是使用了若干后台框架，springmvc/struts + spring + spring jdbc/hibernate/mybatis 等等。</p>
<p>大多数项目在java后端都是分了三层，控制层（controller/action），业务层（service/manage），持久层（dao）。<br>控制层负责接收参数，调用相关业务层，封装数据，以及路由&amp;渲染到jsp页面。<br>然后jsp页面上使用各种标签（jstl/el/struts标签等）或者手写java表达式（&lt;%=%&gt;）将后台的数据展现出来，玩的是MVC那套思路。</p>
<p>我们先看这种情况：需求定完了，代码写完了，测试测完了，然后呢？要发布了吧？<br>你需要用maven或者eclipse等工具把你的代码打成一个war包，然后把这个war包发布到你的生产环境下的web容器（tomcat/jboss/weblogic/websphere/jetty/resin）里，对吧？</p>
<p>发布完了之后，你要启动你的web容器，开始提供服务，这时候你通过配置域名，dns等等相关，你的网站就可以访问了（假设你是个网站）。<br>那我们来看，你的前后端代码是不是全都在那个war包里？包括你的js，css，图片，各种第三方的库，对吧？</p>
<p>好，下面在浏览器中输入你的网站域名（<a href="http://www.xxx.com），之后发生了什么？（这个问题也是很多公司的面试题）" target="_blank" rel="noopener">www.xxx.com），之后发生了什么？（这个问题也是很多公司的面试题）</a><br>我捡干的说了啊，基础不好的童鞋请自己去搜。</p>
<p>浏览器在通过域名通过dns服务器找到你的服务器外网ip,将http请求发送到你的服务器，在tcp 3次握手之后（http下面是tcp/ip），通过tcp协议开始传输数据，你的服务器得到请求后，开始提供服务，接收参数，之后返回你的应答给浏览器，浏览器再通过content-type来解析你返回的内容，呈现给用户。</p>
<p>那么我们来看，我们先假设你的首页中有100张图片，此时，用户的看似一次http请求，其实并不是一次，用户在第一次访问的时候，浏览器中不会有缓存，你的100张图片，浏览器要连着请求100次http请求（有人会跟我说http长连短连的问题，不在这里讨论），你的服务器接收这些请求，都需要耗费内存去创建socket来玩tcp传输（消耗你服务器上的计算资源）。</p>
<p>偏头痛杨原创文章，禁止转载，版权必究。</p>
<p>重点来了，这样的话，你的服务器的压力会非常大，因为页面中的所有请求都是只请求到你这台服务器上，如果1个人还好，如果10000个人并发访问呢（先不聊服务器集群，这里就说是单实例服务器），那你的服务器能扛住多少个tcp连接？你的带宽有多大？你的服务器的内存有多大？你的硬盘是高性能的吗？你能抗住多少IO？你给web服务器分的内存有多大？会不会宕机？</p>
<p>这就是为什么，越是大中型的web应用，他们越是要解耦。<br>理论上你可以把你的数据库+应用服务+消息队列+缓存+用户上传的文件+日志+等等都扔在一台服务器上，你也不用玩什么服务治理，也不用做什么性能监控，什么报警机制等等，就乱成一锅粥好了。<br>但是这样就好像是你把鸡蛋都放在一个篮子里，隐患非常大。如果因为一个子应用的内存不稳定导致整个服务器内存溢出而hung住，那你的整个网站就挂掉了。</p>
<p>如果出意外挂掉，而恰好这时你们的业务又处于井喷式发展高峰期，那么恭喜你，业务成功被技术卡住，很可能会流失大量用户，后果不堪设想。<br>注意：技术一定是要走在业务前面的，否则你将错过最佳的发展期哟，亲~</p>
<p>此外，你的应用全部都耦合在一起，相当于一个巨石，当服务端负载能力不足时，一般会使用负载均衡的方式，将服务器做成集群，这样其实你是在水平扩展一块块巨石，性能加速度会越来越低，<br>要知道，本身负载就低的功能or模块是没有必要水平扩展的，在本文中的例子就是你的性能瓶颈不在前端，那干嘛要水平扩展前端呢？？？<br>还有发版部署上线的时候，我明明只改了后端的代码，为什么要前端也跟着发布呢？？？<br>（引用：《架构探险-轻量级微服务架构》，黄勇）</p>
<p>正常的互联网架构，是都要拆开的，你的web服务器集群，你的应用服务器集群+文件服务器集群+数据库服务器集群+消息队列集群+缓存集群等等。<br>JSP的痛点</p>
<p>以前的javaWeb项目大多数使用jsp作为页面层展示数据给用户，因为流量不高，因此也没有那么苛刻的性能要求，但现在是大数据时代，对于互联网项目的性能要求是越来越高，<br>因此原始的前后端耦合在一起的架构模式已经逐渐不能满足我们，因此我们需要需找一种解耦的方式，来大幅度提升我们的负载能力。</p>
<p>1.动态资源和静态资源全部耦合在一起，服务器压力大，因为服务器会收到各种http请求，例如css的http请求，js的，图片的等等。<br>一旦服务器出现状况，前后台一起玩完，用户体验极差。</p>
<p>2.UI出好设计图后，前端工程师只负责将设计图切成html，需要由java工程师来将html套成jsp页面，出错率较高（因为页面中经常会出现大量的js代码），<br>修改问题时需要双方协同开发，效率低下。</p>
<p>3.jsp必须要在支持java的web服务器里运行（例如tomcat，jetty，resin等），无法使用nginx等（nginx据说单实例http并发高达5w，这个优势要用上），<br>性能提不上来。</p>
<p>4.第一次请求jsp，必须要在web服务器中编译成servlet，第一次运行会较慢。</p>
<p>5.每次请求jsp都是访问servlet再用输出流输出的html页面，效率没有直接使用html高（是每次哟，亲~）。</p>
<p>6.jsp内有较多标签和表达式，前端工程师在修改页面时会捉襟见肘，遇到很多痛点。</p>
<p>7.如果jsp中的内容很多，页面响应会很慢，因为是同步加载。</p>
<p>8.需要前端工程师使用java的ide（例如eclipse），以及需要配置各种后端的开发环境，你们有考虑过前端工程师的感受吗。</p>
<p>基于上述的一些痛点，我们应该把整个项目的开发权重往前移，实现前后端真正的解耦！<br>偏头痛杨原创文章，禁止转载，版权必究。<br>开发模式</p>
<p>以前老的方式是：<br>1.产品经历/领导/客户提出需求<br>2.UI做出设计图<br>3.前端工程师做html页面<br>4.后端工程师将html页面套成jsp页面（前后端强依赖，后端必须要等前端的html做好才能套jsp。如果html发生变更，就更痛了，开发效率低）<br>5.集成出现问题<br>6.前端返工<br>7.后端返工<br>8.二次集成<br>9.集成成功<br>10.交付</p>
<p>新的方式是：<br>1.产品经历/领导/客户提出需求<br>2.UI做出设计图<br>3.前后端约定接口&amp;数据&amp;参数<br>4.前后端并行开发（无强依赖，可前后端并行开发，如果需求变更，只要接口&amp;参数不变，就不用两边都修改代码，开发效率高）<br>5.前后端集成<br>6.前端页面调整<br>7.集成成功<br>8.交付</p>
<p>请求方式</p>
<p>以前老的方式是：<br>1.客户端请求<br>2.服务端的servlet或controller接收请求（后端控制路由与渲染页面，整个项目开发的权重大部分在后端）<br>3.调用service,dao代码完成业务逻辑<br>4.返回jsp<br>5.jsp展现一些动态的代码</p>
<p>新的方式是：<br>1.浏览器发送请求<br>2.直接到达html页面（前端控制路由与渲染页面，整个项目开发的权重前移）<br>3.html页面负责调用服务端接口产生数据（通过ajax等等，后台返回json格式数据，json数据格式因为简洁高效而取代xml）<br>4.填充html，展现动态效果，在页面上进行解析并操作DOM。<br>（有兴趣的童鞋可以访问一下阿里巴巴等大型网站，然后按一下F12，监控一下你刷新一次页面，他的http是怎么玩的，大多数都是单独请求后台数据，<br>使用json传输数据，而不是一个大而全的http请求把整个页面包括动+静全部返回过来）</p>
<p>偏头痛杨原创文章，禁止转载，版权必究。<br>总结一下新的方式的请求步骤：<br>大量并发浏览器请求—&gt;web服务器集群(nginx)—&gt;应用服务器集群(tomcat)—&gt;文件/数据库/缓存/消息队列服务器集群<br>同时又可以玩分模块，还可以按业务拆成一个个的小集群，为后面的架构升级做准备。</p>
<p>前后分离的优势</p>
<p>1.可以实现真正的前后端解耦，前端服务器使用nginx。<br>前端/WEB服务器放的是css，js，图片等等一系列静态资源（甚至你还可以css，js，图片等资源放到特定的文件服务器，例如阿里云的oss，并使用cdn加速），前端服务器负责控制页面引用&amp;跳转&amp;路由，前端页面异步调用后端的接口，后端/应用服务器使用tomcat（把tomcat想象成一个数据提供者），加快整体响应速度。<br>（这里需要使用一些前端工程化的框架比如nodejs，react，router，react，redux，webpack）</p>
<p>2.发现bug，可以快速定位是谁的问题，不会出现互相踢皮球的现象。<br>页面逻辑，跳转错误，浏览器兼容性问题，脚本错误，页面样式等问题，全部由前端工程师来负责。<br>接口数据出错，数据没有提交成功，应答超时等问题，全部由后端工程师来解决。<br>双方互不干扰，前端与后端是相亲相爱的一家人。</p>
<p>3.在大并发情况下，我可以同时水平扩展前后端服务器，比如淘宝的一个首页就需要2000+台前端服务器做集群来抗住日均多少亿+的日均pv。<br>（去参加阿里的技术峰会，听他们说他们的web容器都是自己写的，就算他单实例抗10万http并发，2000台是2亿http并发，并且他们还可以根据预知洪峰来无限拓展，很恐怖，就一个首页。。。）</p>
<p>4.减少后端服务器的并发/负载压力<br>除了接口以外的其他所有http请求全部转移到前端nginx上，接口的请求调用tomcat，参考nginx反向代理tomcat。<br>且除了第一次页面请求外，浏览器会大量调用本地缓存。</p>
<p>5.即使后端服务暂时超时或者宕机了，前端页面也会正常访问，只不过数据刷不出来而已。</p>
<p>6.也许你也需要有微信相关的轻应用，那样你的接口完全可以共用，如果也有app相关的服务，<br>那么只要通过一些代码重构，也可以大量复用接口，提升效率。（多端应用）</p>
<p>7.页面显示的东西再多也不怕，因为是异步加载。</p>
<p>8.nginx支持页面热部署，不用重启服务器，前端升级更无缝。</p>
<p>9.增加代码的维护性&amp;易读性（前后端耦在一起的代码读起来相当费劲）。</p>
<p>10.提升开发效率，因为可以前后端并行开发，而不是像以前的强依赖。</p>
<p>11.在nginx中部署证书，外网使用https访问，并且只开放443和80端口，其他端口一律关闭（防止黑客端口扫描），<br>内网使用http，性能和安全都有保障。</p>
<p>12.前端大量的组件代码得以复用，组件化，提升开发效率，抽出来！<br>注意事项</p>
<p>1.在开需求会议的时候，前后端工程师必须全部参加，并且需要制定好接口文档，后端工程师要写好测试用例（2个维度），不要让前端工程师充当你的专职测试，<br>推荐使用chrome的插件postman或soapui或jmeter，service层的测试用例拿junit写。ps：前端也可以玩单元测试吗？</p>
<p>2.上述的接口并不是java里的interface，说白了调用接口就是调用你controler里的方法。</p>
<p>3.加重了前端团队的工作量，减轻了后端团队的工作量，提高了性能和可扩展性。</p>
<p>4.我们需要一些前端的框架来解决类似于页面嵌套，分页，页面跳转控制等功能。（上面提到的那些前端框架）。</p>
<p>5.如果你的项目很小，或者是一个单纯的内网项目，那你大可放心，不用任何架构而言，但是如果你的项目是外网项目，呵呵哒。</p>
<p>6.以前还有人在使用类似于velocity/freemarker等模板框架来生成静态页面，仁者见仁智者见智。</p>
<p>7.这篇文章主要的目的是说jsp在大型外网java web项目中被淘汰掉，可没说jsp可以完全不学，对于一些学生朋友来说，jsp/servlet等相关的java web基础还是要掌握牢的，不然你以为springmvc这种框架是基于什么来写的？</p>
<p>8.如果页面上有一些权限等等相关的校验，那么这些相关的数据也可以通过ajax从接口里拿。</p>
<p>9.对于既可以前端做也可以后端做的逻辑，我建议是放到前端，为什么？<br>因为你的逻辑需要计算资源进行计算，如果放到后端去run逻辑，则会消耗带宽&amp;内存&amp;cpu等等计算资源，你要记住一点就是<br>服务端的计算资源是有限的，而如果放到前端，使用的是客户端的计算资源，这样你的服务端负载就会下降（高并发场景）。<br>类似于数据校验这种，前后端都需要做！</p>
<p>10.前端需要有机制应对后端请求超时以及后端服务宕机的情况，友好的展示给用户。</p>
<p>扩展阅读</p>
<p>1.其实对于js，css，图片这类的静态资源可以考虑放到类似于阿里云的oss这类文件服务器上（如果是普通的服务器&amp;操作系统，存储在到达pb级的文件后，或者单个文件夹内的文件数量达到3-5万，<br>io会有很严重的性能问题），<br>再在oss上配cdn（全国子节点加速），这样你页面打开的速度像飞一样， 无论你在全国的哪个地方，并且你的nginx的负载会进一步降低。</p>
<p>2.如果你要玩轻量级微服务架构，要使用nodejs做网关，用nodejs的好处还有利于seo优化，因为nginx只是向浏览器返回页面静态资源，而国内的搜索引擎爬虫只会抓取静态数据，不会解析页面中的js，<br>这使得应用得不到良好的搜索引擎支持。同时因为nginx不会进行页面的组装渲染，需要把静态页面返回到浏览器，然后完成渲染工作，这加重了浏览器的渲染负担。<br>浏览器发起的请求经过nginx进行分发，URL请求统一分发到nodejs，在nodejs中进行页面组装渲染；API请求则直接发送到后端服务器，完成响应。</p>
<p>3.如果遇到跨域问题，spring4的CORS可以完美解决，但一般使用nginx反向代理都不会有跨域问题，除非你把前端服务和后端服务分成两个域名。<br>JSONP的方式也被淘汰掉了。</p>
<p>4.如果想玩多端应用，注意要去掉tomcat原生的session机制，要使用token机制，使用缓存（因为是分布式系统），做单点，对于token机制的安全性问题，可以搜一下jwt。</p>
<p>5.前端项目中可以加入mock测试（构造虚拟测试对象来模拟后端，可以独立开发和测试），后端需要有详细的测试用例，保证服务的可用性与稳定性。<br>总结</p>
<p>前后端分离并非仅仅只是一种开发模式，而是一种架构模式（前后端分离架构）。<br>千万不要以为只有在撸代码的时候把前端和后端分开就是前后端分离了。需要区分前后端项目<br>前端项目与后端项目是两个项目，放在两个不同的服务器，需要独立部署，两个不同的工程，两个不同的代码库，不同的开发人员。<br>前后端工程师需要约定交互接口，实现并行开发，开发结束后需要进行独立部署，前端通过ajax来调用http请求调用后端的restful api。<br>前端只需要关注页面的样式与动态数据的解析&amp;渲染，而后端专注于具体业务逻辑。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>系统架构</tag>
      </tags>
  </entry>
  <entry>
    <title>windows基于NGINX配置HTTPS证书</title>
    <url>/2019/08/07/windows%E9%85%8D%E7%BD%AEhttps%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<ol>
<li><p>下载解压nginx的windows版本 （笔者使用的版本是nginx-1.12.2版)<a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">官方下载链接</a>具体</p>
</li>
<li><p>从阿里云获取那个免费的HTTPS证书</p>
</li>
<li><p>Nginx的config路径下创建cert文件夹，将证书解压到该目录下，证书一般是两个文件，分别是<strong>**</strong>.key和 ***.pem</p>
</li>
<li><p>修改配置文件如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">	listen 443;</span><br><span class="line">	server_name localhost;</span><br><span class="line">	ssl on;</span><br><span class="line">	ssl_certificate  	cert/2195340_www.baidu.com.pem;    #替换为自己的证书文件</span><br><span class="line">	ssl_certificate_key 	cert/2195340_www.baidu.com.key;#替换为自己的证书文件</span><br><span class="line">	ssl_session_timeout 5m;</span><br><span class="line">	ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">	ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">	ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">	proxy_set_header Host $host;</span><br><span class="line">	proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line"></span><br><span class="line">   location / &#123;</span><br><span class="line">		proxy_set_header Host $host;</span><br><span class="line">		proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">		root   D:/nginx-1.12.2/html;</span><br><span class="line">		index  index.html index.htm;</span><br><span class="line">		try_files $uri $uri/ @router;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">   location /admin &#123;</span><br><span class="line">		proxy_set_header Host $host;</span><br><span class="line">		proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">		proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">		proxy_pass http://127.0.0.1:8083/admin;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> server &#123;</span><br><span class="line">   	listen   80;</span><br><span class="line">	server_name www.nilaile.com  nilaile.com;   #这里改为自己的域名,多个域名空格分开</span><br><span class="line">	proxy_set_header Host $host;</span><br><span class="line">	proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">	rewrite ^(.*)$  https://$&#123;server_name&#125;$1 permanent; </span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>NGINX</tag>
      </tags>
  </entry>
  <entry>
    <title>windows安装Nginx</title>
    <url>/2019/08/07/windows%E5%AE%89%E8%A3%85nginx/</url>
    <content><![CDATA[<h2 id="1-官方下载NGINX-download"><a href="#1-官方下载NGINX-download" class="headerlink" title="1. 官方下载NGINX download"></a>1. 官方下载NGINX <a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">download</a></h2><h2 id="2-解压运行"><a href="#2-解压运行" class="headerlink" title="2.解压运行"></a>2.解压运行</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd c:\</span><br><span class="line">unzip nginx-1.12.2.zip</span><br><span class="line">cd nginx-1.12.2</span><br><span class="line">start nginx</span><br></pre></td></tr></table></figure>
<h2 id="3-命令行查看"><a href="#3-命令行查看" class="headerlink" title="3. 命令行查看"></a>3. 命令行查看</h2><p>命令行运行  <code>tasklist</code> 可以看到nginx的两个进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\nginx-1.12.2&gt;tasklist /fi &quot;imagename eq nginx.exe&quot;</span><br><span class="line"></span><br><span class="line"> Image Name           PID Session Name     Session#    Mem Usage</span><br><span class="line">=============== ======== ============== ========== ============</span><br><span class="line"> nginx.exe            652 Console                 0      2 780 K</span><br><span class="line"> nginx.exe           1332 Console                 0      3 112 K</span><br></pre></td></tr></table></figure>
<p>有两个进程,一个进程是master进程 另一个是worker进程, 如果进程没有启动成功，可以查看日志文件 <code>logs\error.log</code></p>
<p>Nginx常用命令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>Model</th>
</tr>
</thead>
<tbody>
<tr>
<td>start nginx</td>
<td>启动</td>
</tr>
<tr>
<td>nginx -s stop</td>
<td>迅速退出</td>
</tr>
<tr>
<td>nginx -s quit</td>
<td>优雅的退出</td>
</tr>
<tr>
<td>nginx -s reload</td>
<td>修改配置文件后重载</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>NGINX</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2019/08/07/swaggr%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>/**</p>
<ul>
<li>swagger使用规范</li>
<li>之所以设定规范是为了能够让swagger被正确运用以便达到替代传统接口文档和解决传统文档的痛点的两个目的.<br> *</li>
<li>传统接口文档中对于每个请求参数都有详细的描述, 前端对于多数请求参数都能准确理解, 但是在编写这份使用规范前swagger未被正确运用</li>
<li>已造成前端无法准确理解请求参数的含义,增加了不必要的沟通成本.<br> *</li>
<li>传统接口文档对于每个模块之间的分类很明确, 前端能够快速查找到对应模块的接口文档, 但是在编写这份使用规范前swagger未被正确运用</li>
<li><p>导致每个模块名称仅被描述为”xxx-controller”,前端无法快速查找到对应模块的接口文档同时也增加了不必要的沟通成本.</p>
</li>
<li><p>传统接口文档对于请求响应都有code来表明当前请求的状况, 可根据对应的code来完成相应操作, 但是在编写这份使用规范前swagger未被正确运用, 导致前端无法准确理解目前所使用的Http code所代表的含义, 从而增加了不必要的沟通成本.<br> *</p>
</li>
<li>为了解决以上三个存在的问题从而达到易维护和消除不必要的沟通成本的目的, 请各位同事严格遵守以下规范.</li>
<li>若有不同的想法,欢迎提出讨论并完善该规范.<br> *</li>
<li>1.controller中对于path及form类型参数的使用规范</li>
<li>请查看示例{@link com.hikedu.backend.swaggerexample.ExampleController#pathAndFormParamsStandard(String)}<br> *</li>
<li>2.controller中对于code的使用及描述规范</li>
<li>使用Http code并通过注解@ApiResponse来完成描述, 并根据对应的情况在ResponseEntity对象中返回.</li>
<li>请查看示例中的@Responses注解的用法</li>
<li>{@link com.hikedu.backend.swaggerexample.ExampleController#pathAndFormParamsStandard(String)}<br> *</li>
<li>3.禁止直接使用Model来作为controller的接收参数, 而是创建对应的DTO来接收参数.</li>
<li>之所以禁止是因为如下几个原因:</li>
<li>1.model的意义是在controller、service、dao、View层来传递数据, 所以尽量保证model功能的单一, 以避免产生不必要的复杂度.</li>
<li>2.使用model因为存在诸如createdAt, updatedAt等不必要的字段并不适合作为controller的入参.</li>
<li>3.model因其本身的意义不能添加太多和model功能不相干的属性以达到使用model作为controller参数的目的.</li>
<li>因此有必要创建DTO来作为controller的参数.</li>
<li>使用详见{@link com.hikedu.backend.model.dto.ExampleDTO}<br> *</li>
<li>4.controller中对于使用对象接收参数的使用规范</li>
<li>在当前规范未实施前, 所有的以对象接收的参数的字段含义对于前端来讲是模糊不清的.</li>
<li>因此有必要对对象中的每个属性做描述,以便前端能够理解参数的含义.</li>
<li>示例见{@link com.hikedu.backend.model.dto.ExampleDTO}中的参数注解</li>
<li>和{@link com.hikedu.backend.swaggerexample.ExampleController#objectParamsStandard(ExampleDTO)}<br> *</li>
<li>5.响应的model数据添加说明</li>
<li>未实施当前规范前, 所有的响应数据均没有说明, 前端无法理解响应数据中参数的含义, 因此有必要在响应的model中为每个参数添加说明</li>
<li>示例见如下两处</li>
<li>{@link com.hikedu.backend.model.dto.ExampleResponseDataDTO}</li>
<li>{@link ExampleController#responseDataStandard()}<br> *</li>
<li>@author himly <a href="mailto:z1399956473@gamil.com" target="_blank" rel="noopener">z1399956473@gamil.com</a> 2018.8.20<br> */</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>next主题配置文件</title>
    <url>/2019/08/07/next%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ===============================================================</span><br><span class="line"># ========================= ATTENTION! ==========================</span><br><span class="line"># ===============================================================</span><br><span class="line"># NexT repository is moving here: https://github.com/theme-next</span><br><span class="line"># ===============================================================</span><br><span class="line"># It&apos;s rebase to v6.0.0 and future maintenance will resume there</span><br><span class="line"># ===============================================================</span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Theme Core Configuration Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># Set to true, if you want to fully override the default configuration.</span><br><span class="line"># Useful if you don&apos;t want to inherit the theme _config.yml configurations.</span><br><span class="line">override: false</span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Site Information Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># To get or check favicons visit: https://realfavicongenerator.net</span><br><span class="line"># Put your favicons into `hexo-site/source/` (recommend) or `hexo-site/themes/next/source/images/` directory.</span><br><span class="line"></span><br><span class="line"># Default NexT favicons placed in `hexo-site/themes/next/source/images/` directory.</span><br><span class="line"># And if you want to place your icons in `hexo-site/source/` root directory, you must remove `/images` prefix from pathes.</span><br><span class="line"></span><br><span class="line"># For example, you put your favicons into `hexo-site/source/images` directory.</span><br><span class="line"># Then need to rename &amp; redefine they on any other names, otherwise icons from Next will rewrite your custom icons in Hexo.</span><br><span class="line">favicon:</span><br><span class="line">  small: /images/favicon-16x16-next.png</span><br><span class="line">  medium: /images/favicon-32x32-next.png</span><br><span class="line">  apple_touch_icon: /images/apple-touch-icon-next.png</span><br><span class="line">  safari_pinned_tab: /images/logo.svg</span><br><span class="line">  #android_manifest: /images/manifest.json</span><br><span class="line">  #ms_browserconfig: /images/browserconfig.xml</span><br><span class="line"></span><br><span class="line"># Set default keywords (Use a comma to separate)</span><br><span class="line">keywords: &quot;Hexo, NexT&quot;</span><br><span class="line"></span><br><span class="line"># Set rss to false to disable feed link.</span><br><span class="line"># Leave rss as empty to use site&apos;s feed link.</span><br><span class="line"># Set rss to specific value if you have burned your feed already.</span><br><span class="line">rss:</span><br><span class="line"></span><br><span class="line">footer:</span><br><span class="line">  # Specify the date when the site was setup.</span><br><span class="line">  # If not defined, current year will be used.</span><br><span class="line">  #since: 2015</span><br><span class="line"></span><br><span class="line">  # Icon between year and copyright info.</span><br><span class="line">  icon: user</span><br><span class="line"></span><br><span class="line">  # If not defined, will be used `author` from Hexo main config.</span><br><span class="line">  copyright:</span><br><span class="line">  # -------------------------------------------------------------</span><br><span class="line">  # Hexo link (Powered by Hexo).</span><br><span class="line">  powered: true</span><br><span class="line"></span><br><span class="line">  theme:</span><br><span class="line">    # Theme &amp; scheme info link (Theme - NexT.scheme).</span><br><span class="line">    enable: true</span><br><span class="line">    # Version info of NexT after scheme info (vX.X.X).</span><br><span class="line">    version: true</span><br><span class="line">  # -------------------------------------------------------------</span><br><span class="line">  # Any custom text can be defined here.</span><br><span class="line">  #custom_text: Hosted by &lt;a target=&quot;_blank&quot; href=&quot;https://pages.github.com&quot;&gt;GitHub Pages&lt;/a&gt;</span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># SEO Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># Canonical, set a canonical link tag in your hexo, you could use it for your SEO of blog.</span><br><span class="line"># See: https://support.google.com/webmasters/answer/139066</span><br><span class="line"># Tips: Before you open this tag, remember set up your URL in hexo _config.yml ( ex. url: http://yourdomain.com )</span><br><span class="line">canonical: true</span><br><span class="line"></span><br><span class="line"># Change headers hierarchy on site-subtitle (will be main site description) and on all post/pages titles for better SEO-optimization.</span><br><span class="line">seo: false</span><br><span class="line"></span><br><span class="line"># If true, will add site-subtitle to index page, added in main hexo config.</span><br><span class="line"># subtitle: Subtitle</span><br><span class="line">index_with_subtitle: false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Menu Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash from link value (/archives -&gt; archives).</span><br><span class="line"># Usage: `Key: /link/ || icon`</span><br><span class="line"># Key is the name of menu item. If translate for this menu will find in languages - this translate will be loaded; if not - Key name will be used. Key is case-senstive.</span><br><span class="line"># Value before `||` delimeter is the target link.</span><br><span class="line"># Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, question icon will be loaded.</span><br><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  #about: /about/ || user</span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  #categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  #schedule: /schedule/ || calendar</span><br><span class="line">  #sitemap: /sitemap.xml || sitemap</span><br><span class="line">  commonweal: /404.html  || heartbeat</span><br><span class="line"></span><br><span class="line"># Enable/Disable menu icons.</span><br><span class="line">menu_icons:</span><br><span class="line">  enable: true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Scheme Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">#scheme: Gemini</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Sidebar Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># Social Links.</span><br><span class="line"># Usage: `Key: permalink || icon`</span><br><span class="line"># Key is the link label showing to end users.</span><br><span class="line"># Value before `||` delimeter is the target permalink.</span><br><span class="line"># Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded.</span><br><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/godloveyou || github</span><br><span class="line">  E-Mail: mailto:823939100@gmail.com || envelope</span><br><span class="line">  #Google: https://plus.google.com/yourname || google</span><br><span class="line">  #Twitter: https://twitter.com/yourname || twitter</span><br><span class="line">  #FB Page: https://www.facebook.com/yourname || facebook</span><br><span class="line">  #VK Group: https://vk.com/yourname || vk</span><br><span class="line">  #StackOverflow: https://stackoverflow.com/yourname || stack-overflow</span><br><span class="line">  #YouTube: https://youtube.com/yourname || youtube</span><br><span class="line">  #Instagram: https://instagram.com/yourname || instagram</span><br><span class="line">  #Skype: skype:yourname?call|chat || skype</span><br><span class="line"></span><br><span class="line">social_icons:</span><br><span class="line">  enable: true</span><br><span class="line">  icons_only: false</span><br><span class="line">  transition: false</span><br><span class="line"></span><br><span class="line"># Blog rolls</span><br><span class="line">links_icon: link</span><br><span class="line">links_title: Links</span><br><span class="line">links_layout: block</span><br><span class="line">#links_layout: inline</span><br><span class="line">#links:</span><br><span class="line">  #Title: http://example.com/</span><br><span class="line"></span><br><span class="line"># Sidebar Avatar</span><br><span class="line"># in theme directory(source/images): /images/avatar.gif</span><br><span class="line"># in site  directory(source/uploads): /uploads/avatar.gif</span><br><span class="line">avatar: /images/author.png</span><br><span class="line"></span><br><span class="line"># Table Of Contents in the Sidebar</span><br><span class="line">toc:</span><br><span class="line">  enable: true</span><br><span class="line"></span><br><span class="line">  # Automatically add list number to toc.</span><br><span class="line">  number: true</span><br><span class="line"></span><br><span class="line">  # If true, all words will placed on next lines if header width longer then sidebar width.</span><br><span class="line">  wrap: false</span><br><span class="line"></span><br><span class="line"># Creative Commons 4.0 International License.</span><br><span class="line"># http://creativecommons.org/</span><br><span class="line"># Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero</span><br><span class="line">#creative_commons: by-nc-sa</span><br><span class="line">#creative_commons:</span><br><span class="line"></span><br><span class="line">sidebar:</span><br><span class="line">  # Sidebar Position, available value: left | right (only for Pisces | Gemini).</span><br><span class="line">  position: left</span><br><span class="line">  #position: right</span><br><span class="line"></span><br><span class="line">  # Sidebar Display, available value (only for Muse | Mist):</span><br><span class="line">  #  - post    expand on posts automatically. Default.</span><br><span class="line">  #  - always  expand for all pages automatically</span><br><span class="line">  #  - hide    expand only when click on the sidebar toggle icon.</span><br><span class="line">  #  - remove  Totally remove sidebar including sidebar toggle.</span><br><span class="line">  display: post</span><br><span class="line">  #display: always</span><br><span class="line">  #display: hide</span><br><span class="line">  #display: remove</span><br><span class="line"></span><br><span class="line">  # Sidebar offset from top menubar in pixels (only for Pisces | Gemini).</span><br><span class="line">  offset: 12</span><br><span class="line"></span><br><span class="line">  # Back to top in sidebar (only for Pisces | Gemini).</span><br><span class="line">  b2t: false</span><br><span class="line"></span><br><span class="line">  # Scroll percent label in b2t button.</span><br><span class="line">  scrollpercent: false</span><br><span class="line"></span><br><span class="line">  # Enable sidebar on narrow view (only for Muse | Mist).</span><br><span class="line">  onmobile: false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Post Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># Automatically scroll page to section which is under &lt;!-- more --&gt; mark.</span><br><span class="line">scroll_to_more: true</span><br><span class="line"></span><br><span class="line"># Automatically saving scroll position on each post/page in cookies.</span><br><span class="line">save_scroll: false</span><br><span class="line"></span><br><span class="line"># Automatically excerpt description in homepage as preamble text.</span><br><span class="line">excerpt_description: true</span><br><span class="line"></span><br><span class="line"># Automatically Excerpt. Not recommend.</span><br><span class="line"># Please use &lt;!-- more --&gt; in the post to control excerpt accurately.</span><br><span class="line">auto_excerpt:</span><br><span class="line">  enable: false</span><br><span class="line">  length: 150</span><br><span class="line"></span><br><span class="line"># Post meta display settings</span><br><span class="line">post_meta:</span><br><span class="line">  item_text: true</span><br><span class="line">  created_at: true</span><br><span class="line">  updated_at: false</span><br><span class="line">  categories: true</span><br><span class="line"></span><br><span class="line"># Post wordcount display settings</span><br><span class="line"># Dependencies: https://github.com/willin/hexo-wordcount</span><br><span class="line">post_wordcount:</span><br><span class="line">  item_text: true</span><br><span class="line">  wordcount: false</span><br><span class="line">  min2read: false</span><br><span class="line">  totalcount: false</span><br><span class="line">  separated_meta: true</span><br><span class="line"></span><br><span class="line"># Wechat Subscriber</span><br><span class="line">#wechat_subscriber:</span><br><span class="line">  #enabled: true</span><br><span class="line">  #qcode: /path/to/your/wechatqcode ex. /uploads/wechat-qcode.jpg</span><br><span class="line">  #description: ex. subscribe to my blog by scanning my public wechat account</span><br><span class="line"></span><br><span class="line"># Reward</span><br><span class="line">#reward_comment: Donate comment here</span><br><span class="line">#wechatpay: /images/wechatpay.jpg</span><br><span class="line">#alipay: /images/alipay.jpg</span><br><span class="line">#bitcoin: /images/bitcoin.png</span><br><span class="line"></span><br><span class="line"># Declare license on posts</span><br><span class="line">post_copyright:</span><br><span class="line">  enable: false</span><br><span class="line">  license: CC BY-NC-SA 3.0</span><br><span class="line">  license_url: https://creativecommons.org/licenses/by-nc-sa/3.0/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Misc Theme Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># Reduce padding / margin indents on devices with narrow width.</span><br><span class="line">mobile_layout_economy: false</span><br><span class="line"></span><br><span class="line"># Android Chrome header panel color ($black-deep).</span><br><span class="line">android_chrome_color: &quot;#222&quot;</span><br><span class="line"></span><br><span class="line"># Custom Logo.</span><br><span class="line"># !!Only available for Default Scheme currently.</span><br><span class="line"># Options:</span><br><span class="line">#   enabled: [true/false] - Replace with specific image</span><br><span class="line">#   image: url-of-image   - Images&apos;s url</span><br><span class="line">custom_logo:</span><br><span class="line">  enabled: false</span><br><span class="line">  image:</span><br><span class="line"></span><br><span class="line"># Code Highlight theme</span><br><span class="line"># Available value:</span><br><span class="line">#    normal | night | night eighties | night blue | night bright</span><br><span class="line"># https://github.com/chriskempson/tomorrow-theme</span><br><span class="line">highlight_theme: normal</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Font Settings</span><br><span class="line"># - Find fonts on Google Fonts (https://www.google.com/fonts)</span><br><span class="line"># - All fonts set here will have the following styles:</span><br><span class="line">#     light, light italic, normal, normal italic, bold, bold italic</span><br><span class="line"># - Be aware that setting too much fonts will cause site running slowly</span><br><span class="line"># - Introduce in 5.0.1</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># CAUTION! Safari Version 10.1.2 bug: https://github.com/iissnan/hexo-theme-next/issues/1844</span><br><span class="line"># To avoid space between header and sidebar in Pisces / Gemini themes recommended to use Web Safe fonts for `global` (and `logo`):</span><br><span class="line"># Arial | Tahoma | Helvetica | Times New Roman | Courier New | Verdana | Georgia | Palatino | Garamond | Comic Sans MS | Trebuchet MS</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line">font:</span><br><span class="line">  enable: false</span><br><span class="line"></span><br><span class="line">  # Uri of fonts host. E.g. //fonts.googleapis.com (Default).</span><br><span class="line">  host:</span><br><span class="line"></span><br><span class="line">  # Font options:</span><br><span class="line">  # `external: true` will load this font family from `host` above.</span><br><span class="line">  # `family: Times New Roman`. Without any quotes.</span><br><span class="line">  # `size: xx`. Use `px` as unit.</span><br><span class="line"></span><br><span class="line">  # Global font settings used on &lt;body&gt; element.</span><br><span class="line">  global:</span><br><span class="line">    external: true</span><br><span class="line">    family: Lato</span><br><span class="line">    size:</span><br><span class="line"></span><br><span class="line">  # Font settings for Headlines (h1, h2, h3, h4, h5, h6).</span><br><span class="line">  # Fallback to `global` font settings.</span><br><span class="line">  headings:</span><br><span class="line">    external: true</span><br><span class="line">    family:</span><br><span class="line">    size:</span><br><span class="line"></span><br><span class="line">  # Font settings for posts.</span><br><span class="line">  # Fallback to `global` font settings.</span><br><span class="line">  posts:</span><br><span class="line">    external: true</span><br><span class="line">    family:</span><br><span class="line"></span><br><span class="line">  # Font settings for Logo.</span><br><span class="line">  # Fallback to `global` font settings.</span><br><span class="line">  logo:</span><br><span class="line">    external: true</span><br><span class="line">    family:</span><br><span class="line">    size:</span><br><span class="line"></span><br><span class="line">  # Font settings for &lt;code&gt; and code blocks.</span><br><span class="line">  codes:</span><br><span class="line">    external: true</span><br><span class="line">    family:</span><br><span class="line">    size:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Third Party Services Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># MathJax Support</span><br><span class="line">mathjax:</span><br><span class="line">  enable: false</span><br><span class="line">  per_page: false</span><br><span class="line">  cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML</span><br><span class="line"></span><br><span class="line"># Han Support docs: https://hanzi.pro/</span><br><span class="line">han: false</span><br><span class="line"></span><br><span class="line"># Swiftype Search API Key</span><br><span class="line"> #swiftype_key: jYY_fsKS5TYycYSCJas6</span><br><span class="line"></span><br><span class="line"># Baidu Analytics ID</span><br><span class="line">baidu_analytics: f7d714ed33bfd150a4e166afae0d03d3</span><br><span class="line"></span><br><span class="line"># Duoshuo ShortName</span><br><span class="line">#duoshuo_shortname:</span><br><span class="line"></span><br><span class="line"># Disqus</span><br><span class="line">disqus:</span><br><span class="line">  enable: false</span><br><span class="line">  shortname:</span><br><span class="line">  count: true</span><br><span class="line"></span><br><span class="line"># Hypercomments</span><br><span class="line">#hypercomments_id:</span><br><span class="line"></span><br><span class="line"># changyan</span><br><span class="line">changyan:</span><br><span class="line">  enable: true</span><br><span class="line">  appid: cyto4vUae</span><br><span class="line">  appkey: fbae73d15fb09500171cf0adae584a71</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Valine.</span><br><span class="line"># You can get your appid and appkey from https://leancloud.cn</span><br><span class="line"># more info please open https://valine.js.org</span><br><span class="line">valine:</span><br><span class="line">  enable: false</span><br><span class="line">  appid:  # your leancloud application appid</span><br><span class="line">  appkey:  # your leancloud application appkey</span><br><span class="line">  notify: false # mail notifier , https://github.com/xCss/Valine/wiki</span><br><span class="line">  verify: false # Verification code</span><br><span class="line">  placeholder: Just go go # comment box placeholder</span><br><span class="line">  avatar: mm # gravatar style</span><br><span class="line">  guest_info: nick,mail,link # custom comment header</span><br><span class="line">  pageSize: 10 # pagination size</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Support for youyan comments system.</span><br><span class="line"># You can get your uid from http://www.uyan.cc</span><br><span class="line">#youyan_uid: your uid</span><br><span class="line"></span><br><span class="line"># Support for LiveRe comments system.</span><br><span class="line"># You can get your uid from https://livere.com/insight/myCode (General web site)</span><br><span class="line">#livere_uid: your uid</span><br><span class="line"></span><br><span class="line"># Gitment</span><br><span class="line"># Introduction: https://imsun.net/posts/gitment-introduction/</span><br><span class="line"># You can get your Github ID from https://api.github.com/users/&lt;Github username&gt;</span><br><span class="line">gitment:</span><br><span class="line">  enable: false</span><br><span class="line">  mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway</span><br><span class="line">  count: true # Show comments count in post meta area</span><br><span class="line">  lazy: false # Comments lazy loading with a button</span><br><span class="line">  cleanly: false # Hide &apos;Powered by ...&apos; on footer, and more</span><br><span class="line">  language: # Force language, or auto switch by theme</span><br><span class="line">  github_user: # MUST HAVE, Your Github ID</span><br><span class="line">  github_repo: # MUST HAVE, The repo you use to store Gitment comments</span><br><span class="line">  client_id: # MUST HAVE, Github client id for the Gitment</span><br><span class="line">  client_secret: # EITHER this or proxy_gateway, Github access secret token for the Gitment</span><br><span class="line">  proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect</span><br><span class="line">  redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled</span><br><span class="line"></span><br><span class="line"># Baidu Share</span><br><span class="line"># Available value:</span><br><span class="line">#    button | slide</span><br><span class="line"># Warning: Baidu Share does not support https.</span><br><span class="line">baidushare: true</span><br><span class="line">type: button</span><br><span class="line"></span><br><span class="line"># Share</span><br><span class="line"># This plugin is more useful in China, make sure you known how to use it.</span><br><span class="line"># And you can find the use guide at official webiste: http://www.jiathis.com/.</span><br><span class="line"># Warning: JiaThis does not support https.</span><br><span class="line">#jiathis:</span><br><span class="line">  ##uid: Get this uid from http://www.jiathis.com/</span><br><span class="line">#add_this_id:</span><br><span class="line"></span><br><span class="line"># Share</span><br><span class="line">#duoshuo_share: true</span><br><span class="line"></span><br><span class="line"># NeedMoreShare2</span><br><span class="line"># This plugin is a pure javascript sharing lib which is useful in China.</span><br><span class="line"># See: https://github.com/revir/need-more-share2</span><br><span class="line"># Also see: https://github.com/DzmVasileusky/needShareButton</span><br><span class="line"># iconStyle: default | box</span><br><span class="line"># boxForm: horizontal | vertical</span><br><span class="line"># position: top / middle / bottom + Left / Center / Right</span><br><span class="line"># networks: Weibo,Wechat,Douban,QQZone,Twitter,Linkedin,Mailto,Reddit,</span><br><span class="line">#           Delicious,StumbleUpon,Pinterest,Facebook,GooglePlus,Slashdot,</span><br><span class="line">#           Technorati,Posterous,Tumblr,GoogleBookmarks,Newsvine,</span><br><span class="line">#           Evernote,Friendfeed,Vkontakte,Odnoklassniki,Mailru</span><br><span class="line">needmoreshare2:</span><br><span class="line">  enable: false</span><br><span class="line">  postbottom:</span><br><span class="line">    enable: false</span><br><span class="line">    options:</span><br><span class="line">      iconStyle: box</span><br><span class="line">      boxForm: horizontal</span><br><span class="line">      position: bottomCenter</span><br><span class="line">      networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook</span><br><span class="line">  float:</span><br><span class="line">    enable: false</span><br><span class="line">    options:</span><br><span class="line">      iconStyle: box</span><br><span class="line">      boxForm: horizontal</span><br><span class="line">      position: middleRight</span><br><span class="line">      networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook</span><br><span class="line"></span><br><span class="line"># Google Webmaster tools verification setting</span><br><span class="line"># See: https://www.google.com/webmasters/</span><br><span class="line">#google_site_verification:</span><br><span class="line"></span><br><span class="line"># Google Analytics</span><br><span class="line">#google_analytics:</span><br><span class="line"></span><br><span class="line"># Bing Webmaster tools verification setting</span><br><span class="line"># See: https://www.bing.com/webmaster/</span><br><span class="line">#bing_site_verification:</span><br><span class="line"></span><br><span class="line"># Yandex Webmaster tools verification setting</span><br><span class="line"># See: https://webmaster.yandex.ru/</span><br><span class="line">#yandex_site_verification:</span><br><span class="line"></span><br><span class="line"># CNZZ count</span><br><span class="line">#cnzz_siteid:</span><br><span class="line"></span><br><span class="line"># Application Insights</span><br><span class="line"># See https://azure.microsoft.com/en-us/services/application-insights/</span><br><span class="line"># application_insights:</span><br><span class="line"></span><br><span class="line"># Make duoshuo show UA</span><br><span class="line"># user_id must NOT be null when admin_enable is true!</span><br><span class="line"># you can visit http://dev.duoshuo.com get duoshuo user id.</span><br><span class="line">duoshuo_info:</span><br><span class="line">  ua_enable: true</span><br><span class="line">  admin_enable: false</span><br><span class="line">  user_id: 0</span><br><span class="line">  #admin_nickname: Author</span><br><span class="line"></span><br><span class="line"># Post widgets &amp; FB/VK comments settings.</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Facebook SDK Support.</span><br><span class="line"># https://github.com/iissnan/hexo-theme-next/pull/410</span><br><span class="line">facebook_sdk:</span><br><span class="line">  enable:       false</span><br><span class="line">  app_id:       #&lt;app_id&gt;</span><br><span class="line">  fb_admin:     #&lt;user_id&gt;</span><br><span class="line">  like_button:  #true</span><br><span class="line">  webmaster:    #true</span><br><span class="line"></span><br><span class="line"># Facebook comments plugin</span><br><span class="line"># This plugin depends on Facebook SDK.</span><br><span class="line"># If facebook_sdk.enable is false, Facebook comments plugin is unavailable.</span><br><span class="line">facebook_comments_plugin:</span><br><span class="line">  enable:       false</span><br><span class="line">  num_of_posts: 10    # min posts num is 1</span><br><span class="line">  width:        100%  # default width is 550px</span><br><span class="line">  scheme:       light # default scheme is light (light or dark)</span><br><span class="line"></span><br><span class="line"># VKontakte API Support.</span><br><span class="line"># To get your AppID visit https://vk.com/editapp?act=create</span><br><span class="line">vkontakte_api:</span><br><span class="line">  enable:       false</span><br><span class="line">  app_id:       #&lt;app_id&gt;</span><br><span class="line">  like:         true</span><br><span class="line">  comments:     true</span><br><span class="line">  num_of_posts: 10</span><br><span class="line"></span><br><span class="line"># Star rating support to each article.</span><br><span class="line"># To get your ID visit https://widgetpack.com</span><br><span class="line">rating:</span><br><span class="line">  enable: false</span><br><span class="line">  id:     #&lt;app_id&gt;</span><br><span class="line">  color:  fc6423</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># Show number of visitors to each article.</span><br><span class="line"># You can visit https://leancloud.cn get AppID and AppKey.</span><br><span class="line">leancloud_visitors:</span><br><span class="line">  enable: false</span><br><span class="line">  app_id: #&lt;app_id&gt;</span><br><span class="line">  app_key: #&lt;app_key&gt;</span><br><span class="line"></span><br><span class="line"># Another tool to show number of visitors to each article.</span><br><span class="line"># visit https://console.firebase.google.com/u/0/ to get apiKey and projectId</span><br><span class="line"># visit https://firebase.google.com/docs/firestore/ to get more information about firestore</span><br><span class="line">firestore:</span><br><span class="line">  enable: false</span><br><span class="line">  collection: articles #required, a string collection name to access firestore database</span><br><span class="line">  apiKey: #required</span><br><span class="line">  projectId: #required</span><br><span class="line">  bluebird: false #enable this if you want to include bluebird 3.5.1(core version) Promise polyfill</span><br><span class="line"></span><br><span class="line"># Show PV/UV of the website/page with busuanzi.</span><br><span class="line"># Get more information on http://ibruce.info/2015/04/04/busuanzi/</span><br><span class="line">busuanzi_count:</span><br><span class="line">  # count values only if the other configs are false</span><br><span class="line">  enable: true</span><br><span class="line">  # custom uv span for the whole site</span><br><span class="line">  site_uv: true</span><br><span class="line">  site_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt;</span><br><span class="line">  site_uv_footer:</span><br><span class="line">  # custom pv span for the whole site</span><br><span class="line">  site_pv: true</span><br><span class="line">  site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt;</span><br><span class="line">  site_pv_footer:</span><br><span class="line">  # custom pv span for one page only</span><br><span class="line">  page_pv: true</span><br><span class="line">  page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt;</span><br><span class="line">  page_pv_footer:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Tencent analytics ID</span><br><span class="line"># tencent_analytics:</span><br><span class="line"></span><br><span class="line"># Tencent MTA ID</span><br><span class="line"># tencent_mta:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEO</span><br><span class="line">baidu_push: false</span><br><span class="line"></span><br><span class="line"># Google Calendar</span><br><span class="line"># Share your recent schedule to others via calendar page</span><br><span class="line">#</span><br><span class="line"># API Documentation:</span><br><span class="line"># https://developers.google.com/google-apps/calendar/v3/reference/events/list</span><br><span class="line">calendar:</span><br><span class="line">  enable: false</span><br><span class="line">  calendar_id: &lt;required&gt;</span><br><span class="line">  api_key: &lt;required&gt;</span><br><span class="line">  orderBy: startTime</span><br><span class="line">  offsetMax: 24</span><br><span class="line">  offsetMin: 4</span><br><span class="line">  timeZone:</span><br><span class="line">  showDeleted: false</span><br><span class="line">  singleEvents: true</span><br><span class="line">  maxResults: 250</span><br><span class="line"></span><br><span class="line"># Algolia Search</span><br><span class="line">algolia_search:</span><br><span class="line">  enable: false</span><br><span class="line">  hits:</span><br><span class="line">    per_page: 10</span><br><span class="line">  labels:</span><br><span class="line">    input_placeholder: Search for Posts</span><br><span class="line">    hits_empty: &quot;We didn&apos;t find any results for the search: $&#123;query&#125;&quot;</span><br><span class="line">    hits_stats: &quot;$&#123;hits&#125; results found in $&#123;time&#125; ms&quot;</span><br><span class="line"></span><br><span class="line"># Local search</span><br><span class="line"># Dependencies: https://github.com/flashlab/hexo-generator-search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # if auto, trigger search by changing input</span><br><span class="line">  # if manual, trigger search by pressing enter key or search button</span><br><span class="line">  trigger: auto</span><br><span class="line">  # show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Tags Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># External URL with BASE64 encrypt &amp; decrypt.</span><br><span class="line"># Usage: &#123;% exturl text url &quot;title&quot; %&#125;</span><br><span class="line"># Alias: &#123;% extlink text url &quot;title&quot; %&#125;</span><br><span class="line">exturl: false</span><br><span class="line"></span><br><span class="line"># Note tag (bs-callout).</span><br><span class="line">note:</span><br><span class="line">  # Note tag style values:</span><br><span class="line">  #  - simple    bs-callout old alert style. Default.</span><br><span class="line">  #  - modern    bs-callout new (v2-v3) alert style.</span><br><span class="line">  #  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span><br><span class="line">  #  - disabled  disable all CSS styles import of note tag.</span><br><span class="line">  style: simple</span><br><span class="line">  icons: false</span><br><span class="line">  border_radius: 3</span><br><span class="line">  # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span><br><span class="line">  # Offset also applied to label tag variables. This option can work with disabled note tag.</span><br><span class="line">  light_bg_offset: 0</span><br><span class="line"></span><br><span class="line"># Label tag.</span><br><span class="line">label: true</span><br><span class="line"></span><br><span class="line"># Tabs tag.</span><br><span class="line">tabs:</span><br><span class="line">  enable: true</span><br><span class="line">  transition:</span><br><span class="line">    tabs: false</span><br><span class="line">    labels: true</span><br><span class="line">  border_radius: 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#! ---------------------------------------------------------------</span><br><span class="line">#! DO NOT EDIT THE FOLLOWING SETTINGS</span><br><span class="line">#! UNLESS YOU KNOW WHAT YOU ARE DOING</span><br><span class="line">#! ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># Use velocity to animate everything.</span><br><span class="line">motion:</span><br><span class="line">  enable: true</span><br><span class="line">  async: false</span><br><span class="line">  transition:</span><br><span class="line">    # Transition variants:</span><br><span class="line">    # fadeIn | fadeOut | flipXIn | flipXOut | flipYIn | flipYOut | flipBounceXIn | flipBounceXOut | flipBounceYIn | flipBounceYOut</span><br><span class="line">    # swoopIn | swoopOut | whirlIn | whirlOut | shrinkIn | shrinkOut | expandIn | expandOut</span><br><span class="line">    # bounceIn | bounceOut | bounceUpIn | bounceUpOut | bounceDownIn | bounceDownOut | bounceLeftIn | bounceLeftOut | bounceRightIn | bounceRightOut</span><br><span class="line">    # slideUpIn | slideUpOut | slideDownIn | slideDownOut | slideLeftIn | slideLeftOut | slideRightIn | slideRightOut</span><br><span class="line">    # slideUpBigIn | slideUpBigOut | slideDownBigIn | slideDownBigOut | slideLeftBigIn | slideLeftBigOut | slideRightBigIn | slideRightBigOut</span><br><span class="line">    # perspectiveUpIn | perspectiveUpOut | perspectiveDownIn | perspectiveDownOut | perspectiveLeftIn | perspectiveLeftOut | perspectiveRightIn | perspectiveRightOut</span><br><span class="line">    post_block: fadeIn</span><br><span class="line">    post_header: slideDownIn</span><br><span class="line">    post_body: slideDownIn</span><br><span class="line">    coll_header: slideLeftIn</span><br><span class="line">    # Only for Pisces | Gemini.</span><br><span class="line">    sidebar: slideUpIn</span><br><span class="line"></span><br><span class="line"># Fancybox</span><br><span class="line">fancybox: true</span><br><span class="line"></span><br><span class="line"># Progress bar in the top during page loading.</span><br><span class="line">pace: false</span><br><span class="line"># Themes list:</span><br><span class="line">#pace-theme-big-counter</span><br><span class="line">#pace-theme-bounce</span><br><span class="line">#pace-theme-barber-shop</span><br><span class="line">#pace-theme-center-atom</span><br><span class="line">#pace-theme-center-circle</span><br><span class="line">#pace-theme-center-radar</span><br><span class="line">#pace-theme-center-simple</span><br><span class="line">#pace-theme-corner-indicator</span><br><span class="line">#pace-theme-fill-left</span><br><span class="line">#pace-theme-flash</span><br><span class="line">#pace-theme-loading-bar</span><br><span class="line">#pace-theme-mac-osx</span><br><span class="line">#pace-theme-minimal</span><br><span class="line"># For example</span><br><span class="line"># pace_theme: pace-theme-center-simple</span><br><span class="line">pace_theme: pace-theme-minimal</span><br><span class="line"></span><br><span class="line"># Canvas-nest</span><br><span class="line">canvas_nest: false</span><br><span class="line"></span><br><span class="line"># three_waves</span><br><span class="line">three_waves: false</span><br><span class="line"></span><br><span class="line"># canvas_lines</span><br><span class="line">canvas_lines: false</span><br><span class="line"></span><br><span class="line"># canvas_sphere</span><br><span class="line">canvas_sphere: false</span><br><span class="line"></span><br><span class="line"># Only fit scheme Pisces</span><br><span class="line"># Canvas-ribbon</span><br><span class="line"># size: The width of the ribbon.</span><br><span class="line"># alpha: The transparency of the ribbon.</span><br><span class="line"># zIndex: The display level of the ribbon.</span><br><span class="line">canvas_ribbon:</span><br><span class="line">  enable: false</span><br><span class="line">  size: 300</span><br><span class="line">  alpha: 0.6</span><br><span class="line">  zIndex: -1</span><br><span class="line"></span><br><span class="line"># Script Vendors.</span><br><span class="line"># Set a CDN address for the vendor you want to customize.</span><br><span class="line"># For example</span><br><span class="line">#    jquery: https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js</span><br><span class="line"># Be aware that you should use the same version as internal ones to avoid potential problems.</span><br><span class="line"># Please use the https protocol of CDN files when you enable https on your site.</span><br><span class="line">vendors:</span><br><span class="line">  # Internal path prefix. Please do not edit it.</span><br><span class="line">  _internal: lib</span><br><span class="line"></span><br><span class="line">  # Internal version: 2.1.3</span><br><span class="line">  jquery:</span><br><span class="line"></span><br><span class="line">  # Internal version: 2.1.5</span><br><span class="line">  # See: http://fancyapps.com/fancybox/</span><br><span class="line">  fancybox:</span><br><span class="line">  fancybox_css:</span><br><span class="line"></span><br><span class="line">  # Internal version: 1.0.6</span><br><span class="line">  # See: https://github.com/ftlabs/fastclick</span><br><span class="line">  fastclick:</span><br><span class="line"></span><br><span class="line">  # Internal version: 1.9.7</span><br><span class="line">  # See: https://github.com/tuupola/jquery_lazyload</span><br><span class="line">  lazyload:</span><br><span class="line"></span><br><span class="line">  # Internal version: 1.2.1</span><br><span class="line">  # See: http://VelocityJS.org</span><br><span class="line">  velocity:</span><br><span class="line"></span><br><span class="line">  # Internal version: 1.2.1</span><br><span class="line">  # See: http://VelocityJS.org</span><br><span class="line">  velocity_ui:</span><br><span class="line"></span><br><span class="line">  # Internal version: 0.7.9</span><br><span class="line">  # See: https://faisalman.github.io/ua-parser-js/</span><br><span class="line">  ua_parser:</span><br><span class="line"></span><br><span class="line">  # Internal version: 4.6.2</span><br><span class="line">  # See: http://fontawesome.io/</span><br><span class="line">  fontawesome:</span><br><span class="line"></span><br><span class="line">  # Internal version: 1</span><br><span class="line">  # https://www.algolia.com</span><br><span class="line">  algolia_instant_js:</span><br><span class="line">  algolia_instant_css:</span><br><span class="line"></span><br><span class="line">  # Internal version: 1.0.2</span><br><span class="line">  # See: https://github.com/HubSpot/pace</span><br><span class="line">  # Or use direct links below:</span><br><span class="line">  # pace: //cdn.bootcss.com/pace/1.0.2/pace.min.js</span><br><span class="line">  # pace_css: //cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css</span><br><span class="line">  pace:</span><br><span class="line">  pace_css:</span><br><span class="line"></span><br><span class="line">  # Internal version: 1.0.0</span><br><span class="line">  # https://github.com/hustcc/canvas-nest.js</span><br><span class="line">  canvas_nest:</span><br><span class="line"></span><br><span class="line">  # three</span><br><span class="line">  three:</span><br><span class="line"></span><br><span class="line">  # three_waves</span><br><span class="line">  # https://github.com/jjandxa/three_waves</span><br><span class="line">  three_waves:</span><br><span class="line"></span><br><span class="line">  # three_waves</span><br><span class="line">  # https://github.com/jjandxa/canvas_lines</span><br><span class="line">  canvas_lines:</span><br><span class="line"></span><br><span class="line">  # three_waves</span><br><span class="line">  # https://github.com/jjandxa/canvas_sphere</span><br><span class="line">  canvas_sphere:</span><br><span class="line"></span><br><span class="line">  # Internal version: 1.0.0</span><br><span class="line">  # https://github.com/zproo/canvas-ribbon</span><br><span class="line">  canvas_ribbon:</span><br><span class="line"></span><br><span class="line">  # Internal version: 3.3.0</span><br><span class="line">  # https://github.com/ethantw/Han</span><br><span class="line">  han:</span><br><span class="line"></span><br><span class="line">  # needMoreShare2</span><br><span class="line">  # https://github.com/revir/need-more-share2</span><br><span class="line">  needMoreShare2:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Assets</span><br><span class="line">css: css</span><br><span class="line">js: js</span><br><span class="line">images: images</span><br><span class="line"></span><br><span class="line"># Theme version</span><br><span class="line">version: 5.1.4</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>next主题</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2019/08/07/oneMall%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="oneMall项目环境"><a href="#oneMall项目环境" class="headerlink" title="oneMall项目环境"></a>oneMall项目环境</h1><h3 id="Mysql5-7"><a href="#Mysql5-7" class="headerlink" title="Mysql5.7"></a>Mysql5.7</h3><p>安装位置: 192.168.1.34(虚拟机)<br>安装方式: docker<br>用户名: root<br>密码: 123456<br>端口  13306：3306（docker中Mysql端口采用的默认3306,映射外部端口未13306）</p>
<h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><p>安装位置: 192.168.1.34(虚拟机)<br>安装方式: docker<br>端口: 2181</p>
<h3 id="RocketMq"><a href="#RocketMq" class="headerlink" title="RocketMq"></a>RocketMq</h3><p>安装位置: 192.168.1.34(虚拟机)<br>安装方式: 直接安装（/root/rocketmq)<br>端口: 9876</p>
<h3 id="elasticsearch2-5"><a href="#elasticsearch2-5" class="headerlink" title="elasticsearch2.5"></a>elasticsearch2.5</h3><p>安装位置: 192.168.1.34(虚拟机)<br>安装方式: 直接安装<br>端口: 9200<br>安装的插件:  elasticsearch-analyzer-ik(中文分词插件)</p>
]]></content>
  </entry>
  <entry>
    <title>linux文件系统</title>
    <url>/2019/08/07/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="Linux文件系统"><a href="#Linux文件系统" class="headerlink" title="Linux文件系统"></a>Linux文件系统</h1><h3 id="文件管理命令"><a href="#文件管理命令" class="headerlink" title="文件管理命令"></a>文件管理命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df -hl 查看磁盘剩余空间</span><br><span class="line"></span><br><span class="line">df -h 查看每个根路径的分区大小</span><br><span class="line"></span><br><span class="line">du -sh [目录名] 返回该目录的大小</span><br><span class="line"></span><br><span class="line">du -sm [文件夹] 返回该文件夹总M数</span><br><span class="line"></span><br><span class="line">du -h [目录名] 查看指定文件夹下的所有文件大小（包含子文件夹）</span><br><span class="line"></span><br><span class="line">查看硬盘的分区 #sudo fdisk -l</span><br><span class="line"></span><br><span class="line">查看IDE硬盘信息 #sudo hdparm -i /dev/hda</span><br><span class="line"></span><br><span class="line">查看STAT硬盘信息 #sudo hdparm -I /dev/sda 或 #sudo apt-get install blktool #sudo blktool /dev/sda id</span><br><span class="line"></span><br><span class="line">查看硬盘剩余空间 #df -h #df -H</span><br><span class="line"></span><br><span class="line">查看目录占用空间 #du -hs 目录名</span><br><span class="line"></span><br><span class="line">优盘没法卸载 #sync fuser -km /media/usbdisk</span><br></pre></td></tr></table></figure>
<ol>
<li><p>查看磁盘剩余空间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[root@iZ3i4n96yv24gsZ collector]# df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/vda1       <span class="number">158</span>G   <span class="number">20</span>G  <span class="number">131</span>G  <span class="number">13</span>% /</span><br><span class="line">devtmpfs        <span class="number">7.8</span>G     <span class="number">0</span>  <span class="number">7.8</span>G   <span class="number">0</span>% /dev</span><br><span class="line">tmpfs           <span class="number">7.8</span>G     <span class="number">0</span>  <span class="number">7.8</span>G   <span class="number">0</span>% /dev/shm</span><br><span class="line">tmpfs           <span class="number">7.8</span>G  <span class="number">656</span>K  <span class="number">7.8</span>G   <span class="number">1</span>% /run</span><br><span class="line">tmpfs           <span class="number">7.8</span>G     <span class="number">0</span>  <span class="number">7.8</span>G   <span class="number">0</span>% /sys/fs/cgroup</span><br><span class="line">tmpfs           <span class="number">1.6</span>G     <span class="number">0</span>  <span class="number">1.6</span>G   <span class="number">0</span>% /run/user/<span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看目录各个文件占用的大小</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@iZ3i4n96yv24gsZ usr]# du -sh *</span><br><span class="line">  513M    bin</span><br><span class="line">  4.0K    etc</span><br><span class="line">  4.0K    games</span><br><span class="line">  9.6M    include</span><br><span class="line">  369M    java</span><br><span class="line">  571M    lib</span><br><span class="line">  378M    lib64</span><br><span class="line">  48M     libexec</span><br><span class="line">  2.6G    local</span><br><span class="line">  464M    sbin</span><br><span class="line">  306M    share</span><br><span class="line">  105M    src</span><br><span class="line">  0       tmp</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2019/08/07/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p> 查看端口占用情况<br>netstat -tunlp |grep 8082</p>
<p>jar包后台运行<br>$ nohup java -Dfile.encoding=utf-8 -jar rr-api.jar  &amp;</p>
<p>//nohup 意思是不挂断运行命令,当账户退出或终端关闭时,程序仍然运行<br>//当用 nohup 命令执行作业时，缺省情况下该作业的所有输出被重定向到nohup.out的文件中<br>//除非另外指定了输出文件</p>
<p>jobs:  列出所有后台执行的作业，并且每个作业前面都有个编号。<br>$ jobs</p>
<p>kill -9 进程号 （杀死进程）</p>
<p>作业管理</p>
<ol>
<li>将“当前”作业放到后台“暂停”：ctrl+z </li>
<li>观察当前后台作业状态：</li>
<li><p>jobs参数：<br> -l 除了列出作业号之外同时列出PID<br> -r：列出仅在后台运行（run）的作业<br> -s：仅列出暂停的作业 </p>
</li>
<li><p>将后台作业拿到前台处理：<br> fg fg %jobnumber (%可有可无) </p>
</li>
<li><p>让作业在后台运行：<br> bgctrl+z让当前作业到后台去暂停，<br> bg 作业号就可以在后台run </p>
</li>
<li><p>管理后台作业：kill我们可以让一个已经在后台的作业继续执行，也可以让该作业使用fg拿到前台。如果直接删除该作业，或者让作业重启，需要给作业发送信号。<br>kill -signal %jobnumber参数：<br>kill -l 列出当前kill能够使用的信号signal：表示给后台的作业什么指示，用man 7 signal可知-1（数字）：重新读取一次参数的设置文件（类似reload）-2：表示与由键盘输入ctrl-c同样的动作-9：立刻强制删除一个作业-15：以正常方式终止一项作业。与-9不一样。</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>jenkins配置部署启动springboot项目</title>
    <url>/2019/08/07/jenkins%E9%85%8D%E7%BD%AE%E9%83%A8%E7%BD%B2%E5%90%AF%E5%8A%A8springboot%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h3 id="1-jenkins连接远程ssh服务器需要安装一个ssh-plugin插件"><a href="#1-jenkins连接远程ssh服务器需要安装一个ssh-plugin插件" class="headerlink" title="1. jenkins连接远程ssh服务器需要安装一个ssh plugin插件"></a>1. jenkins连接远程ssh服务器需要安装一个ssh plugin插件</h3><p><img src="http://blog.nilaile.cn/blog/20190611/sNQOB7HX5xgK.png" alt="mark"></p>
<h3 id="2-配置一个全局凭证-就是连接远程服务器的用户名密码"><a href="#2-配置一个全局凭证-就是连接远程服务器的用户名密码" class="headerlink" title="2. 配置一个全局凭证,就是连接远程服务器的用户名密码"></a>2. 配置一个全局凭证,就是连接远程服务器的用户名密码</h3><p><img src="http://blog.nilaile.cn/blog/20190611/J2v35kKCBQAg.png" alt="mark"></p>
<h3 id="3-在Jenkins系统设置–》SSH-remote-hosts–》下配置一个ssh服务器"><a href="#3-在Jenkins系统设置–》SSH-remote-hosts–》下配置一个ssh服务器" class="headerlink" title="3.在Jenkins系统设置–》SSH remote hosts–》下配置一个ssh服务器"></a>3.在Jenkins系统设置–》SSH remote hosts–》下配置一个ssh服务器</h3><p><img src="http://blog.nilaile.cn/blog/20190611/FiMYqpScLXsv.png" alt="mark"></p>
<h3 id="4-新建任务-输入要执行的脚本"><a href="#4-新建任务-输入要执行的脚本" class="headerlink" title="4. 新建任务,输入要执行的脚本"></a>4. 新建任务,输入要执行的脚本</h3><p><img src="http://blog.nilaile.cn/blog/20190611/woWNtKXfa6V2.png" alt="mark"></p>
<p>Jenkins配置的脚本：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo &quot;stop collector&quot;</span><br><span class="line">sh /home/deploy/stop.sh</span><br><span class="line">echo &quot;start collector&quot;</span><br><span class="line">sh /home/deploy/start.sh</span><br></pre></td></tr></table></figure></p>
<h3 id="stop-sh脚本如下"><a href="#stop-sh脚本如下" class="headerlink" title="stop.sh脚本如下"></a>stop.sh脚本如下</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo &quot;Stopping tooldin-mq&quot;</span><br><span class="line">pid=`ps -ef | grep admin.jar | grep -v grep | awk &apos;&#123;print $2&#125;&apos;`</span><br><span class="line">if [ -n &quot;$pid&quot; ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;kill -9 的pid:&quot; $pid</span><br><span class="line">   kill -9 $pid</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h3 id="start-sh脚本如下"><a href="#start-sh脚本如下" class="headerlink" title="start.sh脚本如下"></a>start.sh脚本如下</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">source /etc/profile # 注意这行代码</span><br><span class="line">nohup java  -Dfile.encoding=utf-8 -jar /home/deploy/admin.jar &gt; /usr/local/collector/admin.log &amp;</span><br></pre></td></tr></table></figure>
<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>在Jenkins中执行该新建的任务时,系统一直无法启动成功,stop.sh脚本确实执行成功了<br>但是项目一直未在后台启动成功</p>
<h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><ol>
<li>先是按照网上的教程更改了jenkins中配置的执行脚本,防止jenkins进程结束后杀死子进程,更改后测试无效<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">BUILD_ID=DONTKILLME</span><br><span class="line">echo &quot;stop collector&quot;</span><br><span class="line">sh /home/deploy/stop.sh</span><br><span class="line">echo &quot;start collector&quot;</span><br><span class="line">sh /home/deploy/start.sh</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="http://blog.nilaile.cn/blog/20190611/qlrYXcTwC80C.png" alt="mark"></p>
<ol start="2">
<li><p>然后把 start.sh 错误输出指向标准输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">nohup java -jar /home/deploy/admin.jar &gt; /home/deploy/admin.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后在jenkins中启动任务,然后cat admin.log中打印出了错误的日志</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nohup: failed to run command `java&apos;: No such file or directory</span><br></pre></td></tr></table></figure>
<p>看到这个错误，猜想多半是由于java未配置环境变量，但是服务器环境变量确实正常，输入java –version可以看到是能够正常响应的,最终只能在start.sh脚本中增加 <code>source /etc/profile</code></p>
<ol start="4">
<li>最后特别感谢饺子哥的帮助</li>
</ol>
]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins安装</title>
    <url>/2019/08/07/jenkins%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h4 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h4><blockquote>
<p>安装环境 centos7.5,jdk1.8<br>参考博客: <a href="https://www.jianshu.com/p/180fb11a5b96" target="_blank" rel="noopener">https://www.jianshu.com/p/180fb11a5b96</a></p>
</blockquote>
<h4 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h4><p>注意: 安装前需要确认一下系统是否已经安装并配置好java环境变量<br>1.下载依赖<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo</span><br></pre></td></tr></table></figure></p>
<p>2.导入秘钥<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key</span><br></pre></td></tr></table></figure></p>
<p>3.安装<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install jenkins</span><br></pre></td></tr></table></figure></p>
<p>4.查看安装路径<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -ql jenkins</span><br></pre></td></tr></table></figure></p>
<p>5.修改默认端口号<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi /etc/sysconfig/jenkins</span><br></pre></td></tr></table></figure></p>
<p>找到JENKINS_PORT=”8080”,修改为自己的端口号如8090</p>
<p>6.启动jenkins<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start jenkins</span><br></pre></td></tr></table></figure></p>
<p>7.如果启动报如下错误,需要修改jenkins的配置文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Starting Jenkins bash: /usr/bin/java: No such file or directory</span><br></pre></td></tr></table></figure></p>
<p>修改Jenkins启动配置文件，指定java安装路径。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim /etc/init.d/jenkins</span><br></pre></td></tr></table></figure></p>
<p>打开配置文件后找到candidates这行，在下面增加自己的java安装路径<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">candidates=&quot;</span><br><span class="line">/usr/java/jdk1.8/bin/java ## 这里 增加自己的java安装路径，下面的不用动</span><br><span class="line">/etc/alternatives/java</span><br><span class="line">/usr/lib/jvm/java-1.8.0/bin/java</span><br><span class="line">/usr/lib/jvm/jre-1.8.0/bin/java</span><br><span class="line">/usr/lib/jvm/java-1.7.0/bin/java</span><br><span class="line">/usr/lib/jvm/jre-1.7.0/bin/java</span><br><span class="line">/usr/bin/java</span><br><span class="line">&quot;</span><br></pre></td></tr></table></figure></p>
<p>相关目录说明<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jenkins相关目录释义：</span><br><span class="line">1. /usr/lib/jenkins/：jenkins安装目录，war包会放在这里。</span><br><span class="line">2. /etc/sysconfig/jenkins：jenkins配置文件，“端口”，“JENKINS_HOME”等都可以在这里配置。</span><br><span class="line">3. /var/lib/jenkins/：默认的JENKINS_HOME。</span><br><span class="line">4. /var/log/jenkins/jenkins.log：jenkins日志文件。</span><br><span class="line">5. /etc/init.d/jenkins： jenkins启动配置文件这里需要配置java安装目录</span><br></pre></td></tr></table></figure></p>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p>1.启动<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方法1: java -jar /usr/lib/jenkins/jenkins.war --httpPort=8090</span><br><span class="line">方法2： service jenkins start</span><br><span class="line">方法3: systemctl start jenkins</span><br></pre></td></tr></table></figure></p>
<p>浏览器访问 <a href="http://localhost:8090" target="_blank" rel="noopener">http://localhost:8090</a> 输入初始密码即可<br>初始密码路径位于<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/var/lib/jenkins/secrets/initialAdminPassword</span><br></pre></td></tr></table></figure></p>
<p>2.停止<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service jenkins stop</span><br></pre></td></tr></table></figure></p>
<p>3.查看运行状态<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service jenkins start</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>JAVA运维工具</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot以jar包启动,打包到测试服务器,中文乱码,数据库乱码</title>
    <url>/2019/08/07/jar%E5%8C%85%E5%90%AF%E5%8A%A8%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>原因<br>windows启动的jar的时候给Java虚拟机设置编码默认不是utf-8, 所以乱码,同时连接插入到数据库的很多数据也是乱码, linux系统的服务器编码默认是utf-8，对于是windows的服务器默认不是utf-8。所以在启动的时候需要设置编码方式。</p>
<p>解决方案: 启动jar包时设置编码<br>如下所示：java -Dfile.encoding=utf=8 -<br><code>java -Dfile.encoding=utf-8 -jar rr-api.jar</code></p>
]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>中文乱码</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker远程连接配置</title>
    <url>/2019/08/07/docker%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="无CA认证方式-不安全-建议用于测试环境）"><a href="#无CA认证方式-不安全-建议用于测试环境）" class="headerlink" title="无CA认证方式(不安全,建议用于测试环境）"></a>无CA认证方式(不安全,建议用于测试环境）</h2><ol>
<li><p>修改服务器配置，开放Docker的远程连接访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim /usr/lib/systemd/system/docker.service </span><br><span class="line">将ExecStart属性value值改为</span><br><span class="line">/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix://var/run/docker.sock</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启docker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# systemctl daemon-reload </span><br><span class="line">[root@localhost ~]# systemctl restart docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启阿里云和本地的防火墙中 放行2375 端口</p>
</li>
<li><p>远程通过IDEA测试OK</p>
</li>
</ol>
<h2 id="CA-认证方式-安全访问方式适用于生产环境"><a href="#CA-认证方式-安全访问方式适用于生产环境" class="headerlink" title="CA 认证方式(安全访问方式适用于生产环境)"></a>CA 认证方式(安全访问方式适用于生产环境)</h2><h3 id="文件总览"><a href="#文件总览" class="headerlink" title="文件总览"></a>文件总览</h3><p>├── ca-key.pem       # 妥善保管，连接时用不到<br>├── ca.pem           # clent &amp; server<br>├── ca.srl           # 用不到<br>├── cert.pem         # client<br>├── client.csr       # 请求文件<br>├── extfile.cnf      # 配置文件<br>├── key.pem          # client<br>├── server-cert.pem  # server<br>├── server.csr       # 请求文件<br>└── server-key.pem   # server</p>
<h3 id="生成步骤"><a href="#生成步骤" class="headerlink" title="生成步骤"></a>生成步骤</h3><ol>
<li>创建ca文件夹，存放CA私钥和公钥</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# mkdir -p /usr/local/ca</span><br><span class="line">[root@localhost ~]# cd /usr/local/ca/</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>生成 CA 私钥 (需要连续输入两次相同的密码)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ca]# openssl genrsa -aes256 -out ca-key.pem 4096</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>生成 CA 公钥.输入上一步中设置的密码,然后输入(国家、省、市、组织名称等)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ca]# openssl req -new -x509 -days 365 -key ca-key.pem -sha256 -out ca.pem</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>生成服务器私钥 <code>server-key.pem</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ca]# openssl genrsa -out server-key.pem 4096</span><br></pre></td></tr></table></figure>
<ol start="5">
<li><code>用私钥生成证书请求文件(重点)</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ca]# openssl req -subj &quot;/CN=47.105.199.230&quot; -sha256 -new -key server-key.pem -out server.csr</span><br></pre></td></tr></table></figure>
<p>把下面命令中的$Host换成你自己服务器外网的IP或者域名<br><code>openssl req -subj &quot;/CN=$HOST&quot; -sha256 -new -key server-key.pem -out server.csr</code></p>
<p>比如</p>
<ul>
<li>IP:<code>openssl req -subj &quot;/CN=192.168.1.106&quot; -sha256 -new -key server-key.pem -out server.csr</code></li>
<li>域名: <code>openssl req -subj &quot;/CN=www.baidu.com&quot; -sha256 -new -key server-key.pem -out server.csr</code></li>
</ul>
<ol start="6">
<li>用 CA 来签署证书(也就是配置白名单)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ca]# echo subjectAltName = IP:192.168.1.106,IP:0.0.0.0 &gt;&gt; extfile.cnf</span><br></pre></td></tr></table></figure>
<p>注意事项:<br>这里就是配置白名单, 制定你接下来要允许那些ip可以连接到服务器的docker，因为已经是ssl连接，所以我推荐配置0.0.0.0,也就是所有ip都可以连接(但只有拥有证书的才可以连接成功)，这样配置好之后公司其他人也可以使用。如果你不想这样，那你可以配置ip，用逗号分隔开。下面的$Host依旧是你服务器外网的IP或者域名，请自行替换。</p>
<p>如果你填写的是ip地址的话命令如下</p>
<ul>
<li><code>echo subjectAltName = IP:$HOST,IP:0.0.0.0 &gt;&gt; extfile.cnf</code><br>如果你填写的是域名的话命令如下 </li>
<li><code>echo subjectAltName = DNS:$HOST,IP:0.0.0.0 &gt;&gt; extfile.cnf</code><br>我这里使用局域网进行测试</li>
</ul>
<ol start="7">
<li>执行命令, 将Docker守护程序密钥的扩展使用属性设置为仅用于服务器身份验证</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ca]# echo extendedKeyUsage = serverAuth &gt;&gt; extfile.cnf</span><br></pre></td></tr></table></figure>
<ol start="8">
<li>执行命令，并输入之前设置的密码，生成签名证书</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ca]# openssl x509 -req -days 365 -sha256 -in server.csr -CA ca.pem -CAkey ca-key.pem \-CAcreateserial -out server-cert.pem -extfile extfile.cnf</span><br><span class="line">Signature ok</span><br><span class="line">subject=/CN=192.168.1.106</span><br><span class="line">Getting CA Private Key</span><br><span class="line">Enter pass phrase for ca-key.pem:</span><br></pre></td></tr></table></figure>
<hr>
<ol start="9">
<li>生成客户端私钥(key.pem) 到时候把生成好的几个公钥私钥拷出去即可</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ca]# openssl genrsa -out key.pem 4096</span><br></pre></td></tr></table></figure>
<ol start="10">
<li>用私钥生成证书请求文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ca]# openssl req -subj &apos;/CN=client&apos; -new -key key.pem -out client.csr</span><br></pre></td></tr></table></figure>
<ol start="11">
<li>执行命令，要使密钥适合客户端身份验证，请创建扩展配置文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ca]# echo extendedKeyUsage = clientAuth &gt;&gt; extfile.cnf</span><br></pre></td></tr></table></figure>
<ol start="12">
<li>用 CA 来签署证书,生成cert.pem(需要输入前面设置的密码,生成签名证书)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ca]# openssl x509 -req -days 365 -sha256 -in client.csr -CA ca.pem -CAkey ca-key.pem \-CAcreateserial -out cert.pem -extfile extfile.cnf</span><br></pre></td></tr></table></figure>
<ol start="13">
<li>删除不需要的文件，两个证书签名请求</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ca]# rm -v client.csr server.csr</span><br></pre></td></tr></table></figure>
<ol start="14">
<li>修改权限，要保护您的密钥免受意外损坏，请删除其写入权限。要使它们只能被您读取，更改文件模式</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ chmod -v 0400 ca-key.pem key.pem server-key.pem</span><br><span class="line">$ chmod -v 0444 ca.pem server-cert.pem cert.pem</span><br></pre></td></tr></table></figure>
<ol start="15">
<li>归集服务器证书</li>
</ol>
<p>把 <code>ca.pem</code>  <code>server-cert.pem</code>  <code>server-key.pem</code> 三个文件移动到服务端 <code>/etc/docker/</code> 文件夹中。</p>
<ol start="16">
<li>修改Docker配置(使Docker守护程序仅接受来自提供CA信任的证书的客户端的连接()</li>
</ol>
<ul>
<li>修改docker.service <code>[root@localhost ca]# vim /lib/systemd/system/docker.service</code> 修改该文件Service标签下的<code>ExecStart</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line"># the default is not to use systemd for cgroups because the delegate issues still</span><br><span class="line"># exists and systemd currently does not support the cgroup feature set required</span><br><span class="line"># for containers run by docker</span><br><span class="line"></span><br><span class="line">#重点</span><br><span class="line">#ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock（原来的）</span><br><span class="line">ExecStart=/usr/bin/dockerd（改为这样）</span><br><span class="line"># -H tcp://0.0.0.0:2375 -H unix://var/run/docker.sock （上面行从-H开始换行注释起来）</span><br></pre></td></tr></table></figure>
<ul>
<li>修改/etc/docker/daemon.json</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"registry-mirrors"</span>: [<span class="string">"https://26t763ap.mirror.aliyuncs.com"</span>], </span><br><span class="line">  <span class="attr">"tlsverify"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"tlscert"</span>: <span class="string">"/etc/docker/server-cert.pem"</span>,</span><br><span class="line">  <span class="attr">"tlskey"</span>: <span class="string">"/etc/docker/server-key.pem"</span>,</span><br><span class="line">  <span class="attr">"tlscacert"</span>: <span class="string">"/etc/docker/ca.pem"</span>,</span><br><span class="line">  <span class="attr">"hosts"</span>:[</span><br><span class="line">    <span class="string">"unix:///var/run/docker.sock"</span>,</span><br><span class="line">    <span class="string">"tcp://0.0.0.0:2376"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">~</span><br></pre></td></tr></table></figure>
<ol start="17">
<li>重新加载daemon并重启docker</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# systemctl daemon-reload </span><br><span class="line">[root@localhost ~]# systemctl restart docker</span><br></pre></td></tr></table></figure>
<ol start="18">
<li><p>阿里云或本地防火墙要放行2376 端口</p>
</li>
<li><p>通过FTP把客户端需要的 pem文件下载到本地</p>
<p>将 <code>ca.pem</code>  <code>cert.pem</code>  <code>key.pem</code> 三个文件通过 <code>scp</code> 下载到本地</p>
</li>
<li><p>IDEA 中配置证书及路径（如下图）</p>
<p><img src="images/20181018162510941.png" alt="20181018162510941"></p>
</li>
</ol>
<p>注意: 改为 2376 端口以后，要使用<strong>https</strong>地址,不能再使用 tcp 地址</p>
<ul>
<li>正确的: <code>https://47.105.199.230:2376</code></li>
<li>错误的: <code>tcp://47.105.199.230:2376</code></li>
</ul>
<p>[^参考文章][^参考文章]: <a href="https://blog.csdn.net/ChineseYoung/article/details/83107353" target="_blank" rel="noopener">https://blog.csdn.net/ChineseYoung/article/details/83107353</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker远程访问</tag>
      </tags>
  </entry>
  <entry>
    <title>cron表达式详解</title>
    <url>/2019/08/07/cron%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>　<br>　　　Cron表达式是一个字符串，字符串以5或6个空格隔开，分为6或7个域，每一个域代表一个含义，Cron有如下两种语法格式：<br>　　（1） Seconds Minutes Hours DayofMonth Month DayofWeek Year<br>　　（2） Seconds Minutes Hours DayofMonth Month DayofWeek</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>　　corn从左到右（用空格隔开）：<br>　　秒 分 小时 月份中的日期 月份 星期中的日期 年份</p>
<h3 id="各字段的含义"><a href="#各字段的含义" class="headerlink" title="各字段的含义"></a>各字段的含义</h3><table>
<thead>
<tr>
<th>字段</th>
<th>允许值</th>
<th style="text-align:right">允许的特殊字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>秒(Seconds)</td>
<td>0~59的整数</td>
<td style="text-align:right">, - * / 四个字符</td>
</tr>
<tr>
<td>分(Minutes)</td>
<td>0~59的整数</td>
<td style="text-align:right">, - * / 四个字符</td>
</tr>
<tr>
<td>小时(<em>Hours</em>)</td>
<td>0~23的整数</td>
<td style="text-align:right">, - * / 四个字符</td>
</tr>
<tr>
<td>日期(<em>DayofMonth</em>)</td>
<td>1~31的整数</td>
<td style="text-align:right">,- * ? / L W C     八个字符</td>
</tr>
<tr>
<td>月份(<em>Month</em>)</td>
<td>1~12的整数或者 JAN-DEC</td>
<td style="text-align:right">, - * / 四个字符</td>
</tr>
<tr>
<td>星期(<em>DayofWeek</em>)</td>
<td>1~7的整数或者 SUN-SAT （1=SUN）</td>
<td style="text-align:right">, - * ? / L C #     八个字符</td>
</tr>
<tr>
<td>年(<em>Year</em>) 可选，留空</td>
<td>1970~2099</td>
<td style="text-align:right">, - * / 四个字符</td>
</tr>
</tbody>
</table>
<p>　　<strong>注意事项：</strong></p>
<p>　　每一个域都使用数字，但还可以出现如下特殊字符，它们的含义是：</p>
<p>　　（1）<em>：表示匹配该域的任意值。假如在Minutes域使用</em>, 即表示每分钟都会触发事件。</p>
<p>　　（2）?：只能用在DayofMonth和DayofWeek两个域。它也匹配域的任意值，但实际不会。因为DayofMonth和DayofWeek会相互影响。例如想在每月的20日触发调度，不管20日到底是星期几，则只能使用如下写法： 13 13 15 20 <em> ?, 其中最后一位只能用？，而不能使用</em>，如果使用*表示不管星期几都会触发，实际上并不是这样。</p>
<p>　　（3）-：表示范围。例如在Minutes域使用5-20，表示从5分到20分钟每分钟触发一次 </p>
<p>　　（4）/：表示起始时间开始触发，然后每隔固定时间触发一次。例如在Minutes域使用5/20,则意味着5分钟触发一次，而25，45等分别触发一次. </p>
<p>　　（5）,：表示列出枚举值。例如：在Minutes域使用5,20，则意味着在5和20分每分钟触发一次。 </p>
<p>　　（6）L：表示最后，只能出现在DayofWeek和DayofMonth域。如果在DayofWeek域使用5L,意味着在最后的一个星期四触发。 </p>
<p>　　（7）W:表示有效工作日(周一到周五),只能出现在DayofMonth域，系统将在离指定日期的最近的有效工作日触发事件。例如：在 DayofMonth使用5W，如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日(周一)触发；如果5日在星期一到星期五中的一天，则就在5日触发。另外一点，W的最近寻找不会跨过月份 。</p>
<p>　　（8）LW:这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。 </p>
<p>　　（9）#:用于确定每个月第几个星期几，只能出现在DayofMonth域。例如在4#2，表示某月的第二个星期三。</p>
<p>　　<strong>三、常用表达式例子</strong></p>
<p>　　（1）<strong>0 0 2 1 <em> ? </em></strong>   表示在每月的1日的凌晨2点调整任务</p>
<p>　　（2）<strong>0 15 10 ? * MON-FRI </strong>  表示周一到周五每天上午10:15执行作业</p>
<p>　　（3）<strong>0 15 10 ? 6L 2002-2006</strong>   表示2002-2006年的每个月的最后一个星期五上午10:15执行作</p>
<p>　　（4）<strong>0 0 10,14,16 <em> </em> ?</strong>   每天上午10点，下午2点，4点 </p>
<p>　　（5）<strong>0 0/30 9-17 <em> </em> ?</strong>   朝九晚五工作时间内每半小时 </p>
<p>　　（6）<strong>0 0 12 ? * WED</strong>    表示每个星期三中午12点 </p>
<p>　　（7）<strong>0 0 12 <em> </em> ?</strong>   每天中午12点触发 </p>
<p>　　（8）<strong>0 15 10 ? <em> </em>  </strong>  每天上午10:15触发 </p>
<p>　　（9）<strong>0 15 10 <em> </em> ?</strong>     每天上午10:15触发 </p>
<p>　　（10）<strong>0 15 10 <em> </em> ? * </strong>   每天上午10:15触发 </p>
<p>　　（11）<strong>0 15 10 <em> </em> ? 2005</strong>    2005年的每天上午10:15触发 </p>
<p>　　（12）<strong>0 <em> 14 </em> * ?</strong>     在每天下午2点到下午2:59期间的每1分钟触发 </p>
<p>　　（13）<strong>0 0/5 14 <em> </em> ?</strong>    在每天下午2点到下午2:55期间的每5分钟触发 </p>
<p>　　（14）<strong>0 0/5 14,18 <em> </em> ?</strong>     在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 </p>
<p>　　（15）<strong>0 0-5 14 <em> </em> ? </strong>   在每天下午2点到下午2:05期间的每1分钟触发 </p>
<p>　　（16）<strong>0 10,44 14 ? 3 WED</strong>    每年三月的星期三的下午2:10和2:44触发 </p>
<p>　　（17）<strong>0 15 10 ? * MON-FRI </strong>   周一至周五的上午10:15触发 </p>
<p>　　（18）<strong>0 15 10 15 * ? </strong>   每月15日上午10:15触发 </p>
<p>　　（19）<strong>0 15 10 L * ? </strong>   每月最后一日的上午10:15触发 </p>
<p>　　（20）<strong>0 15 10 ? * 6L </strong>   每月的最后一个星期五上午10:15触发 </p>
<p>　　（21）<strong>0 15 10 ? * 6L 2002-2005</strong>   2002年至2005年的每月的最后一个星期五上午10:15触发 </p>
<p>　　（22）<strong>0 15 10 ? * 6#3</strong>   每月的第三个星期五上午10:15触发</p>
<p><strong>　　注：</strong></p>
<p>　　（1）有些子表达式能包含一些范围或列表</p>
<p>　　例如：子表达式（天（星期））可以为 “MON-FRI”，“MON，WED，FRI”，“MON-WED,SAT”</p>
<p>“*”字符代表所有可能的值</p>
<p>　　因此，“<em>”在子表达式（月）里表示每个月的含义，“</em>”在子表达式（天（星期））表示星期的每一天</p>
<p>　　“/”字符用来指定数值的增量<br>　　例如：在子表达式（分钟）里的“0/15”表示从第0分钟开始，每15分钟<br>在子表达式（分钟）里的“3/20”表示从第3分钟开始，每20分钟（它和“3，23，43”）的含义一样</p>
<p>　　“？”字符仅被用于天（月）和天（星期）两个子表达式，表示不指定值<br>　　当2个子表达式其中之一被指定了值以后，为了避免冲突，需要将另一个子表达式的值设为“？”</p>
<p>　　“L” 字符仅被用于天（月）和天（星期）两个子表达式，它是单词“last”的缩写<br>　　但是它在两个子表达式里的含义是不同的。<br>　　在天（月）子表达式中，“L”表示一个月的最后一天<br>　　在天（星期）自表达式中，“L”表示一个星期的最后一天，也就是SAT</p>
<p>　　如果在“L”前有具体的内容，它就具有其他的含义了</p>
<p>　　例如：“6L”表示这个月的倒数第６天，“FRIL”表示这个月的最一个星期五<br>　　注意：在使用“L”参数时，不要指定列表或范围，因为这会导致问题</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>定时任务</tag>
      </tags>
  </entry>
  <entry>
    <title>centOS ssh连接 一段时间无操作连接自动断开问题</title>
    <url>/2019/08/07/centOS-ssh%E8%BF%9E%E6%8E%A5-%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E6%97%A0%E6%93%8D%E4%BD%9C%E8%BF%9E%E6%8E%A5%E8%87%AA%E5%8A%A8%E6%96%AD%E5%BC%80%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>解决方法：</p>
<p>1 修改  /etc/ssh/sshd_config 文件<br>执行命令：vi /etc/ssh/sshd_config</p>
<p>中间部分有：</p>
<h4 id="ClientAliveInterval-0"><a href="#ClientAliveInterval-0" class="headerlink" title="ClientAliveInterval 0"></a>ClientAliveInterval 0</h4><h4 id="ClientAliveCountMax-3"><a href="#ClientAliveCountMax-3" class="headerlink" title="ClientAliveCountMax 3"></a>ClientAliveCountMax 3</h4><p>改为：</p>
<p>ClientAliveInterval 60</p>
<p>ClientAliveCountMax 60</p>
<p>修改后如下用图：</p>
<p>ClientAliveInterval指定了服务器端向客户端请求消息的时间间隔, 默认是0, 不发送.而ClientAliveInterval 60表示每分钟发送一次, 然后客户端响应, 这样就保持长连接了</p>
<p>ClientAliveCountMax表示服务器发出请求后客户端没有响应的次数达到一定值, 就自动断开 。</p>
<p>2重启sshd （必须的否则无效）<br>执行命令：/bin/systemctl restart  sshd.service<br>我有在网上找这个问题的解决方法，有的只改参数，没有讲重启sshd。有的说了但是呢在我的机子上命令不能用，例如：/etc/init.d/sshdstart   /etc/rc.d/init.d/sshd restart</p>
]]></content>
      <categories>
        <category>centos</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2019/08/07/cenos7.5%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<h3 id="cenos7-5下载地址"><a href="#cenos7-5下载地址" class="headerlink" title="cenos7.5下载地址"></a>cenos7.5下载地址</h3><p><a href="http://archive.kernel.org/centos-vault/7.5.1804/isos/x86_64/" target="_blank" rel="noopener">http://archive.kernel.org/centos-vault/7.5.1804/isos/x86_64/</a></p>
]]></content>
  </entry>
  <entry>
    <title>android版本API对应关系</title>
    <url>/2019/08/07/android%E7%89%88%E6%9C%ACAPI%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p><img src="http://blog.nilaile.cn/blog/20190520/V91Q41R0IX0B.png" alt="mark"></p>
<table>
<thead>
<tr>
<th>code name</th>
<th style="text-align:right">Version    API level</th>
</tr>
</thead>
<tbody>
<tr>
<td>Q Preview</td>
<td style="text-align:right">API level Q</td>
</tr>
<tr>
<td>Pie    9.0</td>
<td style="text-align:right">API level 28</td>
</tr>
<tr>
<td>Oreo    8.1</td>
<td style="text-align:right">API level 27</td>
</tr>
<tr>
<td>Oreo    8.0</td>
<td style="text-align:right">API level 26</td>
</tr>
<tr>
<td>Nougat    7.1</td>
<td style="text-align:right">API level 25</td>
</tr>
<tr>
<td>Nougat    7.0</td>
<td style="text-align:right">API level 24</td>
</tr>
<tr>
<td>Marshmallow    6.0</td>
<td style="text-align:right">API level 23</td>
</tr>
<tr>
<td>Lollipop    5.1</td>
<td style="text-align:right">API level 22</td>
</tr>
<tr>
<td>Lollipop    5.0</td>
<td style="text-align:right">API level 21</td>
</tr>
<tr>
<td>KitKat    4.4 - 4.4.4</td>
<td style="text-align:right">API level 19</td>
</tr>
<tr>
<td>Jelly Bean    4.3.x</td>
<td style="text-align:right">API level 18</td>
</tr>
<tr>
<td>Jelly Bean    4.2.x</td>
<td style="text-align:right">API level 17</td>
</tr>
<tr>
<td>Jelly Bean    4.1.x</td>
<td style="text-align:right">API level 16</td>
</tr>
<tr>
<td>Ice Cream Sandwich    4.0.3 - 4.0.4</td>
<td style="text-align:right">API level 15, NDK 8</td>
</tr>
<tr>
<td>Ice Cream Sandwich    4.0.1 - 4.0.2</td>
<td style="text-align:right">API level 14, NDK 7</td>
</tr>
<tr>
<td>Honeycomb    3.2.x</td>
<td style="text-align:right">API level 13</td>
</tr>
<tr>
<td>Honeycomb    3.1</td>
<td style="text-align:right">API level 12, NDK 6</td>
</tr>
<tr>
<td>Honeycomb    3.0</td>
<td style="text-align:right">API level 11</td>
</tr>
<tr>
<td>Gingerbread    2.3.3 - 2.3.7</td>
<td style="text-align:right">API level 10</td>
</tr>
<tr>
<td>Gingerbread    2.3 - 2.3.2</td>
<td style="text-align:right">API level 9, NDK 5</td>
</tr>
<tr>
<td>Froyo    2.2.x</td>
<td style="text-align:right">API level 8, NDK 4</td>
</tr>
<tr>
<td>Eclair    2.1</td>
<td style="text-align:right">API level 7, NDK 3</td>
</tr>
<tr>
<td>Eclair    2.0.1</td>
<td style="text-align:right">API level 6</td>
</tr>
<tr>
<td>Eclair    2.0</td>
<td style="text-align:right">API level 5</td>
</tr>
<tr>
<td>Donut    1.6</td>
<td style="text-align:right">API level 4, NDK 2</td>
</tr>
<tr>
<td>Cupcake    1.5</td>
<td style="text-align:right">API level 3, NDK 1</td>
</tr>
<tr>
<td>(no code name)    1.1</td>
<td style="text-align:right">API level 2</td>
</tr>
<tr>
<td>(no code name)    1.0</td>
<td style="text-align:right">API level 1</td>
</tr>
</tbody>
</table>
<hr>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql存储emoji表情错误问题</title>
    <url>/2019/08/07/Mysql%E5%AD%98%E5%82%A8emoji%E8%A1%A8%E6%83%85%E9%94%99%E8%AF%AF%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>问题: 插入emoji表情字符串时,数据库抛出下面的异常信息:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Incorrect string value: &apos;\xF0\x9F\x98\x81&apos; for column &apos;job&apos; at row 23</span><br></pre></td></tr></table></figure></p>
<p>解决方法 ：</p>
<ol>
<li><p>windows服务器<br>修改my.ini配置文件,修改编码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysql]  </span><br><span class="line">default-character-set=utf8mb4</span><br><span class="line">[mysqld]  </span><br><span class="line">character-set-server=utf8mb4</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启Mysql服务</p>
</li>
<li><p>先查看数据库的编码方式：</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &apos;%char%&apos;;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>修改整个表的编码方式：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table user convert to character set utf8mb4 collate utf8mb4_bin;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>修改某个字段的编码方式：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE user_patient MODIFY COLUMN user_name varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT &apos;姓名&apos;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx配置Https证书后,API项目访问时POST请求变为GET请求</title>
    <url>/2019/08/07/Nginx%E9%85%8D%E7%BD%AEHttps%E8%AF%81%E4%B9%A6%E5%90%8E,API%E9%A1%B9%E7%9B%AE%E8%AE%BF%E9%97%AE%E6%97%B6POST%E8%AF%B7%E6%B1%82%E5%8F%98%E4%B8%BAGET%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<p>Nginx下配置Https证书，之前的博客是: <a href="http://nilaile.win/2019/05/13/Centos7.5%E9%85%8D%E7%BD%AEHTTPS%E8%AF%81%E4%B9%A6/" target="_blank" rel="noopener">Nginx配置Https证书</a></p>
<p>Https证书配置完成后 admin模块可以正常跳转到HTTPS, API模块部署后,后台请求登录遇到异常,查看Nginx日志后发现从http跳转到https时,请求的api方法从POST变为了GET请求，日志如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">123.52.42.83 - - [05/Jun/2019:15:51:46 +0800] &quot;POST /ylzhy-api/api/wechat/user/login HTTP/1.1&quot; 301 185 &quot;-&quot; &quot;PostmanRuntime/7.13.0&quot;</span><br><span class="line"></span><br><span class="line">123.52.42.83 - - [05/Jun/2019:15:51:46 +0800] &quot;GET /ylzhy-api/api/wechat/user/login HTTP/1.1&quot; 200 65 &quot;http://www.sjjtcloud.com:80/ylzhy-api/api/wechat/user/login&quot; &quot;PostmanRuntime/7.13.0&quot;</span><br></pre></td></tr></table></figure>
<p>查找相关资料后, 发现是由于 301引起的。换成307问题解决</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;   </span><br><span class="line">	server &#123;</span><br><span class="line">		listen 443;</span><br><span class="line">		server_name www.sjjtcloud.com;</span><br><span class="line">		ssl on;</span><br><span class="line">		ssl_certificate  	cert/2195340_www.sjjtcloud.com.pem;</span><br><span class="line">		ssl_certificate_key 	cert/2195340_www.sjjtcloud.com.key;</span><br><span class="line">		ssl_session_timeout 5m;</span><br><span class="line">		ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">		ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">		ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">		proxy_set_header Host $host;</span><br><span class="line">		proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">		</span><br><span class="line">		location / &#123;</span><br><span class="line">			proxy_set_header Host $host;</span><br><span class="line">			proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">			root   D:/nginx-1.12.2/html;</span><br><span class="line">			index  index.html index.htm;</span><br><span class="line">			try_files $uri $uri/ @router;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		location /api/ &#123;</span><br><span class="line">			proxy_set_header Host $host;</span><br><span class="line">			proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">			proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">			proxy_pass http://127.0.0.1:8081;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		location /admin &#123;</span><br><span class="line">			proxy_set_header Host $host;</span><br><span class="line">			proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">			proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">			proxy_pass http://127.0.0.1:8083/admin;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	 server &#123;</span><br><span class="line">    	listen   80;</span><br><span class="line">		server_name www.sjjtcloud.com sjjtcloud.com;  </span><br><span class="line">		proxy_set_header Host $host;</span><br><span class="line">		proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">		#rewrite ^(.*)$  https://$&#123;server_name&#125;$1 permanent; #这种写法是错误的</span><br><span class="line">		return 307 https://$server_name$request_uri; ###改为307</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>301 Moved Permanently<br>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一</p>
<p>307 Temporary Redirect<br>请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求 </p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx匹配规则说明以及匹配的优先级</title>
    <url>/2019/08/07/Nginx%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<p>location 匹配规则<br>语法规则<br>location [=|~|~*|^~] /uri/ { … }</p>
<p>模式    含义<br>location = /uri    = 表示精确匹配，只有完全匹配上才能生效<br>location ^~ /uri    ^~ 开头对URL路径进行前缀匹配，并且在正则之前。<br>location ~ pattern    开头表示区分大小写的正则匹配<br>location ~* pattern    开头表示不区分大小写的正则匹配<br>location /uri    不带任何修饰符，也表示前缀匹配，但是在正则匹配之后<br>location /    通用匹配，任何未匹配到其它location的请求都会匹配到，相当于switch中的default<br>前缀匹配时，Nginx 不对 url 做编码，因此请求为 /static/20%/aa，可以被规则 ^~ /static/ /aa 匹配到（注意是空格）</p>
<p>多个 location 配置的情况下匹配顺序为（参考资料而来，还未实际验证，试试就知道了，不必拘泥，仅供参考）:</p>
<p>首先精确匹配 =<br>其次前缀匹配 ^~<br>其次是按文件中顺序的正则匹配<br>然后匹配不带任何修饰的前缀匹配。<br>最后是交给 / 通用匹配<br>当有匹配成功时候，停止匹配，按当前匹配规则处理请求<br>注意：前缀匹配，如果有包含关系时，按最大匹配原则进行匹配。比如在前缀匹配：location /dir01 与location /dir01/dir02，如有请求 <a href="http://localhost/dir01/dir02/file" target="_blank" rel="noopener">http://localhost/dir01/dir02/file</a> 将最终匹配到 location /dir01/dir02</p>
<p>例子，有如下匹配规则：</p>
<p>location = / {<br>   echo “规则A”;<br>}<br>location = /login {<br>   echo “规则B”;<br>}<br>location ^~ /static/ {<br>   echo “规则C”;<br>}<br>location ^~ /static/files {<br>    echo “规则X”;<br>}<br>location ~ .(gif|jpg|png|js|css)$ {<br>   echo “规则D”;<br>}<br>location ~* .png$ {<br>   echo “规则E”;<br>}<br>location /img {<br>    echo “规则Y”;<br>}<br>location / {<br>   echo “规则F”;<br>}<br>那么产生的效果如下：</p>
<p>访问根目录 /，比如 <a href="http://localhost/" target="_blank" rel="noopener">http://localhost/</a> 将匹配 规则A<br>访问 <a href="http://localhost/login" target="_blank" rel="noopener">http://localhost/login</a> 将匹配 规则B，<a href="http://localhost/register" target="_blank" rel="noopener">http://localhost/register</a> 则匹配 规则F<br>访问 <a href="http://localhost/static/a.html" target="_blank" rel="noopener">http://localhost/static/a.html</a> 将匹配 规则C<br>访问 <a href="http://localhost/static/files/a.exe" target="_blank" rel="noopener">http://localhost/static/files/a.exe</a> 将匹配 规则X，虽然 规则C 也能匹配到，但因为最大匹配原则，最终选中了 规则X。你可以测试下，去掉规则 X ，则当前 URL 会匹配上 规则C。<br>访问 <a href="http://localhost/a.gif" target="_blank" rel="noopener">http://localhost/a.gif</a>, <a href="http://localhost/b.jpg" target="_blank" rel="noopener">http://localhost/b.jpg</a> 将匹配 规则D 和 规则 E ，但是 规则 D 顺序优先，规则 E 不起作用，而 <a href="http://localhost/static/c.png" target="_blank" rel="noopener">http://localhost/static/c.png</a> 则优先匹配到 规则 C<br>访问 <a href="http://localhost/a.PNG" target="_blank" rel="noopener">http://localhost/a.PNG</a> 则匹配 规则 E ，而不会匹配 规则 D ，因为 规则 E 不区分大小写。<br>访问 <a href="http://localhost/img/a.gif" target="_blank" rel="noopener">http://localhost/img/a.gif</a> 会匹配上 规则D,虽然 规则Y 也可以匹配上，但是因为正则匹配优先，而忽略了 规则Y。<br>访问 <a href="http://localhost/img/a.tiff" target="_blank" rel="noopener">http://localhost/img/a.tiff</a> 会匹配上 规则Y。<br>访问 <a href="http://localhost/category/id/1111" target="_blank" rel="noopener">http://localhost/category/id/1111</a> 则最终匹配到规则 F ，因为以上规则都不匹配，这个时候应该是 Nginx 转发请求给后端应用服务器，比如 FastCGI（php），tomcat（jsp），Nginx 作为反向代理服务器存在。</p>
<p>所以实际使用中，笔者觉得至少有三个匹配规则定义，如下：</p>
<h4 id="直接匹配网站根，通过域名访问网站首页比较频繁，使用这个会加速处理，官网如是说。"><a href="#直接匹配网站根，通过域名访问网站首页比较频繁，使用这个会加速处理，官网如是说。" class="headerlink" title="直接匹配网站根，通过域名访问网站首页比较频繁，使用这个会加速处理，官网如是说。"></a>直接匹配网站根，通过域名访问网站首页比较频繁，使用这个会加速处理，官网如是说。</h4><h4 id="这里是直接转发给后端应用服务器了，也可以是一个静态首页"><a href="#这里是直接转发给后端应用服务器了，也可以是一个静态首页" class="headerlink" title="这里是直接转发给后端应用服务器了，也可以是一个静态首页"></a>这里是直接转发给后端应用服务器了，也可以是一个静态首页</h4><h4 id="第一个必选规则"><a href="#第一个必选规则" class="headerlink" title="第一个必选规则"></a>第一个必选规则</h4><p>location = / {<br>    proxy_pass <a href="http://tomcat:8080/index" target="_blank" rel="noopener">http://tomcat:8080/index</a><br>}</p>
<h1 id="第二个必选规则是处理静态文件请求，这是-nginx-作为-http-服务器的强项"><a href="#第二个必选规则是处理静态文件请求，这是-nginx-作为-http-服务器的强项" class="headerlink" title="第二个必选规则是处理静态文件请求，这是 nginx 作为 http 服务器的强项"></a>第二个必选规则是处理静态文件请求，这是 nginx 作为 http 服务器的强项</h1><h1 id="有两种配置模式，目录匹配或后缀匹配，任选其一或搭配使用"><a href="#有两种配置模式，目录匹配或后缀匹配，任选其一或搭配使用" class="headerlink" title="有两种配置模式，目录匹配或后缀匹配，任选其一或搭配使用"></a>有两种配置模式，目录匹配或后缀匹配，任选其一或搭配使用</h1><p>location ^~ /static/ {<br>    root /webroot/static/;<br>}<br>location ~* .(gif|jpg|jpeg|png|css|js|ico)$ {<br>    root /webroot/res/;<br>}</p>
<h1 id="第三个规则就是通用规则，用来转发动态请求到后端应用服务器"><a href="#第三个规则就是通用规则，用来转发动态请求到后端应用服务器" class="headerlink" title="第三个规则就是通用规则，用来转发动态请求到后端应用服务器"></a>第三个规则就是通用规则，用来转发动态请求到后端应用服务器</h1><h1 id="非静态文件请求就默认是动态请求，自己根据实际把握"><a href="#非静态文件请求就默认是动态请求，自己根据实际把握" class="headerlink" title="非静态文件请求就默认是动态请求，自己根据实际把握"></a>非静态文件请求就默认是动态请求，自己根据实际把握</h1><h1 id="毕竟目前的一些框架的流行，带-php、-jsp后缀的情况很少了"><a href="#毕竟目前的一些框架的流行，带-php、-jsp后缀的情况很少了" class="headerlink" title="毕竟目前的一些框架的流行，带.php、.jsp后缀的情况很少了"></a>毕竟目前的一些框架的流行，带.php、.jsp后缀的情况很少了</h1><p>location / {<br>    proxy_pass <a href="http://tomcat:8080/" target="_blank" rel="noopener">http://tomcat:8080/</a><br>}</p>
<h2 id="rewrite-语法"><a href="#rewrite-语法" class="headerlink" title="rewrite 语法"></a>rewrite 语法</h2><p>作者：Gove_chan<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/qq_15766181/article/details/72829672" target="_blank" rel="noopener">https://blog.csdn.net/qq_15766181/article/details/72829672</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p>
]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>NGINX</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2019/08/07/MybatisPlus%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>###MybatisPlus总结</p>
<ol>
<li>mybatisPlus中使用updateById和update 都不能更新某个字段为””问题<br>解决方法： 修改mybatis-plus配置文件，如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#字段策略 0:&quot;忽略判断&quot;,1:&quot;非 NULL 判断&quot;),2:&quot;非空判断&quot;</span><br><span class="line">field-strategy: 1</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>JAVA IO总结</title>
    <url>/2019/08/07/Java-io%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>#JAVA IO总结</p>
<p><img src="https://www.2cto.com/uploadfile/Collfiles/20160801/20160801093838973.png" alt="IO分类图"></p>
<h2 id="InputStream和OutputStream"><a href="#InputStream和OutputStream" class="headerlink" title="InputStream和OutputStream"></a>InputStream和OutputStream</h2><ul>
<li>InputStream是所有字节输入流的父类</li>
</ul>
<ul>
<li>int read():读取一个字节以int形式返回,该int值的低8位有效，返回-1则表示EOF</li>
<li>int read(byte[] b): 读取b.length字节到数组中，返回值为实际读取到的字节量</li>
</ul>
<ul>
<li>OutputStream是所有字节输出流的父类</li>
</ul>
<ul>
<li>void write(int d) 写出一个字节，写的是int的低8位</li>
<li>void write(byte[] d)将给定的字节数组中的所有字节全部写出</li>
</ul>
<h2 id="文件字节流"><a href="#文件字节流" class="headerlink" title="文件字节流"></a>文件字节流</h2><ul>
<li>FileInputStream 是文件的字节输入流</li>
</ul>
<ul>
<li>int read()</li>
<li>int read(byte[] b)</li>
</ul>
<ul>
<li>FileOutputStream 是文件的字节输出流，FOS有两种模式一种是重写模式，一种是追加模式</li>
</ul>
<ul>
<li>void write(int d)</li>
<li>void write(byte[] d)</li>
<li>void write(byte[] d,int offset,int len)将字节数组d中 从偏移量offset开始的 len个字节写入文件输出流中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 文件流</span><br><span class="line"> * FileOutPutStream是字节输出流</span><br><span class="line"> */</span><br><span class="line">public class FosTest &#123;</span><br><span class="line"></span><br><span class="line">    File f = new File(&quot;fileOut.txt&quot;);</span><br><span class="line"></span><br><span class="line">    //测试FOS 追加模式</span><br><span class="line">    @Test</span><br><span class="line">    @Ignore</span><br><span class="line">    public void testFosAppendMode()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            FileOutputStream fos = new FileOutputStream(f,true);</span><br><span class="line">            fos.write(&quot;,Hello every one I am David&quot;.getBytes());</span><br><span class="line">            fos.flush();</span><br><span class="line">            fos.close();</span><br><span class="line"></span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //测试FOS 重写模式</span><br><span class="line">    @Test</span><br><span class="line">    @Ignore</span><br><span class="line">    public void testFosOverrideMode()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            FileOutputStream fos = new FileOutputStream(f);</span><br><span class="line">            fos.write(&quot;You are good Boy&quot;.getBytes());</span><br><span class="line">            fos.flush();</span><br><span class="line">            fos.close();</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><blockquote>
<p>在读取数据时 若以字节为单位读取数据，会因为读取次数频繁而大大的降低读取效率<br>缓冲流就是通过提高每次读写的字节数量,减少读写次数 从而提高读写效率</p>
</blockquote>
<ul>
<li>BufferedInputStream</li>
<li>BufferedOutputStream</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * BufferedOutputStream</span><br><span class="line"> * 内部维护着一个缓冲区,当我们向该流写数据时，都会先将数据写入缓冲区, 当缓冲区已满时,缓冲流会一次性将数据写出</span><br><span class="line"> * 用途：在向硬件设备写出数据时, 使用缓冲流可以减小写出次数，从而提高了写出效率</span><br><span class="line"> * 注意: 有时我们在写出数据后希望 数据立即被写出，而不是存储在缓冲区中 直到缓冲区满后才真正写出，这时可以调用flush()强制写出</span><br><span class="line"> *</span><br><span class="line"> * BufferedInputPutStream 处理流</span><br><span class="line"> * 内部也是维护一个缓冲区，当读取字节数据时会尽可能多的读取 然后存入缓冲区，然后逐一的返回缓存的字节数据，直到读取完毕</span><br><span class="line"> */</span><br><span class="line">public class BosBisTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void testBos()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            byte[] d = new byte[100];</span><br><span class="line"></span><br><span class="line">            FileOutputStream fos = new FileOutputStream(&quot;fileOut.txt&quot;,true);</span><br><span class="line">            BufferedOutputStream bos = new BufferedOutputStream(fos);</span><br><span class="line">            bos.write(&quot;,I am from China&quot;.getBytes());</span><br><span class="line">            bos.close();</span><br><span class="line"></span><br><span class="line">            FileInputStream fio = new FileInputStream(&quot;fileOut.txt&quot;);</span><br><span class="line">            BufferedInputStream bio = new BufferedInputStream(fio);</span><br><span class="line"></span><br><span class="line">            int dd = -1;</span><br><span class="line">            while((dd = bio.read())!=-1)&#123;</span><br><span class="line">                //一个个字节的读取输出了，</span><br><span class="line">                System.out.println(dd+&quot;,&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Reader和Writer"><a href="#Reader和Writer" class="headerlink" title="Reader和Writer"></a>Reader和Writer</h2><ul>
<li>Reader是字符输入流的父类，当要读文本文件时最好使用Reader类，它为读取文本而设计</li>
<li><p>Writer是字符输出流的父类，当要写文本文件时最好使用Writer类，而不是直接写OutputStream；因为Writer类就是为写文本而设计的。</p>
</li>
<li><p>字符流是以char(字符)为单位读写数据的,一次处理一个Unicode</p>
</li>
<li>字符流的底层仍然是基本的字节流.</li>
</ul>
<h3 id="Reader常用方法"><a href="#Reader常用方法" class="headerlink" title="Reader常用方法"></a>Reader常用方法</h3><ul>
<li>int read(): 读取一个字符,返回int值 “低16位”有效</li>
<li>int read(char[] chs): 读取一个字符数组的length个字符并存入该数组,返回值为实际读取到的字符量</li>
</ul>
<h3 id="Writer常用方法"><a href="#Writer常用方法" class="headerlink" title="Writer常用方法"></a>Writer常用方法</h3><ul>
<li>void write(int c): 写出一个字符,写出给定int值 “低16位”表示的字符。</li>
<li>void write(char[] chs):将给定字符数组中所有字符写出</li>
<li>void write(char[] chs,int offset,int len):将给定的字符数组中从offset处开始连续的len个字符写出</li>
</ul>
<h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><p>###InputStreamReader: 字符输入流<br> 使用该流可以设置字符集,并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取 </p>
<ul>
<li>InputStreamReader(InputStream in, String charsetName) 根据指定字符集创建ISR</li>
<li>InputStreamReader(InputStream in) 根据系统默认字符集创建ISR</li>
</ul>
<h3 id="OutputStreamWriter-字符输出流"><a href="#OutputStreamWriter-字符输出流" class="headerlink" title="OutputStreamWriter:字符输出流"></a>OutputStreamWriter:字符输出流</h3><p>使用该流可以设置字符集,并按照指定字符集 将字符转换为对应字节后通过流写出 </p>
<ul>
<li>OutputStreamWriter(OutputStream out,String charsetName) 基于指定的字节输出流和字符集创建OSW</li>
<li>OutputStreamWriter(OutputStream out) 基于指定的字节输出流和系统默认字符集创建OSW</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 测试InputStreamReader 和 OutputStreamWriter</span><br><span class="line"> */</span><br><span class="line">public class OswTest &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    @Ignore</span><br><span class="line">    public void testOsw() throws java.io.IOException&#123;</span><br><span class="line">        FileOutputStream fos = new FileOutputStream(&quot;demo.txt&quot;);</span><br><span class="line">        OutputStreamWriter osw = new OutputStreamWriter(fos,&quot;UTF-8&quot;);</span><br><span class="line">        osw.write(&quot;中国人&quot;);</span><br><span class="line">        osw.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testIsr() throws java.io.IOException&#123;</span><br><span class="line">        FileInputStream fis = new FileInputStream(&quot;demo.txt&quot;);</span><br><span class="line">        InputStreamReader isr = new InputStreamReader(fis,&quot;utf-8&quot;);</span><br><span class="line">        int data = -1;</span><br><span class="line">        while ((data=isr.read())!=-1)&#123;</span><br><span class="line">            System.out.println((char)data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        isr.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="文件字符流"><a href="#文件字符流" class="headerlink" title="文件字符流"></a>文件字符流</h3><ul>
<li>FileReader</li>
<li>FileWriter</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class FileReaderWriterTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            File f = new File(&quot;demo.txt&quot;);</span><br><span class="line">            FileWriter fw = new FileWriter(f);</span><br><span class="line">            fw.write(&quot;Hello\ndavid&quot;);</span><br><span class="line">            fw.close();</span><br><span class="line"></span><br><span class="line">            FileReader fr = new FileReader(f);</span><br><span class="line">            int res = 0;</span><br><span class="line">            while ( (res=fr.read())!=-1)&#123;</span><br><span class="line">                System.out.println((char)res);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fr.close();</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h3><ul>
<li>BufferedReader 它是缓存字符输入流,内部提供了缓冲区 可以提交读取效率</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BufferedReader(Reader reader) 构造函数</span><br><span class="line">String readLine() 该方法连续读取一行字符串</span><br></pre></td></tr></table></figure>
<ul>
<li>BufferedWriter</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BufferedWriter(Writer writer)构造函数</span><br><span class="line">void newLine()  //写入一个行分隔符。 </span><br><span class="line">void write(char ch)</span><br><span class="line">void write(char[] cbuf)</span><br><span class="line">void write(char[] cbuf,int offset,int len)</span><br></pre></td></tr></table></figure>
<p> Demo代码</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public class BufferedReaderWriter &#123;</span><br><span class="line"> 	</span><br><span class="line">    @Test</span><br><span class="line">    @Ignore</span><br><span class="line">    public void testReader()&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            BufferedReader br = new BufferedReader(new FileReader(&quot;demo.txt&quot;));</span><br><span class="line">            String str= &quot;&quot;;</span><br><span class="line">            while((str=br.readLine())!=null)&#123;</span><br><span class="line">                System.out.println(&quot;---&quot;+str);</span><br><span class="line">            &#125;</span><br><span class="line">            br.close();</span><br><span class="line"></span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testWriter()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;demo.txt&quot;));</span><br><span class="line">            bw.write(&quot;Hello&quot;);</span><br><span class="line"></span><br><span class="line">            bw.newLine();</span><br><span class="line">            bw.write(&quot;I am david&quot;);</span><br><span class="line">            bw.newLine();</span><br><span class="line">            bw.close();</span><br><span class="line"></span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql主从复制原理及步骤</title>
    <url>/2019/08/07/Mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h2 id="Mysql主从复制的原理"><a href="#Mysql主从复制的原理" class="headerlink" title="Mysql主从复制的原理"></a>Mysql主从复制的原理</h2><blockquote>
<p>mysql内建有一种复制方式，即指定一台或多台服务器为主机master，另外一台或多台服务器作为从机slave。当master存在更新的时候，master将更新写入二进制文件，并维护了一个索引文件跟踪日志。当slave连接到主服务器之后，slave会通知master进行同步，master通过索引找日志文件上一次同步的位置，然后将这段时间内的更新数据发送给slave进行同步<br><a id="more"></a></p>
</blockquote>
<h3 id="主从配置的优缺点"><a href="#主从配置的优缺点" class="headerlink" title="主从配置的优缺点"></a>主从配置的优缺点</h3><p>优点：高可用，提高容错率，数据分布，负载均衡。</p>
<p>缺点：单向同步，无法解决主机宕机问题</p>
<h3 id="主从配置先决条件"><a href="#主从配置先决条件" class="headerlink" title="主从配置先决条件"></a>主从配置先决条件</h3><ol>
<li>Mysql版本必须一致</li>
<li>保证两台主机的mysql远程连接开启</li>
</ol>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>主库从库均创建要给名为auth的数据库</p>
<ol start="3">
<li>主库ip:192.168.1.121 </li>
<li>从库ip:192.168.1.107</li>
</ol>
<h3 id="主机-主库-配置"><a href="#主机-主库-配置" class="headerlink" title="主机(主库)配置"></a>主机(主库)配置</h3><h5 id="1-找到Mysql安装目录下的my-ini配置文件-在-mysqld-下增加如下配置"><a href="#1-找到Mysql安装目录下的my-ini配置文件-在-mysqld-下增加如下配置" class="headerlink" title="1. 找到Mysql安装目录下的my.ini配置文件,在[mysqld]下增加如下配置"></a>1. 找到Mysql安装目录下的my.ini配置文件,在[mysqld]下增加如下配置</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">server-id=66 <span class="comment">#id唯一</span></span><br><span class="line">log-bin=E:/phpStudy/MySQL/log-bin <span class="comment">#同步日志的文件存放路径</span></span><br><span class="line">binlog-<span class="keyword">do</span>-db=auth <span class="comment">#备份哪些些数据库的二进制日志</span></span><br><span class="line"><span class="comment">#binlog-ignore-db=test  #也可以直接设置哪些数据库不同步</span></span><br></pre></td></tr></table></figure>
<h5 id="2-重启mysql服务-可以在上面配置的日志文件存储路径下找到索引文件-表示成功"><a href="#2-重启mysql服务-可以在上面配置的日志文件存储路径下找到索引文件-表示成功" class="headerlink" title="2. 重启mysql服务,可以在上面配置的日志文件存储路径下找到索引文件,表示成功"></a>2. 重启mysql服务,可以在上面配置的日志文件存储路径下找到索引文件,表示成功</h5><h5 id="3-登陆mysql，给从机配置登录名，登陆，密码和权限"><a href="#3-登陆mysql，给从机配置登录名，登陆，密码和权限" class="headerlink" title="3. 登陆mysql，给从机配置登录名，登陆，密码和权限"></a>3. 登陆mysql，给从机配置登录名，登陆，密码和权限</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">replication</span> <span class="keyword">slave</span>,reload,super <span class="keyword">on</span> *.*  <span class="keyword">to</span> <span class="keyword">slave</span>@<span class="number">192.168</span><span class="number">.1</span><span class="number">.121</span>  <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'changpan'</span>;</span><br></pre></td></tr></table></figure>
<h5 id="4-查看主库状态-配置从机时需要使用file和postion两个值"><a href="#4-查看主库状态-配置从机时需要使用file和postion两个值" class="headerlink" title="4. 查看主库状态 配置从机时需要使用file和postion两个值"></a>4. 查看主库状态 配置从机时需要使用file和postion两个值</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">master</span> <span class="keyword">status</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://images.cnblogs.com/cnblogs_com/fxmemory/1028818/o_%e4%b8%bb%e6%9c%ba%e7%8a%b6%e6%80%81.png" alt></p>
<h3 id="从机-从库-配置"><a href="#从机-从库-配置" class="headerlink" title="从机(从库)配置"></a>从机(从库)配置</h3><h5 id="1-找到Mysql安装目录下的my-ini配置文件-在-mysqld-下增加如下配置-1"><a href="#1-找到Mysql安装目录下的my-ini配置文件-在-mysqld-下增加如下配置-1" class="headerlink" title="1. 找到Mysql安装目录下的my.ini配置文件,在[mysqld]下增加如下配置"></a>1. 找到Mysql安装目录下的my.ini配置文件,在[mysqld]下增加如下配置</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">server-id=88 　　<span class="comment">#保证整数唯一</span></span><br><span class="line">replicate-<span class="keyword">do</span>-db=auth  <span class="comment">#同步哪一个数据库 跟主库一致</span></span><br></pre></td></tr></table></figure>
<p>注意: 配置好之后重启数据库</p>
<h5 id="2-测试是否能够登陆到主库-校验之前主库的配置"><a href="#2-测试是否能够登陆到主库-校验之前主库的配置" class="headerlink" title="2. 测试是否能够登陆到主库,校验之前主库的配置"></a>2. 测试是否能够登陆到主库,校验之前主库的配置</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql -uslave -h 192.168.1.121 -pchangpan</span><br></pre></td></tr></table></figure>
<h5 id="3-配置从库的同步链接信息-登陆从库-Navicat中执行下面命令"><a href="#3-配置从库的同步链接信息-登陆从库-Navicat中执行下面命令" class="headerlink" title="3.配置从库的同步链接信息,登陆从库,Navicat中执行下面命令"></a>3.配置从库的同步链接信息,登陆从库,Navicat中执行下面命令</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">stop</span> <span class="keyword">slave</span>;      关闭从机同步连接</span><br><span class="line"><span class="keyword">change</span> <span class="keyword">master</span> <span class="keyword">to</span> master_host = <span class="string">'192.168.1.121'</span>, master_user=<span class="string">'slave'</span>, master_password =<span class="string">'changpan'</span>, master_log_file=<span class="string">'mysql-bin.000001'</span>,master_log_pos=<span class="number">593</span>;</span><br></pre></td></tr></table></figure>
<p>【注意】master_log_file,master_log_pos是主库中通过命令show master status查询到的数据</p>
<h5 id="4-开启同步-查看从库配置的有效性"><a href="#4-开启同步-查看从库配置的有效性" class="headerlink" title="4.开启同步,查看从库配置的有效性"></a>4.开启同步,查看从库配置的有效性</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span>；     开启同步连接</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">slave</span> <span class="keyword">status</span>;   查看主从机连接信息</span><br></pre></td></tr></table></figure>
<p>输入命令后查看下面的结果<br><img src="https://images.cnblogs.com/cnblogs_com/fxmemory/1028818/o_%e5%90%8c%e6%ad%a5%e7%8a%b6%e6%80%81.png" alt></p>
<h5 id="当上面查看到的状态中出现以下-两个值都为YES时-表示成功"><a href="#当上面查看到的状态中出现以下-两个值都为YES时-表示成功" class="headerlink" title="当上面查看到的状态中出现以下 两个值都为YES时,表示成功"></a>当上面查看到的状态中出现以下 两个值都为YES时,表示成功</h5><p>Slave_IO_Running:Yes<br>Slave_SQL_Running:Yes</p>
<h5 id="5-测试-在主库中添加一个新表或表中插入新的数据，进行测试"><a href="#5-测试-在主库中添加一个新表或表中插入新的数据，进行测试" class="headerlink" title="5. 测试,在主库中添加一个新表或表中插入新的数据，进行测试"></a>5. 测试,在主库中添加一个新表或表中插入新的数据，进行测试</h5><h4 id="已有主库-怎样在此基础上进行主从同步呢？"><a href="#已有主库-怎样在此基础上进行主从同步呢？" class="headerlink" title="已有主库,怎样在此基础上进行主从同步呢？"></a>已有主库,怎样在此基础上进行主从同步呢？</h4><h5 id="1-锁定或者阻断主库中的表进写操作-导出sql结构和数据"><a href="#1-锁定或者阻断主库中的表进写操作-导出sql结构和数据" class="headerlink" title="1.锁定或者阻断主库中的表进写操作,导出sql结构和数据"></a>1.锁定或者阻断主库中的表进写操作,导出sql结构和数据</h5><figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; FLUSH TABLES WITH READ LOCK;</span><br><span class="line">mysqldump -u root -p123456 <span class="comment">--opt -R openser &gt; openser20121203.sql；</span></span><br><span class="line">mysql&gt; UNLOCK TABLES;</span><br></pre></td></tr></table></figure>
<h5 id="2-从库中关闭同步链接，然后导入sql、"><a href="#2-从库中关闭同步链接，然后导入sql、" class="headerlink" title="2.从库中关闭同步链接，然后导入sql、"></a>2.从库中关闭同步链接，然后导入sql、</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">stop</span> <span class="keyword">slave</span>;</span><br></pre></td></tr></table></figure>
<h5 id="3-关闭从库链接-重启从库链接即可"><a href="#3-关闭从库链接-重启从库链接即可" class="headerlink" title="3.关闭从库链接,重启从库链接即可"></a>3.关闭从库链接,重启从库链接即可</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span>;</span><br></pre></td></tr></table></figure>
<h5 id="4-进行测试OK"><a href="#4-进行测试OK" class="headerlink" title="4.进行测试OK"></a>4.进行测试OK</h5>]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>主从复制</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA快捷键</title>
    <url>/2019/08/07/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h2 id="Ctrl"><a href="#Ctrl" class="headerlink" title="Ctrl"></a>Ctrl</h2><table>
<thead>
<tr>
<th style="text-align:left">快捷键</th>
<th style="text-align:left">介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Ctrl + F</td>
<td style="text-align:left">在当前文件进行文本查找 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + R</td>
<td style="text-align:left">在当前文件进行文本替换 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Z</td>
<td style="text-align:left">撤销 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Y</td>
<td style="text-align:left">删除光标所在行 或 删除选中的行 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + X</td>
<td style="text-align:left">剪切光标所在行 或 剪切选择内容</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + C</td>
<td style="text-align:left">复制光标所在行 或 复制选择内容</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + D</td>
<td style="text-align:left">复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + W</td>
<td style="text-align:left">递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + E</td>
<td style="text-align:left">显示最近打开的文件记录列表 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + N</td>
<td style="text-align:left">根据输入的 <strong>类名</strong> 查找类文件 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + G</td>
<td style="text-align:left">在当前文件跳转到指定行处</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + J</td>
<td style="text-align:left">插入自定义动态代码模板 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + P</td>
<td style="text-align:left">方法参数提示显示 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Q</td>
<td style="text-align:left">光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + U</td>
<td style="text-align:left">前往当前光标所在的方法的父类的方法 / 接口定义 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + B</td>
<td style="text-align:left">进入光标所在的方法/变量的接口或是定义处，等效于 <code>Ctrl + 左键单击</code> <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + K</td>
<td style="text-align:left">版本控制提交项目，需要此项目有加入到版本控制才可用</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + T</td>
<td style="text-align:left">版本控制更新项目，需要此项目有加入到版本控制才可用</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + H</td>
<td style="text-align:left">显示当前类的层次结构</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + O</td>
<td style="text-align:left">选择可重写的方法</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + I</td>
<td style="text-align:left">选择可继承的方法</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + +</td>
<td style="text-align:left">展开代码</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + -</td>
<td style="text-align:left">折叠代码</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + /</td>
<td style="text-align:left">注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + [</td>
<td style="text-align:left">移动光标到当前所在代码的花括号开始位置</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + ]</td>
<td style="text-align:left">移动光标到当前所在代码的花括号结束位置</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + F1</td>
<td style="text-align:left">在光标所在的错误代码处显示错误信息 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + F3</td>
<td style="text-align:left">调转到所选中的词的下一个引用位置 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + F4</td>
<td style="text-align:left">关闭当前编辑文件</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + F8</td>
<td style="text-align:left">在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + F9</td>
<td style="text-align:left">执行 Make Project 操作</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + F11</td>
<td style="text-align:left">选中文件 / 文件夹，使用助记符设定 / 取消书签 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + F12</td>
<td style="text-align:left">弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Tab</td>
<td style="text-align:left">编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + End</td>
<td style="text-align:left">跳到文件尾</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Home</td>
<td style="text-align:left">跳到文件头</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Space</td>
<td style="text-align:left">基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 <code>Ctrl + 逗号`</code>（必备）`</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Delete</td>
<td style="text-align:left">删除光标后面的单词或是中文句 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + BackSpace</td>
<td style="text-align:left">删除光标前面的单词或是中文句 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + 1,2,3…9</td>
<td style="text-align:left">定位到对应数值的书签位置 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + 左键单击</td>
<td style="text-align:left">在打开的文件标题上，弹出该文件路径 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + 光标定位</td>
<td style="text-align:left">按 Ctrl 不要松开，会显示光标所在的类信息摘要</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + 左方向键</td>
<td style="text-align:left">光标跳转到当前单词 / 中文句的左侧开头位置 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + 右方向键</td>
<td style="text-align:left">光标跳转到当前单词 / 中文句的右侧开头位置 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + 前方向键</td>
<td style="text-align:left">等效于鼠标滚轮向前效果 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + 后方向键</td>
<td style="text-align:left">等效于鼠标滚轮向后效果 <code>（必备）</code></td>
</tr>
</tbody>
</table>
<h2 id="Alt"><a href="#Alt" class="headerlink" title="Alt"></a>Alt</h2><table>
<thead>
<tr>
<th style="text-align:left">快捷键</th>
<th style="text-align:left">介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Alt + `</td>
<td style="text-align:left">显示版本控制常用操作菜单弹出层 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Alt + Q</td>
<td style="text-align:left">弹出一个提示，显示当前类的声明 / 上下文信息</td>
</tr>
<tr>
<td style="text-align:left">Alt + F1</td>
<td style="text-align:left">显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Alt + F2</td>
<td style="text-align:left">对于前面页面，显示各类浏览器打开目标选择弹出层</td>
</tr>
<tr>
<td style="text-align:left">Alt + F3</td>
<td style="text-align:left">选中文本，逐个往下查找相同文本，并高亮显示</td>
</tr>
<tr>
<td style="text-align:left">Alt + F7</td>
<td style="text-align:left">查找光标所在的方法 / 变量 / 类被调用的地方</td>
</tr>
<tr>
<td style="text-align:left">Alt + F8</td>
<td style="text-align:left">在 Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果</td>
</tr>
<tr>
<td style="text-align:left">Alt + Home</td>
<td style="text-align:left">定位 / 显示到当前文件的 <code>Navigation Bar</code></td>
</tr>
<tr>
<td style="text-align:left">Alt + Enter</td>
<td style="text-align:left">IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Alt + Insert</td>
<td style="text-align:left">代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Alt + 左方向键</td>
<td style="text-align:left">切换当前已打开的窗口中的子视图，比如Debug窗口中有Output、Debugger等子视图，用此快捷键就可以在子视图中切换 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Alt + 右方向键</td>
<td style="text-align:left">按切换当前已打开的窗口中的子视图，比如Debug窗口中有Output、Debugger等子视图，用此快捷键就可以在子视图中切换 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Alt + 前方向键</td>
<td style="text-align:left">当前光标跳转到当前文件的前一个方法名位置 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Alt + 后方向键</td>
<td style="text-align:left">当前光标跳转到当前文件的后一个方法名位置 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Alt + 1,2,3…9</td>
<td style="text-align:left">显示对应数值的选项卡，其中 1 是 Project 用得最多 <code>（必备）</code></td>
</tr>
</tbody>
</table>
<h2 id="Shift"><a href="#Shift" class="headerlink" title="Shift"></a><a href="https://github.com/judasn/IntelliJ-IDEA-Tutorial/blob/master/keymap-introduce.md#shift" target="_blank" rel="noopener"></a>Shift</h2><table>
<thead>
<tr>
<th style="text-align:left">快捷键</th>
<th style="text-align:left">介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Shift + F1</td>
<td style="text-align:left">如果有外部文档可以连接外部文档</td>
</tr>
<tr>
<td style="text-align:left">Shift + F2</td>
<td style="text-align:left">跳转到上一个高亮错误 或 警告位置</td>
</tr>
<tr>
<td style="text-align:left">Shift + F3</td>
<td style="text-align:left">在查找模式下，查找匹配上一个</td>
</tr>
<tr>
<td style="text-align:left">Shift + F4</td>
<td style="text-align:left">对当前打开的文件，使用新Windows窗口打开，旧窗口保留</td>
</tr>
<tr>
<td style="text-align:left">Shift + F6</td>
<td style="text-align:left">对文件 / 文件夹 重命名</td>
</tr>
<tr>
<td style="text-align:left">Shift + F7</td>
<td style="text-align:left">在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法</td>
</tr>
<tr>
<td style="text-align:left">Shift + F8</td>
<td style="text-align:left">在 Debug 模式下，跳出，表现出来的效果跟 <code>F9</code> 一样</td>
</tr>
<tr>
<td style="text-align:left">Shift + F9</td>
<td style="text-align:left">等效于点击工具栏的 <code>Debug</code> 按钮</td>
</tr>
<tr>
<td style="text-align:left">Shift + F10</td>
<td style="text-align:left">等效于点击工具栏的 <code>Run</code> 按钮</td>
</tr>
<tr>
<td style="text-align:left">Shift + F11</td>
<td style="text-align:left">弹出书签显示层 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Shift + Tab</td>
<td style="text-align:left">取消缩进 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Shift + ESC</td>
<td style="text-align:left">隐藏当前 或 最后一个激活的工具窗口</td>
</tr>
<tr>
<td style="text-align:left">Shift + End</td>
<td style="text-align:left">选中光标到当前行尾位置</td>
</tr>
<tr>
<td style="text-align:left">Shift + Home</td>
<td style="text-align:left">选中光标到当前行头位置</td>
</tr>
<tr>
<td style="text-align:left">Shift + Enter</td>
<td style="text-align:left">开始新一行。光标所在行下空出一行，光标定位到新行位置 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Shift + 左键单击</td>
<td style="text-align:left">在打开的文件名上按此快捷键，可以关闭当前打开文件 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Shift + 滚轮前后滚动</td>
<td style="text-align:left">当前文件的横向滚动轴滚动 <code>（必备）</code></td>
</tr>
</tbody>
</table>
<h2 id="Ctrl-Alt"><a href="#Ctrl-Alt" class="headerlink" title="Ctrl + Alt"></a><a href="https://github.com/judasn/IntelliJ-IDEA-Tutorial/blob/master/keymap-introduce.md#ctrl--alt" target="_blank" rel="noopener"></a>Ctrl + Alt</h2><table>
<thead>
<tr>
<th style="text-align:left">快捷键</th>
<th style="text-align:left">介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Ctrl + Alt + L</td>
<td style="text-align:left">格式化代码，可以对当前文件和整个包目录使用 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Alt + O</td>
<td style="text-align:left">优化导入的类，可以对当前文件和整个包目录使用 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Alt + I</td>
<td style="text-align:left">光标所在行 或 选中部分进行自动代码缩进，有点类似格式化</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Alt + T</td>
<td style="text-align:left">对选中的代码弹出环绕选项弹出层 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Alt + J</td>
<td style="text-align:left">弹出模板选择窗口，将选定的代码加入动态模板中</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Alt + H</td>
<td style="text-align:left">调用层次</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Alt + B</td>
<td style="text-align:left">在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Alt + C</td>
<td style="text-align:left">重构-快速提取常量</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Alt + F</td>
<td style="text-align:left">重构-快速提取成员变量</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Alt + V</td>
<td style="text-align:left">重构-快速提取变量</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Alt + Y</td>
<td style="text-align:left">同步、刷新</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Alt + S</td>
<td style="text-align:left">打开 IntelliJ IDEA 系统设置 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Alt + F7</td>
<td style="text-align:left">显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Alt + F11</td>
<td style="text-align:left">切换全屏模式</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Alt + Enter</td>
<td style="text-align:left">光标所在行上空出一行，光标定位到新行 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Alt + Home</td>
<td style="text-align:left">弹出跟当前文件有关联的文件弹出层</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Alt + Space</td>
<td style="text-align:left">类名自动完成</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Alt + 左方向键</td>
<td style="text-align:left">退回到上一个操作的地方 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Alt + 右方向键</td>
<td style="text-align:left">前进到上一个操作的地方 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Alt + 前方向键</td>
<td style="text-align:left">在查找模式下，跳到上个查找的文件</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Alt + 后方向键</td>
<td style="text-align:left">在查找模式下，跳到下个查找的文件</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Alt + 右括号（]）</td>
<td style="text-align:left">在打开多个项目的情况下，切换下一个项目窗口</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Alt + 左括号（[）</td>
<td style="text-align:left">在打开多个项目的情况下，切换上一个项目窗口</td>
</tr>
</tbody>
</table>
<h2 id="Ctrl-Shift"><a href="#Ctrl-Shift" class="headerlink" title="Ctrl + Shift"></a><a href="https://github.com/judasn/IntelliJ-IDEA-Tutorial/blob/master/keymap-introduce.md#ctrl--shift" target="_blank" rel="noopener"></a>Ctrl + Shift</h2><table>
<thead>
<tr>
<th style="text-align:left">快捷键</th>
<th style="text-align:left">介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Ctrl + Shift + F</td>
<td style="text-align:left">根据输入内容查找整个项目 或 指定目录内文件 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Shift + R</td>
<td style="text-align:left">根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Shift + J</td>
<td style="text-align:left">自动将下一行合并到当前行末尾 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Shift + Z</td>
<td style="text-align:left">取消撤销 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Shift + W</td>
<td style="text-align:left">递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Shift + N</td>
<td style="text-align:left">通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Shift + U</td>
<td style="text-align:left">对选中的代码进行大 / 小写轮流转换 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Shift + T</td>
<td style="text-align:left">对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Shift + C</td>
<td style="text-align:left">复制当前文件磁盘路径到剪贴板 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Shift + V</td>
<td style="text-align:left">弹出缓存的最近拷贝的内容管理器弹出层</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Shift + E</td>
<td style="text-align:left">显示最近修改的文件列表的弹出层</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Shift + H</td>
<td style="text-align:left">显示方法层次结构</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Shift + B</td>
<td style="text-align:left">跳转到类型声明处 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Shift + I</td>
<td style="text-align:left">快速查看光标所在的方法 或 类的定义</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Shift + A</td>
<td style="text-align:left">查找动作 / 设置</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Shift + /</td>
<td style="text-align:left">代码块注释 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Shift + [</td>
<td style="text-align:left">选中从光标所在位置到它的顶部中括号位置 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Shift + ]</td>
<td style="text-align:left">选中从光标所在位置到它的底部中括号位置 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Shift + +</td>
<td style="text-align:left">展开所有代码 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Shift + -</td>
<td style="text-align:left">折叠所有代码 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Shift + F7</td>
<td style="text-align:left">高亮显示所有该选中文本，按Esc高亮消失 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Shift + F8</td>
<td style="text-align:left">在 Debug 模式下，指定断点进入条件</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Shift + F9</td>
<td style="text-align:left">编译选中的文件 / 包 / Module</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Shift + F12</td>
<td style="text-align:left">编辑器最大化 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Shift + Space</td>
<td style="text-align:left">智能代码提示</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Shift + Enter</td>
<td style="text-align:left">自动结束代码，行末自动添加分号 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Shift + Backspace</td>
<td style="text-align:left">退回到上次修改的地方 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Shift + 1,2,3…9</td>
<td style="text-align:left">快速添加指定数值的书签 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Shift + 左键单击</td>
<td style="text-align:left">把光标放在某个类变量上，按此快捷键可以直接定位到该类中 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Shift + 左方向键</td>
<td style="text-align:left">在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Shift + 右方向键</td>
<td style="text-align:left">在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Shift + 前方向键</td>
<td style="text-align:left">光标放在方法名上，将方法移动到上一个方法前面，调整方法排序 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Shift + 后方向键</td>
<td style="text-align:left">光标放在方法名上，将方法移动到下一个方法前面，调整方法排序 <code>（必备）</code></td>
</tr>
</tbody>
</table>
<h2 id="Alt-Shift"><a href="#Alt-Shift" class="headerlink" title="Alt + Shift"></a><a href="https://github.com/judasn/IntelliJ-IDEA-Tutorial/blob/master/keymap-introduce.md#alt--shift" target="_blank" rel="noopener"></a>Alt + Shift</h2><table>
<thead>
<tr>
<th style="text-align:left">快捷键</th>
<th style="text-align:left">介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Alt + Shift + N</td>
<td style="text-align:left">选择 / 添加 task <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Alt + Shift + F</td>
<td style="text-align:left">显示添加到收藏夹弹出层 / 添加到收藏夹</td>
</tr>
<tr>
<td style="text-align:left">Alt + Shift + C</td>
<td style="text-align:left">查看最近操作项目的变化情况列表</td>
</tr>
<tr>
<td style="text-align:left">Alt + Shift + I</td>
<td style="text-align:left">查看项目当前文件</td>
</tr>
<tr>
<td style="text-align:left">Alt + Shift + F7</td>
<td style="text-align:left">在 Debug 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入</td>
</tr>
<tr>
<td style="text-align:left">Alt + Shift + F9</td>
<td style="text-align:left">弹出 <code>Debug</code> 的可选择菜单</td>
</tr>
<tr>
<td style="text-align:left">Alt + Shift + F10</td>
<td style="text-align:left">弹出 <code>Run</code> 的可选择菜单</td>
</tr>
<tr>
<td style="text-align:left">Alt + Shift + 左键双击</td>
<td style="text-align:left">选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Alt + Shift + 前方向键</td>
<td style="text-align:left">移动光标所在行向上移动 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Alt + Shift + 后方向键</td>
<td style="text-align:left">移动光标所在行向下移动 <code>（必备）</code></td>
</tr>
</tbody>
</table>
<h2 id="Ctrl-Shift-Alt"><a href="#Ctrl-Shift-Alt" class="headerlink" title="Ctrl + Shift + Alt"></a><a href="https://github.com/judasn/IntelliJ-IDEA-Tutorial/blob/master/keymap-introduce.md#ctrl--shift--alt" target="_blank" rel="noopener"></a>Ctrl + Shift + Alt</h2><table>
<thead>
<tr>
<th style="text-align:left">快捷键</th>
<th style="text-align:left">介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Ctrl + Shift + Alt + V</td>
<td style="text-align:left">无格式黏贴 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Shift + Alt + N</td>
<td style="text-align:left">前往指定的变量 / 方法</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Shift + Alt + S</td>
<td style="text-align:left">打开当前项目设置 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Shift + Alt + C</td>
<td style="text-align:left">复制参考信息</td>
</tr>
</tbody>
</table>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a><a href="https://github.com/judasn/IntelliJ-IDEA-Tutorial/blob/master/keymap-introduce.md#%E5%85%B6%E4%BB%96" target="_blank" rel="noopener"></a>其他</h2><table>
<thead>
<tr>
<th style="text-align:left">快捷键</th>
<th style="text-align:left">介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">F2</td>
<td style="text-align:left">跳转到下一个高亮错误 或 警告位置 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">F3</td>
<td style="text-align:left">在查找模式下，定位到下一个匹配处</td>
</tr>
<tr>
<td style="text-align:left">F4</td>
<td style="text-align:left">编辑源 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">F7</td>
<td style="text-align:left">在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中</td>
</tr>
<tr>
<td style="text-align:left">F8</td>
<td style="text-align:left">在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内</td>
</tr>
<tr>
<td style="text-align:left">F9</td>
<td style="text-align:left">在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上</td>
</tr>
<tr>
<td style="text-align:left">F11</td>
<td style="text-align:left">添加书签 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">F12</td>
<td style="text-align:left">回到前一个工具窗口 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">Tab</td>
<td style="text-align:left">缩进 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">ESC</td>
<td style="text-align:left">从工具窗口进入代码文件窗口 <code>（必备）</code></td>
</tr>
<tr>
<td style="text-align:left">连按两次Shift</td>
<td style="text-align:left">弹出 <code>Search Everywhere</code> 弹出层</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker常用命令</title>
    <url>/2019/08/07/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看本机的镜像,可通过该方法查看到镜像id等信息.</span><br><span class="line">docker images </span><br><span class="line"></span><br><span class="line">获取镜像 name：镜像名  [:tag]：版本，默认为最新的（也就是会自己加上一个参数:latest）</span><br><span class="line">docker pull [options] name[:tag]</span><br><span class="line"></span><br><span class="line">删除镜像,需要删除其下所有容器</span><br><span class="line">docker rmi &lt;镜像id&gt;</span><br><span class="line"></span><br><span class="line">运行镜像,构建出一个容器. -d表示后台运行. </span><br><span class="line">docker run -d image </span><br><span class="line">-p 8080:80  进行端口映射，将nginx的80端口映射到主机的8080端口上，也就是别人访问8080，可以访问到自己的80</span><br><span class="line"></span><br><span class="line">查看目前正在运行的容器</span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line">查看所有容器</span><br><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>
<h3 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">重要:xx表示不同的命令如，pull、run等。可以查看该命令的帮助，所有参数</span><br><span class="line">docker xx --help</span><br><span class="line"></span><br><span class="line">停止容器</span><br><span class="line">docker stop &lt;容器id&gt;</span><br><span class="line"></span><br><span class="line">删除容器</span><br><span class="line">docker rm &lt;容器id&gt;</span><br><span class="line"></span><br><span class="line">启动一个运行(run)过的容器</span><br><span class="line">docker start &lt;容器id&gt;</span><br><span class="line"></span><br><span class="line">在运行的容器中执行命令 </span><br><span class="line">docker exec [options] container command [arg...]</span><br><span class="line">例如:   </span><br><span class="line">docker exec -it &lt;容器id&gt; bash</span><br><span class="line">可以进入一个容器，和虚拟机中一样。也就是容器内部</span><br><span class="line"></span><br><span class="line">挂载目录:将宿主机的文件共享给容器</span><br><span class="line">docker run -d --name=test -v /opt/test:/usr/databases docker-test </span><br><span class="line">test是容器的名字，需唯一；</span><br><span class="line">-v表示创建一个数据卷并挂载到容器里，</span><br><span class="line">示例表示把宿主机的/opt/test目录挂载到容器的/usr/databases目录下；</span><br><span class="line">docker-test是镜像的名字</span><br><span class="line"></span><br><span class="line">查看容器当前信息,可在该命令的 Mounts信息中,找到挂载目录信息</span><br><span class="line">docker inspect &lt;容器id&gt;</span><br><span class="line"></span><br><span class="line">运行容器</span><br><span class="line">-d表示后台运行 -p表示设置端口映射， jpress是镜像名</span><br><span class="line">docker run -d -p  8888:8080 jpress</span><br><span class="line"></span><br><span class="line">运行mysql镜像</span><br><span class="line">docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -e MYSQL_DATABASE=xxx  images(镜像名)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch安装中文分词插件ik</title>
    <url>/2019/08/07/Elasticsearch%E5%AE%89%E8%A3%85%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>Elasticsearch自带standard分词只能把汉语分割成一个个字，而不能分词、分段，这就是我们需要分析器ik的地方了。</p>
<h3 id="安装结果"><a href="#安装结果" class="headerlink" title="安装结果:"></a>安装结果:</h3><p><code>http:`</code>//{ip}:9200/_analyze?analyzer=standard&amp;pretty=true&amp;text=sojson中华人民共和国`</p>
<p><img src="http://blog.nilaile.cn/blog/20190613/PXqmfSip2ESr.png" alt="mark"></p>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p>访问浏览器（虚拟机IP:9200）查看你elasticsearch的版本号<br><img src="http://blog.nilaile.cn/blog/20190613/r7kxHm3y7Ta2.png" alt="mark"></p>
<p><strong>一、下载ik的相应版本</strong></p>
<p>查看版本和下载链接<a href="https://github.com/medcl/elasticsearch-analysis-ik" target="_blank" rel="noopener">点击这里</a></p>
<p>这里提供5.0.0的ES及以前的版本对应的ik版本</p>
<p><img src="http://blog.nilaile.cn/blog/20190613/5oX0v1yjC6mz.png" alt="mark"></p>
<p><strong>二、下载的方式</strong></p>
<p>我这里的ES是2.3.5，对应的ik版本是1.9.5</p>
<p>在版本里选择1.9.5，点击 【Download ZIP】右键选择 – 复制链接地址</p>
<p><img src="https://images2015.cnblogs.com/blog/1059579/201702/1059579-20170207145657885-2081174365.png" alt></p>
<p><code>wget https://github.com/medcl/elasticsearch-analysis-ik/archive/v1.9.5.zip</code></p>
<p><strong>三、解包</strong>（如果没有unzip命令的使用  <strong>yum install zip unzip *</strong>  命令安装）</p>
<p><code>unzip v1.9.5.zip</code></p>
<p><strong>四、 打包</strong></p>
<p>因为是java的源码，需要用maven打包</p>
<p>进入解压后的目录elasticsearch-analysis-ik-1.10.1里面，输入下面命令进行打包</p>
<p><code>cd elasticsearch-analysis-ik-1.9.5/</code></p>
<p><code>mvn clean package</code></p>
<p>（注：如果没有mvn的可以直接使用 <strong>yum install java*</strong> 进行安装，把ES的环境也一起配置好）</p>
<p><strong>五、配置</strong></p>
<p>1、打包后，在当前目录下有target目录，进去，有一个releases目录，把里面的zip包复制到你安装ES目录下的plugins目录下的ik目录（ik目录需要手动添加）</p>
<p>查找ES插件路径可以使用命令<br><code>whereis elasticsearch</code></p>
<p>ES插件默认安装路径是：<br><code>/usr/share/elasticsearch/plugins/</code></p>
<p>mkdir -p /usr/share/elasticsearch/plugins/ik</p>
<p>cd target/releases/</p>
<p>mv elasticsearch-analysis-ik-1.9.5.zip /usr/share/elasticsearch/plugins/ik</p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>; “复制代码”)</p>
<p>2、使用unzip命令解包，并把zip包删除了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /usr/share/elasticsearch/plugins/</span><br><span class="line"></span><br><span class="line">unzip elasticsearch-analysis-ik-1.9.5.zip</span><br><span class="line"></span><br><span class="line">rm -rf elasticsearch-analysis-ik-1.9.5.zip</span><br></pre></td></tr></table></figure>
<p><strong>六、测试</strong></p>
<p>重启ES服务，查看ES的状态为（Active: active (running)）即可。</p>
<p>systemctl restart elasticsearch</p>
<p>systemctl status elasticsearch</p>
<p>如果需要具体测试的话，可以在官网git的下面介绍有（<a href="https://github.com/medcl/elasticsearch-analysis-ik/tree/v1.10.1" target="_blank" rel="noopener">点击查看</a>），简单的方法可以使用下面命令在浏览器访问确认</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://（虚拟机ip）:9200**/_analyze?analyzer=ik&amp;pretty=true&amp;text=helloworld,中华人民共和国&quot;</span><br></pre></td></tr></table></figure>
<p><img src="http://blog.nilaile.cn/blog/20190613/PXqmfSip2ESr.png" alt="mark"></p>
]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7.5使用NGINX配置https证书</title>
    <url>/2019/08/07/Centos7.5%E9%85%8D%E7%BD%AEHTTPS%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<h3 id="1-下载安装NGINX"><a href="#1-下载安装NGINX" class="headerlink" title="1. 下载安装NGINX"></a>1. 下载安装NGINX</h3><h3 id="2-修改配置文件（nginx一般安装在-etc-nginx下-配置文件一般会有两个，一个是-etc-nginx-nginx-conf-另一个是-etc-nginx-config-d-default-conf-nginx-conf中包含了default-conf）-通常我们通过修改default-conf"><a href="#2-修改配置文件（nginx一般安装在-etc-nginx下-配置文件一般会有两个，一个是-etc-nginx-nginx-conf-另一个是-etc-nginx-config-d-default-conf-nginx-conf中包含了default-conf）-通常我们通过修改default-conf" class="headerlink" title="2. 修改配置文件（nginx一般安装在/etc/nginx下,配置文件一般会有两个，一个是/etc/nginx/nginx.conf 另一个是/etc/nginx/config.d/default.conf,nginx.conf中包含了default.conf）,通常我们通过修改default.conf"></a>2. 修改配置文件（nginx一般安装在/etc/nginx下,配置文件一般会有两个，一个是/etc/nginx/nginx.conf 另一个是/etc/nginx/config.d/default.conf,nginx.conf中包含了default.conf）,通常我们通过修改default.conf</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim /etc/nginx/config.d/defualt.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#负载均衡配置</span><br><span class="line">upstream webservers_api &#123;</span><br><span class="line">        #weigth</span><br><span class="line">        ip_hash;</span><br><span class="line">        server 127.0.0.1:8086 max_fails=1  fail_timeout=10s;</span><br><span class="line">        #server 127.0.0.1:8081 max_fails=1  fail_timeout=3600s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 443;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate  /usr/local/TencentCloud/httpsCert/www.baidu.com.pem;</span><br><span class="line">    ssl_certificate_key /usr/local/TencentCloud/httpsCert/www.baidu.com.key;</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    proxy_set_header Host $host;</span><br><span class="line">    proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">    access_log /usr/local/web/nginxLogs;</span><br><span class="line"></span><br><span class="line">   #静态文件</span><br><span class="line">   location / &#123;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        root   /usr/local/web/dist;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">        try_files $uri $uri/ @router;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #下载文件时把下载文件放在该目录下</span><br><span class="line">    location ~* \.(exe|apk|zip)$ &#123;</span><br><span class="line">        root /usr/local/web/download;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location @router &#123;</span><br><span class="line">            rewrite ^.*$ /index.html last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   location /hlwyy/api/ &#123;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_pass http://webservers_api; #跳转到api的负载均衡服务器</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  www.nilaie.com nilaie.com; #多个域名以空格隔开（替换为自己的域名）</span><br><span class="line">    rewrite ^(.*)$  https://$host$1 permanent;</span><br><span class="line">    #charset koi8-r;</span><br><span class="line">    #access_log  /var/log/nginx/host.access.log  main;</span><br><span class="line">    proxy_set_header Host $host;</span><br><span class="line">    proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">    rewrite ^(.*)$  https://$&#123;server_name&#125;$1 permanent;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装Mysql</title>
    <url>/2019/08/07/Docker%E5%AE%89%E8%A3%85Mysql/</url>
    <content><![CDATA[<h3 id="方法一、docker-pull-mysql"><a href="#方法一、docker-pull-mysql" class="headerlink" title="方法一、docker pull mysql"></a>方法一、docker pull mysql</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">runoob@runoob:/mysql$ docker search mysql</span><br></pre></td></tr></table></figure>
<h3 id="2-获取-docker-pull-mysql-5-6"><a href="#2-获取-docker-pull-mysql-5-6" class="headerlink" title="2. 获取 docker pull mysql:5.6"></a>2. 获取 <code>docker pull mysql:5.6</code></h3><p>等待下载完成后，我们就可以在本地镜像列表里查到REPOSITORY为mysql,标签为5.7的镜像。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker images| grep mysql</span><br><span class="line">mysql         5.7        a1aa4f76fab9        2 days ago        373MB</span><br></pre></td></tr></table></figure>
<h3 id="方法二、通过-Dockerfile构建"><a href="#方法二、通过-Dockerfile构建" class="headerlink" title="方法二、通过 Dockerfile构建"></a>方法二、通过 Dockerfile构建</h3><p>1.首先创建目录mysql,用于存放后面的相关东西。</p>
<p><code>runoob@runoob:~$ mkdir -p ~/mysql/data ~/mysql/logs ~/mysql/conf</code></p>
<p>data目录将映射为mysql容器配置的数据文件存放路径<br>logs目录将映射为mysql容器的日志目录<br>conf目录里的配置文件将映射为mysql容器的配置文件</p>
<p>2.进入创建的mysql目录，创建Dockerfile文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM debian:jessie # add our user and group first to make sure their IDs get assigned consistently, regardless of whatever dependencies get added RUN groupadd -r mysql &amp;&amp; useradd -r -g mysql mysql # add gosu for easy step-down from root ENV GOSU_VERSION 1.7 RUN set  -x \</span><br><span class="line">    &amp;&amp; apt-get update &amp;&amp; apt-get install -y --no-install-recommends ca-certificates wget &amp;&amp; rm -rf /var/lib/apt/lists/* \</span><br><span class="line">    &amp;&amp; wget -O /usr/local/bin/gosu &quot;https://github.com/tianon/gosu/releases/download/$GOSU_VERSION/gosu-$(dpkg --print-architecture)&quot; \</span><br><span class="line">    &amp;&amp; wget -O /usr/local/bin/gosu.asc &quot;https://github.com/tianon/gosu/releases/download/$GOSU_VERSION/gosu-$(dpkg --print-architecture).asc&quot; \</span><br><span class="line">    &amp;&amp; export GNUPGHOME=&quot;$(mktemp -d)&quot; \</span><br><span class="line">    &amp;&amp; gpg --keyserver ha.pool.sks-keyservers.net --recv-keys B42F6819007F00F88E364FD4036A9C25BF357DD4 \</span><br><span class="line">    &amp;&amp; gpg --batch --verify /usr/local/bin/gosu.asc /usr/local/bin/gosu \</span><br><span class="line">    &amp;&amp; rm -r &quot;$GNUPGHOME&quot; /usr/local/bin/gosu.asc \</span><br><span class="line">    &amp;&amp; chmod +x /usr/local/bin/gosu \</span><br><span class="line">    &amp;&amp; gosu nobody true \</span><br><span class="line">    &amp;&amp; apt-get purge -y --auto-remove ca-certificates wget</span><br><span class="line"></span><br><span class="line">RUN mkdir /docker-entrypoint-initdb.d</span><br><span class="line"></span><br><span class="line"># FATAL ERROR: please install the following Perl modules before executing /usr/local/mysql/scripts/mysql_install_db:</span><br><span class="line"># File::Basename</span><br><span class="line"># File::Copy</span><br><span class="line"># Sys::Hostname</span><br><span class="line"># Data::Dumper</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y perl pwgen --no-install-recommends &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line"></span><br><span class="line"># gpg: key 5072E1F5: public key &quot;MySQL Release Engineering &lt;mysql-build@oss.oracle.com&gt;&quot; imported</span><br><span class="line">RUN apt-key adv --keyserver ha.pool.sks-keyservers.net --recv-keys A4A9406876FCBD3C456770C88C718D3B5072E1F5</span><br><span class="line"></span><br><span class="line">ENV MYSQL_MAJOR 5.6</span><br><span class="line">ENV MYSQL_VERSION 5.6.31-1debian8</span><br><span class="line"></span><br><span class="line">RUN echo &quot;deb http://repo.mysql.com/apt/debian/ jessie mysql-$&#123;MYSQL_MAJOR&#125;&quot; &gt; /etc/apt/sources.list.d/mysql.list</span><br><span class="line"></span><br><span class="line"># the &quot;/var/lib/mysql&quot; stuff here is because the mysql-server postinst doesn&apos;t have an explicit way to disable the mysql_install_db codepath besides having a database already &quot;configured&quot; (ie, stuff in /var/lib/mysql/mysql)</span><br><span class="line"># also, we set debconf keys to make APT a little quieter</span><br><span class="line">RUN &#123; \</span><br><span class="line">        echo mysql-community-server mysql-community-server/data-dir select &apos;&apos;; \</span><br><span class="line">        echo mysql-community-server mysql-community-server/root-pass password &apos;&apos;; \</span><br><span class="line">        echo mysql-community-server mysql-community-server/re-root-pass password &apos;&apos;; \</span><br><span class="line">        echo mysql-community-server mysql-community-server/remove-test-db select false; \</span><br><span class="line">    &#125; | debconf-set-selections \</span><br><span class="line">    &amp;&amp; apt-get update &amp;&amp; apt-get install -y mysql-server=&quot;$&#123;MYSQL_VERSION&#125;&quot; &amp;&amp; rm -rf /var/lib/apt/lists/* \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/mysql &amp;&amp; mkdir -p /var/lib/mysql /var/run/mysqld \</span><br><span class="line">    &amp;&amp; chown -R mysql:mysql /var/lib/mysql /var/run/mysqld \</span><br><span class="line"># ensure that /var/run/mysqld (used for socket and lock files) is writable regardless of the UID our mysqld instance ends up having at runtime</span><br><span class="line">    &amp;&amp; chmod 777 /var/run/mysqld</span><br><span class="line"></span><br><span class="line"># comment out a few problematic configuration values</span><br><span class="line"># don&apos;t reverse lookup hostnames, they are usually another container</span><br><span class="line">RUN sed -Ei &apos;s/^(bind-address|log)/#&amp;/&apos; /etc/mysql/my.cnf \</span><br><span class="line">    &amp;&amp; echo &apos;skip-host-cache\nskip-name-resolve&apos; | awk &apos;&#123; print &#125; $1 == &quot;[mysqld]&quot; &amp;&amp; c == 0 &#123; c = 1; system(&quot;cat&quot;) &#125;&apos; /etc/mysql/my.cnf &gt; /tmp/my.cnf \</span><br><span class="line">    &amp;&amp; mv /tmp/my.cnf /etc/mysql/my.cnf</span><br><span class="line"></span><br><span class="line">VOLUME /var/lib/mysql</span><br><span class="line"></span><br><span class="line">COPY docker-entrypoint.sh /usr/local/bin/</span><br><span class="line">RUN ln -s usr/local/bin/docker-entrypoint.sh /entrypoint.sh # backwards compat</span><br><span class="line">ENTRYPOINT [&quot;docker-entrypoint.sh&quot;]</span><br><span class="line"></span><br><span class="line">EXPOSE 3306</span><br><span class="line">CMD [&quot;mysqld&quot;]</span><br></pre></td></tr></table></figure></p>
<p>通过Dockerfile创建一个镜像，替换成你自己的名字</p>
<p><code>runoob@runoob:~/mysql$ docker build -t mysql .</code></p>
<p>创建完成后，我们可以在本地的镜像列表里查找到刚刚创建的镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images |grep mysql</span><br><span class="line">mysql 5.6  2c0964ec182a  3 weeks ago 329 MB</span><br></pre></td></tr></table></figure>
<h2 id="使用mysql镜像"><a href="#使用mysql镜像" class="headerlink" title="使用mysql镜像"></a>使用mysql镜像</h2><h3 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">docker run -p 13306:3306 --name mymysql -v $PWD/conf:/etc/mysql/conf.d -v $PWD/logs:/logs -v $PWD/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456  -d mysql:5.7</span><br></pre></td></tr></table></figure>
<p>命令说明：</p>
<ul>
<li><strong>–name mymysql</strong>：定义容器的别名。</li>
<li></li>
<li><p><strong>-p 3306:3306</strong>：将容器的 3306 端口映射到主机的 13306 端口。</p>
</li>
<li><p><strong>-v $PWD/conf:/etc/mysql/conf.d</strong>：将主机当前目录下的 conf/my.cnf 挂载到容器的 /etc/mysql/my.cnf。</p>
</li>
<li><p><strong>-v $PWD/logs:/logs</strong>：将主机当前目录下的 logs 目录挂载到容器的 /logs。</p>
</li>
<li><p><strong>-v $PWD/data:/var/lib/mysql</strong> ：将主机当前目录下的data目录挂载到容器的 /var/lib/mysql 。</p>
</li>
<li><p><strong>-e MYSQL_ROOT_PASSWORD=123456：</strong>初始化 root 用户的密码。</p>
</li>
</ul>
<h3 id="查看容器启动情况"><a href="#查看容器启动情况" class="headerlink" title="查看容器启动情况"></a>查看容器启动情况</h3><p><code>[root@localhost ~]# docker ps</code></p>
<p><img src="http://blog.nilaile.cn/blog/20190613/B9qkTex9gJfj.png" alt="mark"></p>
<h3 id="重启docker中的Mysql-可以通过CONTAINER-ID-或者容器的Name"><a href="#重启docker中的Mysql-可以通过CONTAINER-ID-或者容器的Name" class="headerlink" title="重启docker中的Mysql(可以通过CONTAINER ID 或者容器的Name)"></a>重启docker中的Mysql(可以通过CONTAINER ID 或者容器的Name)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker restart mymysql</span><br></pre></td></tr></table></figure>
<p>或者<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker restart f75c3467f92e</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7.5安装Elasticsearch2.3.5</title>
    <url>/2019/08/07/Centos7.5%E5%AE%89%E8%A3%85Elasticsearch/</url>
    <content><![CDATA[<blockquote>
<p> Elasticsearch是一个基于Lucene的搜索服务器,它需要依赖于java环境,所以需要先安装了JDK</p>
</blockquote>
<h3 id="安装方法一（下载rpm包方式）"><a href="#安装方法一（下载rpm包方式）" class="headerlink" title="安装方法一（下载rpm包方式）"></a>安装方法一（下载rpm包方式）</h3><p><strong> 1.百度elasticsearch,点击官网网址</strong></p>
<p><strong> <img src="https://images2015.cnblogs.com/blog/1059579/201702/1059579-20170207111519713-1843270100.png" alt></strong></p>
<p> 2.点击Downloads，选择past releases</p>
<p><img src="https://images2015.cnblogs.com/blog/1059579/201702/1059579-20170207111941963-554816516.png" alt></p>
<p>3.找到2.3.5的版本，（由于elasticsearch更新太快，插件更新进度跟不上，2.3.5的版本插件最齐全）</p>
<p><img src="https://images2015.cnblogs.com/blog/1059579/201702/1059579-20170207112356557-1829265054.png" alt></p>
<p>4.右键点击RPM选择 – 复制连接地址</p>
<p><img src="https://images2015.cnblogs.com/blog/1059579/201702/1059579-20170207112633619-1394926966.png" alt></p>
<p>5.在根目录下载rmp包</p>
<p><code>wget https://download.elastic.co/elasticsearch/release/org/elasticsearch/distribution/rpm/elasticsearch/2.3.5/elasticsearch-2.3.5.rpm</code></p>
<p>6.执行下面的命令,安装完成后按照提示操作,即可</p>
<p><code>rpm -ivh elasticsearch-2.3.5.rpm</code></p>
<p>7.启动并查看安装状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start elasticsearch</span><br><span class="line"></span><br><span class="line">systemctl status elasticsearch</span><br></pre></td></tr></table></figure>
<p>8.本地查看版本信息</p>
<p><code>curl  http://127.0.0.1:9200</code></p>
<p><img src="https://images2015.cnblogs.com/blog/1059579/201702/1059579-20170207113314791-1988726404.png" alt></p>
<p>9.查找elasticsearch 安装路径与配置路径，并且配置</p>
<p>whereis elasticsearch</p>
<p><img src="https://images2015.cnblogs.com/blog/1059579/201702/1059579-20170207113451932-347145346.png" alt></p>
<p><code>vim /etc/elasticsearch/elasticsearch.yml</code></p>
<p>修改：<br>  <img src="http://blog.nilaile.cn/blog/20190613/38Ej7AxkGxTd.png" alt="mark"></p>
<p> 这样就可以在window系统用浏览器通过访问虚拟机的ip:port</p>
<p>保存退出后重启elasticsearch</p>
<p><code>systemctl restart elasticsearch</code></p>
<p>在浏览器访问虚拟机ip:9200<br><img src="http://blognilaile.cn/blog/20190613/3HR3guW0ew98.png" alt="mark"></p>
<h3 id="安装方法二-yum方式安装"><a href="#安装方法二-yum方式安装" class="headerlink" title="安装方法二 (yum方式安装)"></a>安装方法二 (yum方式安装)</h3><p>一、ES的yum安装配置</p>
<p>由于ES不在yum的本地源，所以我们需要添加ES的yum配置。</p>
<p>1、下载并安装ES的yum公钥</p>
<p><code>rpm --import https:`</code>//packages.elastic.co/GPG-KEY-elasticsearch`</p>
<p>2、配置ES的yum源<br><code>vim /etc/yum.repos.d/elasticsearch.repo</code></p>
<p> 输入下面的内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[elasticsearch-2.x]</span><br><span class="line">name=Elasticsearch repository for 2.x packages</span><br><span class="line">baseurl=http://packages.elastic.co/elasticsearch/2.x/centos</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=http://packages.elastic.co/GPG-KEY-elasticsearch</span><br><span class="line">enabled=1</span><br></pre></td></tr></table></figure></p>
<p>二、yum安装ES</p>
<p>1、更新yum的缓存<br><code>yum makecache</code></p>
<p>2、安装ES<br><code>yum install elasticsearch</code></p>
<p>三、测试ES</p>
<p>1、配置和启动ES服务器进程</p>
<p><code>/sbin/chkconfig --add elasticsearch</code></p>
<p><code>systemctl start elasticsearch</code></p>
<p>2、查看状态</p>
<p><code>systemctl status elasticsearch</code></p>
<p>3、运行测试<br><code>curl -X GET localhost:9200</code></p>
<p>返回的json结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot; : &quot;Live Wire&quot;,</span><br><span class="line">  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,</span><br><span class="line">  &quot;version&quot; : &#123;</span><br><span class="line">    &quot;number&quot; : &quot;2.3.5&quot;,</span><br><span class="line">    &quot;build_hash&quot; : &quot;90f439ff60a3c0f497f91663701e64ccd01edbb4&quot;,</span><br><span class="line">    &quot;build_timestamp&quot; : &quot;2016-07-27T10:36:52Z&quot;,</span><br><span class="line">    &quot;build_snapshot&quot; : false,</span><br><span class="line">    &quot;lucene_version&quot; : &quot;5.5.0&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;tagline&quot; : &quot;You Know, for Search&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>四、通过IP访问ES的配置（同方法一配置方法一样）<br>1、打开/etc/elasticsearch/elasticsearch.yml<br><code>vim /etc/elasticsearch/elasticsearch.yml</code></p>
<p> network.host-&gt; 把后面改为0.0.0.0或者虚拟机ip地址，<br> http.port-&gt; 去掉注释<br>  <img src="http://blognilaile.cn/blog/20190613/38Ej7AxkGxTd.png" alt="mark"></p>
<p> 这样就可以在window系统用浏览器通过访问虚拟机的ip:port<br><img src="http://blognilaile.cn/blog/20190613/3HR3guW0ew98.png" alt="mark"></p>
<h3 id="安装中文分词插件参考https-www-cnblogs-com-shifu204-p-6374234-html"><a href="#安装中文分词插件参考https-www-cnblogs-com-shifu204-p-6374234-html" class="headerlink" title="安装中文分词插件参考https://www.cnblogs.com/shifu204/p/6374234.html"></a>安装中文分词插件参考<a href="https://www.cnblogs.com/shifu204/p/6374234.html" target="_blank" rel="noopener">https://www.cnblogs.com/shifu204/p/6374234.html</a></h3>]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7.5增加swap分区</title>
    <url>/2019/08/07/Centos7.5%E8%B0%83%E6%95%B4swap%E5%88%86%E5%8C%BA/</url>
    <content><![CDATA[<p>先用free -m查看一下swap的大小</p>
<p><img src="https://files.jb51.net/file_images/article/201804/201841291807170.png?201831291819" alt></p>
<p>1.添加swap分区 </p>
<p>使用dd命令创建/home/swap这么一个分区文件。文件的大小是2048000  个block，一般情况下1个block为1K，所以这里空间是2G。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dd if=/dev/zero of=/var/swapfile bs=1024 count=2048000  //添加交换文件并设置其大小为2G</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdn.net/20180627095255111?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYnpoYnpoYmJhYnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt> </p>
<p>2.执行完毕，对交换文件格式化并转换为swap分区： </p>
<p>mkswap /var/swapfile</p>
<p><img src="https://img-blog.csdn.net/20180627095317795?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYnpoYnpoYmJhYnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p>
<p>3.挂载并激活分区： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">swapon /var/swapfile</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdn.net/20180627095340170?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYnpoYnpoYmJhYnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p>
<p>4 赋权限 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod -R 0600 /var/swapfile</span><br></pre></td></tr></table></figure>
<p>现在再用free -m命令查看一下内存和swap分区大小，就发现增加了2G的空间了。</p>
<p>注意当计算机重启了以后，发现swap还是原来那么大，新的swap没有自动启动，还要手动启动。那我们需要修改/etc/fstab文件</p>
<p>5.设置开机自动挂载该分区：<br>vi /etc/fstab<br>在fstab文件末尾追加如下内容后:wq!保存即可： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/var/swapfile swap swap defaults 0 0</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>swap</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7.5安装RocketMq</title>
    <url>/2019/08/07/Centos7.5%E5%AE%89%E8%A3%85RocketMq/</url>
    <content><![CDATA[<h3 id="1、下载apache最新rocketmq二进制压缩文件"><a href="#1、下载apache最新rocketmq二进制压缩文件" class="headerlink" title="1、下载apache最新rocketmq二进制压缩文件"></a>1、下载apache最新rocketmq二进制压缩文件</h3><p>下载地址：<a href="https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.2.0/rocketmq-all-4.2.0-bin-release.zip" target="_blank" rel="noopener">https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.2.0/rocketmq-all-4.2.0-bin-release.zip</a></p>
<p>下载命令：wget <a href="https://mirrors.tuna.tsinghua.edu.cn/apache/rocketmq/4.2.0/rocketmq-all-4.2.0-bin-release.zip" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/apache/rocketmq/4.2.0/rocketmq-all-4.2.0-bin-release.zip</a></p>
<h3 id="2、解压安装"><a href="#2、解压安装" class="headerlink" title="2、解压安装"></a>2、解压安装</h3><p>解压命令：unzip -d /dirname rocketmq-all-4.2.0-bin-release.zip</p>
<h3 id="3、环境变量"><a href="#3、环境变量" class="headerlink" title="3、环境变量"></a>3、环境变量</h3><p>nameserver环境变量：vi /etc/profile</p>
<p>添加：export NAMESRV_ADDR=127.0.0.1:9876</p>
<h4 id="4、启动"><a href="#4、启动" class="headerlink" title="4、启动"></a>4、启动</h4><p>bin目录，启动nameserver和broker：</p>
<p>nohup sh mqnamesrv &gt;mqname.log &amp;</p>
<p>nohup sh mqbroker -n localhost:9876 &gt;mqbroker.log &amp;</p>
<p>查看进程：jps</p>
<p>启动broker时会卡顿，因为虚拟机内存和broker配置内存跟不上。</p>
<p>设置：给虚拟机预留1g的内存，这样启动时不太会卡：虚拟机设2g，nameserver和broker共用1g</p>
<h4 id="5、启动失败"><a href="#5、启动失败" class="headerlink" title="5、启动失败"></a>5、启动失败</h4><p>查看启动日志：cat nohup.out</p>
<p>启动失败： Native memory allocation (malloc) failed to allocate 8589934592 bytes for committing reserved memory.</p>
<p>因为nameserver和broker的默认配置内存超过虚拟机的内存，需根据宿主机配置调整虚拟机内存，并调整nameserver和broker的默认内存配置。</p>
<p>bin目录：</p>
<p>vi runserver.sh<br><img src="http://blog.nilaile.cn/blog/20190613/Ym57z2V1GoSG.png" alt="mark"></p>
<p>vi runbroker.sh<br><img src="http://blog.nilaile.cn/blog/20190613/MAdIT4CchpyP.png" alt="mark"></p>
<p>参考文章</p>
<p>[<a href="https://www.jianshu.com/p/04a98ba770a4]" target="_blank" rel="noopener">https://www.jianshu.com/p/04a98ba770a4]</a><br>[<a href="https://blog.csdn.net/paincupid/article/details/81333138]" target="_blank" rel="noopener">https://blog.csdn.net/paincupid/article/details/81333138]</a></p>
]]></content>
      <categories>
        <category>RocketMq</category>
      </categories>
      <tags>
        <tag>RocketMq</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2019/08/07/Centos7%20%E5%AE%89%E8%A3%85Docker/</url>
    <content><![CDATA[<h2 id="Centos7-安装Docker"><a href="#Centos7-安装Docker" class="headerlink" title="Centos7 安装Docker"></a>Centos7 安装Docker</h2><p>安装参考：<a href="https://blog.csdn.net/u010046908/article/details/79553227" target="_blank" rel="noopener">https://blog.csdn.net/u010046908/article/details/79553227</a><br>安装最新版本 <a href="https://blog.csdn.net/kongxx/article/details/78361048" target="_blank" rel="noopener">https://blog.csdn.net/kongxx/article/details/78361048</a></p>
<p>阿里云镜像仓库地址： <a href="https://dev.aliyun.com/search.html" target="_blank" rel="noopener">https://dev.aliyun.com/search.html</a></p>
<p>常用命令<br>docker pull centos  拉取centos<br>docker images 查看本地所有镜像<br>docker run hello-world 运行实例</p>
<p>docker run -i -t -v /root/sortware/:/mnt/sortware/ 75835a67d134 /bin/bash</p>
<h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><p>exit</p>
<h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><p>docker stop mycentos</p>
<h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><p>docker start mycentos</p>
<h3 id="重启后-在mycentos再打开-bin-bash"><a href="#重启后-在mycentos再打开-bin-bash" class="headerlink" title="重启后,在mycentos再打开/bin/bash"></a>重启后,在mycentos再打开/bin/bash</h3><p>docker exec -ti mycentos /bin/bash</p>
<p>1、初步安装和启动docker<br>yum update -y<br>yum -y install docker<br>systemctl start docker</p>
<p>2、设置镜像<br>vi /etc/docker/daemon.json</p>
<p>{<br>  “registry-mirrors”: [“<a href="https://aj2rgad5.mirror.aliyuncs.com&quot;]" target="_blank" rel="noopener">https://aj2rgad5.mirror.aliyuncs.com&quot;]</a><br>}</p>
<p>3、重启docker<br>systemctl daemon-reload<br>systemctl restart docker.service</p>
<p>4、测试docker是否正常安装和运行<br>docker run hello-world</p>
<p>5、查看结果<br>Hello from Docker!</p>
]]></content>
  </entry>
  <entry>
    <title>Cenos7.5环境搭建目录</title>
    <url>/2019/08/07/Cenos7.5%E6%90%AD%E5%BB%BA%E7%94%9F%E6%88%90%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h3 id="1-Linux-设置服务器时区"><a href="#1-Linux-设置服务器时区" class="headerlink" title="1.Linux 设置服务器时区:"></a>1.Linux 设置服务器时区:</h3><p>1、安装ntp服务软件包：yum install ntp<br>2、将ntp设置为缺省启动：systemctl enable ntpd<br>3、修改启动参数，增加-g -x参数，允许ntp服务在系统时间误差较大时也能正常工作：vi /etc/sysconfig/ntpd<br>4、启动ntp服务：/bin/systemctl restart ntpd<br>5、将系统时区改为上海时间（即CST时区）：ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime<br>6、输入date命令查看时间是否正确</p>
<h3 id="2-搭建FTP-vsftp"><a href="#2-搭建FTP-vsftp" class="headerlink" title="2. 搭建FTP(vsftp)"></a>2. 搭建FTP(vsftp)</h3><p><a href="https://blog.csdn.net/zy517863543/article/details/80028351" target="_blank" rel="noopener">https://blog.csdn.net/zy517863543/article/details/80028351</a></p>
<p>  遇到的问题：<br>  1.安装成功后, Filezilla可以正常上传下载文件，但是java程序中使用Ftp工具类无法上传成功？<br>   解决方法： 程序中需要指定使用被动模式</p>
<h3 id="3-搭建SFTP"><a href="#3-搭建SFTP" class="headerlink" title="3.搭建SFTP"></a>3.搭建SFTP</h3><p>参考博客(<a href="https://blog.csdn.net/fenglailea/article/details/78631760" target="_blank" rel="noopener">https://blog.csdn.net/fenglailea/article/details/78631760</a>)</p>
<h3 id="4-下载并安装redis"><a href="#4-下载并安装redis" class="headerlink" title="4.下载并安装redis"></a>4.下载并安装redis</h3><p><a href="https://www.cnblogs.com/zuidongfeng/p/8032505.html" target="_blank" rel="noopener">https://www.cnblogs.com/zuidongfeng/p/8032505.html</a></p>
<p>遇到的问题: <a href="https://blog.csdn.net/jexhen/article/details/76098622" target="_blank" rel="noopener">https://blog.csdn.net/jexhen/article/details/76098622</a><br>复制到etc下的配置<br>/etc/redis/6379.conf (自动启动时生效的是这个,两个配置文件做好同步)</p>
<h3 id="5-搭建java环境"><a href="#5-搭建java环境" class="headerlink" title="5.搭建java环境"></a>5.搭建java环境</h3><p><a href="https://blog.csdn.net/sizhezhongnian/article/details/81142976" target="_blank" rel="noopener">https://blog.csdn.net/sizhezhongnian/article/details/81142976</a><br>JAVA根目录: /usr/java/jdk1.8</p>
<h3 id="6-搭建并配置NGINX服务器"><a href="#6-搭建并配置NGINX服务器" class="headerlink" title="6.搭建并配置NGINX服务器"></a>6.搭建并配置NGINX服务器</h3><p>安装第三方yum源</p>
<h4 id="安装下载wget"><a href="#安装下载wget" class="headerlink" title="安装下载wget"></a>安装下载wget</h4><p>yum install wget</p>
<h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>wget <a href="http://www.atomicorp.com/installers/atomic" target="_blank" rel="noopener">http://www.atomicorp.com/installers/atomic</a></p>
<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>sh ./atomic</p>
<h4 id="更新yum源"><a href="#更新yum源" class="headerlink" title="更新yum源"></a>更新yum源</h4><p>yum check-update</p>
<p>开始安装nginx</p>
<h4 id="删除系统自带的软件包"><a href="#删除系统自带的软件包" class="headerlink" title="删除系统自带的软件包"></a>删除系统自带的软件包</h4><p>yum remove httpd<em> php</em></p>
<h4 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h4><p>yum install -y nginx</p>
<h4 id="设置nginx开机启动"><a href="#设置nginx开机启动" class="headerlink" title="设置nginx开机启动"></a>设置nginx开机启动</h4><p>chkconfig nginx on</p>
<h4 id="启动nginx"><a href="#启动nginx" class="headerlink" title="启动nginx"></a>启动nginx</h4><p>service nginx start</p>
<h3 id="7-搭建TOMCAT及参数优化"><a href="#7-搭建TOMCAT及参数优化" class="headerlink" title="7. 搭建TOMCAT及参数优化"></a>7. 搭建TOMCAT及参数优化</h3><p>安装tomcat,并配置多tomcat<br><a href="https://blog.csdn.net/w410589502/article/details/77988912" target="_blank" rel="noopener">https://blog.csdn.net/w410589502/article/details/77988912</a><br><a href="https://blog.csdn.net/weixin_41004350/article/details/78492500" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41004350/article/details/78492500</a></p>
<h3 id="8-安装MYSQL-5-7-数据库"><a href="#8-安装MYSQL-5-7-数据库" class="headerlink" title="8. 安装MYSQL(5.7) 数据库"></a>8. 安装MYSQL(5.7) 数据库</h3><p>参考博客: <a href="https://www.cnblogs.com/freely/p/8087885.html" target="_blank" rel="noopener">https://www.cnblogs.com/freely/p/8087885.html</a></p>
<p>添加用户,授权用户</p>
<p><a href="https://www.cnblogs.com/xujishou/p/6306765.html" target="_blank" rel="noopener">https://www.cnblogs.com/xujishou/p/6306765.html</a></p>
<p>配置文件 vim /etc/my.cnf<br>注意更改端口号为13306 需要加入防火墙</p>
<p>Mysql授权失败错误问题</p>
<p>执行命令: grant all on <em>.</em> to hospital@’%’</p>
<p>授权只能访问某库</p>
<p>grant all privileges on ky.*  to  hospital@’%’ identified by ‘Fv6jl#cxhd3&amp;0vx8’</p>
<p>执行完要刷新权限  flush privileges;</p>
<p>ERROR 1819 (HY000): Your password does not satisfy the current policy requirements</p>
<p><a href="https://www.cnblogs.com/ivictor/p/5142809.html" target="_blank" rel="noopener">https://www.cnblogs.com/ivictor/p/5142809.html</a></p>
<h3 id="9-防火墙配置及管理"><a href="#9-防火墙配置及管理" class="headerlink" title="9. 防火墙配置及管理"></a>9. 防火墙配置及管理</h3><p>CentOS7使用firewalld打开关闭防火墙与端口</p>
<p>1、firewalld的基本使用<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">启动服务   systemctl start firewalld</span><br><span class="line">关闭服务   systemctl stop firewalld</span><br><span class="line">查看状态   systemctl status firewalld </span><br><span class="line">开机禁用   systemctl disable firewalld</span><br><span class="line">开机启用   systemctl enable firewalld</span><br></pre></td></tr></table></figure></p>
<p>2.systemctl是CentOS7的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">启动一个服务：systemctl start firewalld.service</span><br><span class="line">关闭一个服务：systemctl stop firewalld.service</span><br><span class="line">重启一个服务：systemctl restart firewalld.service</span><br><span class="line">显示一个服务的状态：systemctl status firewalld.service</span><br><span class="line">在开机时启用一个服务：systemctl enable firewalld.service</span><br><span class="line">在开机时禁用一个服务：systemctl disable firewalld.service</span><br><span class="line">查看服务是否开机启动：systemctl is-enabled firewalld.service</span><br><span class="line">查看已启动的服务列表：systemctl list-unit-files|grep enabled</span><br><span class="line">查看启动失败的服务列表：systemctl --failed</span><br></pre></td></tr></table></figure>
<p>3.配置firewalld-cmd<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看版本： firewall-cmd --version</span><br><span class="line">查看帮助： firewall-cmd --help</span><br><span class="line">显示状态： firewall-cmd --state</span><br><span class="line">查看所有打开的端口： firewall-cmd --zone=public --list-ports</span><br><span class="line">更新防火墙规则： firewall-cmd --reload</span><br><span class="line">查看区域信息:  firewall-cmd --get-active-zones</span><br><span class="line">查看指定接口所属区域： firewall-cmd --get-zone-of-interface=eth0</span><br><span class="line">拒绝所有包：firewall-cmd --panic-on</span><br><span class="line">取消拒绝状态： firewall-cmd --panic-off</span><br><span class="line">查看是否拒绝： firewall-cmd --query-panic</span><br></pre></td></tr></table></figure></p>
<p>4.怎样在防火墙中开启一个端口呢？</p>
<ul>
<li><p>添加端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> firewall-cmd --zone=public --add-port=80/tcp --permanent    </span><br><span class="line">（--permanent永久生效，没有此参数重启后失效）</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新载入<br>  <code>firewall-cmd --reload</code></p>
</li>
<li><p>查看<br>  <code>firewall-cmd --zone= public --query-port=80/tcp</code></p>
</li>
<li><p>删除<br>  <code>firewall-cmd --zone= public --remove-port=80/tcp --permanent</code></p>
</li>
</ul>
<p>###10. centos7 常用命令</p>
<p>1、Apache 服务管理命令启动：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start httpd 启动</span><br><span class="line">systemctl stop httpd 停止</span><br><span class="line">systemctl restart httpd 重启</span><br><span class="line">systemctl status httpd 状态</span><br></pre></td></tr></table></figure></p>
<p>2、MySQL 服务管理命令启动：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start mysqld关闭：</span><br><span class="line">systemctl stop mysqld重启：</span><br><span class="line">systemctl restart mysqld状态：</span><br><span class="line">systemctl status mysqld</span><br></pre></td></tr></table></figure></p>
<p>3、FTP 服务管理命令启动：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start vsftpd   启动</span><br><span class="line">systemctl stop vsftpd    停止</span><br><span class="line">systemctl restart vsftpd 重启</span><br><span class="line">systemctl status vsftpd  状态</span><br></pre></td></tr></table></figure></p>
<ol start="4">
<li>Nginx服务管理命令启动<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start nginx 启动</span><br><span class="line">systemctl status nginx 查看状态</span><br><span class="line">systemctl stop nginx 停止</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>studyEnglish</title>
    <url>/2018/04/12/studyEnglish/</url>
    <content><![CDATA[<h3 id="2018-05-05"><a href="#2018-05-05" class="headerlink" title="2018-05-05"></a>2018-05-05</h3><p>The only wealth in this world is children. More than all the money and power on earth.<br>孩子们是世上唯一的财富，远胜于金钱和权力。</p>
<hr>
<h3 id="2018-05-04"><a href="#2018-05-04" class="headerlink" title="2018-05-04"></a>2018-05-04</h3><p>As you make your bed, so you must lie on it.<br>这是你自作自受</p>
<hr>
<h3 id="2018-05-03"><a href="#2018-05-03" class="headerlink" title="2018-05-03"></a>2018-05-03</h3><p>If you wanna change the world, start off by making your bed.<br>改变世界，从整理床铺开始</p>
<ul>
<li>解析<ul>
<li>start off （by） doing XX  从…开始;从…着手</li>
<li>start/get off on the wrong/right foot 一开始就很顺利/不顺</li>
<li>make your bed  整理床铺  </li>
</ul>
</li>
</ul>
<h3 id="2018-04-29"><a href="#2018-04-29" class="headerlink" title="2018-04-29"></a>2018-04-29</h3><p>The more we try to understand one another, the more exceptional each of us will be</p>
<ul>
<li>解析<ul>
<li>try to do 尽力做没事，有难度，能不能做好，不确定</li>
<li>try doing  尝试做某事，不涉及难度，试试看做完结果能否更好</li>
<li>one another=each other彼此</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2018-04-28"><a href="#2018-04-28" class="headerlink" title="2018-04-28"></a>2018-04-28</h3><p>Things happen the way they do. We may not know why at the time, but there must alway be a reason.</p>
<p>万物皆有准则</p>
<hr>
<h3 id="2018-04-26"><a href="#2018-04-26" class="headerlink" title="2018-04-26"></a>2018-04-26</h3><p>People make mistake.-It’s why they put rubbers on the ends of pencil.</p>
<p>人都会犯错，也因此铅笔头上会有橡皮</p>
<ul>
<li>解析<ul>
<li>make mistake犯错误 出岔子</li>
<li>rubbers橡皮</li>
<li>put rubbers on the ends of pencil在铅笔尾部放上橡皮</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2018-04-25"><a href="#2018-04-25" class="headerlink" title="2018-04-25"></a>2018-04-25</h3><p>I want you to gain the intelligence of spending time wisely, because while you’re killing time, time is killing you.</p>
<p>你消磨时间的时候，时间也在耗你</p>
<ul>
<li>解析<ul>
<li>gain intelligence of doing  获得做。。。的智慧</li>
<li>spend your time wisely 明智的利用时间</li>
<li>kill time 打发时间，消遣</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2018-04-20"><a href="#2018-04-20" class="headerlink" title="2018-04-20"></a>2018-04-20</h3><p>Every once in a while, you will find some who’s iridescent,and when you do,nothing will ever compare.</p>
<p>总有一天，你会遇到那个彩虹绚丽的/无与伦比的人</p>
<ul>
<li>解析<ul>
<li>irideacent彩虹色的，变色的</li>
<li>nothing will compare没有什么能比得上</li>
<li>every once in a while偶尔，每隔一阵子</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2018-04-13"><a href="#2018-04-13" class="headerlink" title="2018-04-13"></a>2018-04-13</h3><p>Life is a roller coaster,but I am tall enough to ride<br>你不可能凡是都成功。但是任何成功的愿景中都必须承认失败的存在</p>
<p>解析</p>
<pre><code>* roller coaster 过山车
* roller 滚筒
* coaster 船
</code></pre><hr>
<h3 id="2018-04-12"><a href="#2018-04-12" class="headerlink" title="2018-04-12"></a>2018-04-12</h3><p>You can not be successful at everything.So any vision of success has to admit what it is losing out on.<br>你不可能凡是都成功。但是任何成功的愿景中都必须承认失败的存在</p>
<p>解析</p>
<pre><code>* be successful at 在什么事情上成功
* vision of success成功的愿景
* lose out 失败、失去
</code></pre><hr>
<h3 id="2018-04-11"><a href="#2018-04-11" class="headerlink" title="2018-04-11"></a>2018-04-11</h3><p>Sometimes we act, not for ourselves, but because we believe plainly and simply it is the right thing to do.<br>有时我们行动不是为了自己，而是单纯相信那是正确的事</p>
<p>解析</p>
<pre><code>* myself 复数-&gt; ourselves
* act (for)  (为了)行动/代表
* believe plainly and simply  单纯的相信
* plainly明显地、简单地、朴素地
</code></pre>]]></content>
      <categories>
        <category>english</category>
      </categories>
      <tags>
        <tag>跟着lassie学英语</tag>
      </tags>
  </entry>
</search>
